---
title: "[상태 관리 3/5] 상태 관리 - Jotai"
date: "2025-09-03"
description: "원자(atom) 기반 상태 모델과 파생 상태 설계"
tags: ["React", "고급", "프론트엔드"]
series: "상태 관리"
seriesOrder: 3
---

# 상태 관리 - Jotai

Jotai는 원자(atom) 기반 상태 관리 라이브러리이다. 전역 store 하나를 크게 두는 대신, 상태를 작은 조각으로 쪼개고 의존 관계를 조립한다.

Zustand가 “store 중심”이라면, Jotai는 “상태 그래프 중심”이다.

---

## 1. Jotai가 필요한 순간

Jotai는 다음 요구가 강할 때 적합하다.

- 상태를 작은 조각으로 나누고, 조합(파생)해서 쓰고 싶다.
- 특정 상태 조각이 바뀔 때 필요한 컴포넌트만 리렌더링되게 만들고 싶다.
- 컴포넌트 트리와 상태 그래프가 비슷한 형태를 갖는다(설정 화면, 폼 마법사, 에디터).

반대로 “도메인 상태가 크고 규칙이 많다”면 Redux Toolkit 쪽이 더 적합할 수 있다.

---

## 2. 핵심 원리: atom과 파생 atom

atom은 상태의 최소 단위다.

```tsx
import { atom } from "jotai";

export const countAtom = atom(0);
```

파생 atom은 다른 atom을 읽어 계산한다.

```tsx
import { atom } from "jotai";
import { countAtom } from "./atoms";

export const doubleCountAtom = atom((get) => get(countAtom) * 2);
```

이 모델은 “계산된 상태(derived state)”를 컴포넌트 밖으로 빼서 규칙으로 고정한다.

---

## 3. 최소 예제: 읽기/쓰기 분리

```tsx
import { useAtomValue, useSetAtom } from "jotai";
import { countAtom } from "./atoms";

export function CounterView() {
  const count = useAtomValue(countAtom);
  return <div>{count}</div>;
}

export function CounterControls() {
  const setCount = useSetAtom(countAtom);
  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>+</button>
      <button onClick={() => setCount((c) => c - 1)}>-</button>
    </div>
  );
}
```

읽기 컴포넌트와 쓰기 컴포넌트를 분리하면 리렌더링 경계가 선명해진다.

---

## 4. 실무 예제: 장바구니 합계는 파생 상태로 둔다

장바구니 합계는 “원본 데이터(items)가 바뀌면 자동으로 계산되는 값”이다. 이런 값은 파생 atom으로 두는 편이 적합하다.

```tsx
import { atom } from "jotai";

type CartItem = { id: string; price: number; quantity: number };

export const cartItemsAtom = atom<CartItem[]>([]);

export const cartTotalAtom = atom((get) => {
  const items = get(cartItemsAtom);
  return items.reduce((sum, it) => sum + it.price * it.quantity, 0);
});
```

컴포넌트는 계산 로직을 모른다.

```tsx
import { useAtomValue } from "jotai";
import { cartTotalAtom } from "./cartAtoms";

export function CartTotal() {
  const total = useAtomValue(cartTotalAtom);
  return <div>{total}</div>;
}
```

이 구조는 “계산 규칙이 바뀌는 요구사항”에 강하다.

---

## 5. 영속화: `atomWithStorage`

UI 설정(테마, 언어, 마지막 선택)은 영속화가 자주 필요하다.

```tsx
import { atomWithStorage } from "jotai/utils";

export const themeAtom = atomWithStorage<"light" | "dark">("theme", "light");
```

---

## 6. 비동기 atom은 무엇을 의미하는가

Jotai는 async atom으로 비동기 값을 만들 수 있다. 이 패턴은 “상태 그래프 안에서 비동기를 조합한다”는 의미다.

다만 실무에서는 서버 상태는 React Query로 분리하는 기준이 더 안정적이다. async atom으로 서버 데이터를 들고 있으면 캐시/재시도/무효화 규칙을 Jotai 쪽에서 다시 설계하게 된다.

async atom은 다음에 가깝다.

- 로컬 계산이 비동기인 경우(예: 브라우저 API 기반)
- 단발성 로컬 리소스 로딩
- 서버 상태를 이미 React Query로 관리하는 상황에서 “UI 레벨 조합”만 필요할 때

---

## 7. 자주 터지는 함정

### 1) atom을 너무 잘게 쪼갠다

상태 조각이 지나치게 많아지면 추적 비용이 커진다. “파생 규칙이 복잡해지는 지점”에서 구조를 다시 잡아야 한다.

### 2) 비동기 atom으로 서버 상태를 만들기 시작한다

React Query와 역할이 겹치며, 결국 캐시/무효화 규칙이 분산된다.

### 3) 파생 atom이 무거운 계산을 반복한다

파생 계산이 비싸면 메모이제이션 전략과 데이터 구조를 점검해야 한다.

---

## Vue와 비교

Vue의 `ref`/`computed` 모델은 Jotai의 atom/derived atom과 개념적으로 닮아 있다. 차이는 “상태를 어디에 모으느냐”에서 나타난다.

| 관점 | Vue | Jotai |
| --- | --- | --- |
| 원본 상태 | `ref`, `reactive` | atom |
| 파생 상태 | `computed` | derived atom |
| 영속화 | 플러그인/직접 | `atomWithStorage` |
| 전역 구조 | Pinia store 중심이 흔함 | atom 그래프 중심 |

---

## 체크리스트

- atom과 derived atom의 역할을 구분할 수 있다.
- 계산된 상태를 컴포넌트 밖으로 빼는 이유를 설명할 수 있다.
- 서버 상태는 React Query로 분리하는 기준을 이해한다.
