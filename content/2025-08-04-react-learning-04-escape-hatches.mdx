---
title: "📚 [React 기초 4/4] 고급 Hook - useRef & useEffect"
date: "2025-08-04"
description: "useRef, useEffect의 동작 원리와 커스텀 Hook 작성법을 마스터합니다"
tags: ["React", "useRef", "useEffect", "Hook", "중급"]
---

# React 학습 가이드 - 탈출구 (Escape Hatches)

> React 공식 문서를 기반으로 한 학습 자료  
> 원문: [Escape Hatches - React](https://react.dev/learn/escape-hatches)

---

## 📚 목차

1. [개요](#개요)
2. [Ref로 값 참조하기](#ref로-값-참조하기)
3. [Ref로 DOM 조작하기](#ref로-dom-조작하기)
4. [Effect로 동기화하기](#effect로-동기화하기)
5. [Effect가 필요하지 않을 수도 있습니다](#effect가-필요하지-않을-수도-있습니다)
6. [반응형 Effect의 생명주기](#반응형-effect의-생명주기)
7. [Effect에서 이벤트 분리하기](#effect에서-이벤트-분리하기)
8. [Effect 의존성 제거하기](#effect-의존성-제거하기)
9. [커스텀 Hook으로 로직 재사용하기](#커스텀-hook으로-로직-재사용하기)

---

## 개요

일부 컴포넌트는 **React 외부의 시스템**을 제어하고 동기화해야 할 수 있습니다.

**예시:**

- 브라우저 API로 input에 포커스
- React 없이 작성된 비디오 플레이어 제어
- 원격 서버에 연결 및 수신

이런 "탈출구"를 통해 React 패러다임에서 벗어날 수 있지만, 남용하지 마세요!

### 이 챕터에서 배울 내용

- ✅ 리렌더링 없이 정보 "기억"하는 방법
- ✅ React가 관리하는 DOM 요소에 접근하는 방법
- ✅ 외부 시스템과 컴포넌트를 동기화하는 방법
- ✅ 불필요한 Effect를 제거하는 방법
- ✅ Effect의 생명주기가 컴포넌트와 다른 이유
- ✅ 일부 값이 Effect를 다시 트리거하지 않게 하는 방법
- ✅ Effect가 재실행되는 빈도를 줄이는 방법
- ✅ 컴포넌트 간에 로직을 공유하는 방법

---

## Ref로 값 참조하기

### State와 Ref의 차이

컴포넌트가 일부 정보를 "기억"하되, **리렌더링을 트리거하고 싶지 않을 때** `useRef`를 사용합니다.

```jsx
import { useRef } from 'react';

const ref = useRef(0);
```

**`useRef` 반환값:**

```javascript
{
  current: 0  // 초기값
}
```

### State vs Ref 비교

| 특징 | useRef | useState |
|------|--------|----------|
| **반환값** | `{ current: value }` | `[value, setValue]` |
| **변경 시 리렌더링** | ❌ 안함 | ✅ 함 |
| **변경 가능 (Mutable)** | ✅ 가능 (`ref.current` 수정) | ❌ 불가 (setter 함수 사용) |
| **렌더링 중 읽기/쓰기** | ❌ 불가 | ✅ 가능 |

### 예제: 스톱워치

```jsx
import { useState, useRef } from 'react';

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>
        Start
      </button>
      <button onClick={handleStop}>
        Stop
      </button>
    </>
  );
}
```

**`intervalRef` 사용 이유:**

- `setInterval`의 ID를 저장
- 렌더링에 영향 주지 않음
- `handleStop`에서 접근 가능

### Ref 사용 시기

**Ref는 다음과 같은 경우에 사용합니다:**

- timeout ID 저장
- DOM 요소 저장 (다음 섹션에서)
- JSX 계산에 필요 없는 다른 객체 저장

### Ref 모범 사례

#### 1. **Ref를 탈출구로 취급하세요**

```jsx
// ✅ 좋음: 외부 시스템/브라우저 API
const intervalRef = useRef(null);
const videoRef = useRef(null);

// ❌ 나쁨: React가 관리해야 할 정보
const dataRef = useRef([]);  // state를 사용하세요!
```

#### 2. **렌더링 중에 `ref.current` 읽기/쓰기 금지**

```jsx
// ❌ 잘못됨: 렌더링 중 ref 읽기
function MyComponent() {
  const myRef = useRef(0);
  myRef.current = myRef.current + 1;  // 예측 불가능!
  return <h1>{myRef.current}</h1>;
}

// ✅ 올바름: 이벤트 핸들러에서 사용
function MyComponent() {
  const myRef = useRef(0);
  
  function handleClick() {
    myRef.current = myRef.current + 1;
    console.log(myRef.current);
  }
  
  return <button onClick={handleClick}>Click me</button>;
}
```

### Ref 내부 동작

**직접 구현한다면:**

```jsx
// React가 내부적으로 하는 일
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

### 예제: 클릭 카운터

```jsx
import { useRef } from 'react';

export default function Counter() {
  let countRef = useRef(0);

  function handleClick() {
    // 증가하지만 리렌더링 안됨!
    countRef.current = countRef.current + 1;
    alert('You clicked ' + countRef.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}
```

**버튼을 여러 번 눌러도 화면은 변하지 않지만, alert는 증가된 값을 표시합니다.**

### Vue와 비교

```html
<!-- Vue: ref()는 반응형 -->
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++  // 자동 리렌더링!
}
</script>

<template>
  <button @click="increment">{{ count }}</button>
</template>
```

```jsx
// React: useRef는 비반응형
import { useRef } from 'react'

function Counter() {
  const countRef = useRef(0)
  
  function increment() {
    countRef.current++  // 리렌더링 안됨!
  }
  
  return <button onClick={increment}>Click</button>
}
```

**차이점:**

- Vue: `ref()`는 반응형 (화면 업데이트)
- React: `useRef()`는 비반응형 (화면 업데이트 안됨)

---

## Ref로 DOM 조작하기

### DOM 노드에 접근하기

React는 자동으로 DOM을 업데이트하므로 직접 조작할 일이 거의 없습니다. 하지만 때로는 필요합니다:

- input에 포커스
- 요소로 스크롤
- 크기와 위치 측정

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

**단계:**

1. `useRef`로 ref 선언
2. JSX의 `ref` 속성에 전달
3. React가 `<input>` DOM 노드를 `inputRef.current`에 저장

### Ref 콜백으로 ref 리스트 관리

```jsx
import { useRef } from 'react';

export default function CatFriends() {
  const itemsRef = useRef(null);

  function scrollToId(itemId) {
    const map = getMap();
    const node = map.get(itemId);
    node.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  function getMap() {
    if (!itemsRef.current) {
      // 처음 사용 시 Map 초기화
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }

  return (
    <>
      <nav>
        <button onClick={() => scrollToId(0)}>
          Tom
        </button>
        <button onClick={() => scrollToId(5)}>
          Maru
        </button>
        <button onClick={() => scrollToId(9)}>
          Jellylorum
        </button>
      </nav>
      <div>
        <ul>
          {catList.map(cat => (
            <li
              key={cat.id}
              ref={(node) => {
                const map = getMap();
                if (node) {
                  map.set(cat.id, node);
                } else {
                  map.delete(cat.id);
                }
              }}
            >
              <img src={cat.imageUrl} alt={cat.name} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

const catList = [];
for (let i = 0; i < 10; i++) {
  catList.push({
    id: i,
    imageUrl: 'https://placekitten.com/250/200?image=' + i
  });
}
```

**Ref 콜백:**

- `ref={(node) => { ... }}`
- React가 DOM 노드를 생성할 때 `node`로 호출
- DOM 노드가 제거될 때 `null`로 호출

### 다른 컴포넌트의 DOM 노드 접근

```jsx
// ❌ 작동하지 않음
function MyInput() {
  return <input />;
}

export default function Form() {
  const inputRef = useRef(null);
  return <MyInput ref={inputRef} />;  // 에러!
}
```

**해결책: `forwardRef` 사용**

```jsx
import { forwardRef, useRef } from 'react';

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

### useImperativeHandle로 노출되는 기능 제한

```jsx
import { forwardRef, useRef, useImperativeHandle } from 'react';

const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  
  useImperativeHandle(ref, () => ({
    // focus만 노출
    focus() {
      realInputRef.current.focus();
    },
  }));
  
  return <input {...props} ref={realInputRef} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();  // ✅ 가능
    // inputRef.current.value = 'Hi';  // ❌ 불가능 (노출 안됨)
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

### React가 ref를 첨부하는 시점

**React에서 모든 업데이트는 두 단계로 분할됩니다:**

1. **렌더**: React가 컴포넌트를 호출하여 화면에 무엇이 있어야 하는지 파악
2. **커밋**: React가 변경사항을 DOM에 적용

**Ref 첨부 시점:**

- **렌더 중**: `ref.current = null`
- **커밋 전**: React가 `ref.current`를 DOM 노드로 설정

### flushSync로 state 업데이트 강제

```jsx
import { useState, useRef } from 'react';
import { flushSync } from 'react-dom';

export default function TodoList() {
  const listRef = useRef(null);
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    
    flushSync(() => {
      setText('');
      setTodos([...todos, newTodo]);
    });
    
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={e => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
const initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}
```

### ref로 DOM 조작 시 모범 사례

**Ref는 탈출구입니다.** "React 밖으로 벗어나야" 할 때만 사용하세요.

**좋은 예:**

- 포커스 관리
- 스크롤 위치
- React가 노출하지 않는 브라우저 API 호출

**나쁜 예:**

```jsx
// ❌ 나쁨: React가 관리하는 DOM 수정
const divRef = useRef(null);
divRef.current.remove();  // React와 충돌!
divRef.current.appendChild(child);  // React가 혼란스러워함

// ✅ 좋음: React가 업데이트하지 않는 부분만 수정
divRef.current.scrollIntoView();
divRef.current.focus();
```

### Vue와 비교

```html
<!-- Vue: template ref -->
<script setup>
import { ref } from 'vue'

const inputRef = ref(null)

function focus() {
  inputRef.value.focus()
}
</script>

<template>
  <input ref="inputRef" />
  <button @click="focus">Focus</button>
</template>
```

```jsx
// React: useRef + ref 속성
import { useRef } from 'react'

function Form() {
  const inputRef = useRef(null)
  
  function focus() {
    inputRef.current.focus()
  }
  
  return (
    <>
      <input ref={inputRef} />
      <button onClick={focus}>Focus</button>
    </>
  )
}
```

---

## Effect로 동기화하기

### Effect란?

일부 컴포넌트는 **외부 시스템과 동기화**해야 합니다.

**예시:**

- React가 아닌 컴포넌트 제어
- 서버 연결 설정
- 분석 로그 전송

**Effect는 렌더링 후에 일부 코드를 실행하여 React 외부의 시스템과 동기화합니다.**

### Effect 작성하는 방법

#### 1단계: Effect 선언

```jsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // 여기에 코드 작성
  });
  return <div />;
}
```

#### 2단계: Effect 의존성 지정

```jsx
useEffect(() => {
  // 이 코드는 모든 렌더링 후에 실행됨
});

useEffect(() => {
  // 이 코드는 마운트 시에만 실행됨
}, []);

useEffect(() => {
  // 이 코드는 마운트 시 + a나 b가 변경될 때 실행됨
}, [a, b]);
```

#### 3단계: 필요하면 클린업 추가

```jsx
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  
  return () => {
    connection.disconnect();
  };
}, []);
```

### 예제: 채팅 연결

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');
  const [roomId, setRoomId] = useState('general');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <p>Welcome to the {roomId} room!</p>
    </>
  );
}
```

**동작:**

1. 컴포넌트 마운트 → Effect 실행 → 연결
2. `serverUrl` 또는 `roomId` 변경 → 클린업 실행 (연결 해제) → Effect 재실행 (새 연결)
3. 컴포넌트 언마운트 → 클린업 실행 (연결 해제)

### 개발 모드에서 Effect가 두 번 실행되는 이유

**Strict Mode**에서 React는 컴포넌트를 **두 번** 마운트합니다:

```
마운트 → 클린업 → 재마운트
```

**이유:** 클린업 로직이 제대로 작동하는지 테스트

```jsx
useEffect(() => {
  console.log('✅ 연결 중...');
  const connection = createConnection();
  connection.connect();
  
  return () => {
    console.log('❌ 연결 해제 중...');
    connection.disconnect();
  };
}, []);
```

**콘솔 출력 (개발 모드):**

```
✅ 연결 중...
❌ 연결 해제 중...
✅ 연결 중...
```

**프로덕션에서는 한 번만 실행됩니다.**

### Effect가 필요하지 않은 경우

**다음과 같은 경우 Effect가 필요하지 않습니다:**

#### 1. **렌더링을 위한 데이터 변환**

```jsx
// ❌ 나쁨: Effect로 계산
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const [fullName, setFullName] = useState('');

useEffect(() => {
  setFullName(firstName + ' ' + lastName);
}, [firstName, lastName]);

// ✅ 좋음: 렌더링 중 계산
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const fullName = firstName + ' ' + lastName;
```

#### 2. **사용자 이벤트 처리**

```jsx
// ❌ 나쁨: Effect로 처리
useEffect(() => {
  if (isSubmitted) {
    post('/api/register', { email });
  }
}, [isSubmitted, email]);

// ✅ 좋음: 이벤트 핸들러에서 처리
function handleSubmit() {
  post('/api/register', { email });
}
```

### Vue와 비교

```html
<!-- Vue: onMounted, onUnmounted -->
<script setup>
import { onMounted, onUnmounted } from 'vue'

onMounted(() => {
  const connection = createConnection()
  connection.connect()
  
  onUnmounted(() => {
    connection.disconnect()
  })
})
</script>
```

```jsx
// React: useEffect
import { useEffect } from 'react'

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection()
    connection.connect()
    
    return () => {
      connection.disconnect()
    }
  }, [])
}
```

**차이점:**

- Vue: `onMounted`, `onUnmounted` 분리
- React: `useEffect`에서 클린업 함수 반환

---

## Effect가 필요하지 않을 수도 있습니다

Effect는 React 코드에서 "벗어나" 외부 시스템과 동기화하는 데 사용됩니다. **Effect를 남용하지 마세요!**

### 불필요한 Effect 제거하기

#### 1. **렌더링을 위한 데이터 변환에 Effect 불필요**

```jsx
// ❌ 불필요한 Effect
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  const [fullName, setFullName] = useState('');

  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}

// ✅ 렌더링 중 계산
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  const fullName = firstName + ' ' + lastName;
  // ...
}
```

#### 2. **비싼 계산 캐싱에는 useMemo**

```jsx
// ❌ 느림: 매 렌더링마다 재계산
function TodoList({ todos, filter }) {
  const visibleTodos = getFilteredTodos(todos, filter);  // 느린 함수
  // ...
}

// ✅ 빠름: todos나 filter가 변경될 때만 재계산
import { useMemo } from 'react';

function TodoList({ todos, filter }) {
  const visibleTodos = useMemo(() => {
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
  // ...
}
```

#### 3. **Props 변경 시 모든 state 재설정**

```jsx
// ❌ 나쁨: Effect로 재설정
export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  useEffect(() => {
    setComment('');
  }, [userId]);
  // ...
}

// ✅ 좋음: key로 재설정
export default function ProfilePage({ userId }) {
  return (
    <Profile
      userId={userId}
      key={userId}
    />
  );
}

function Profile({ userId }) {
  const [comment, setComment] = useState('');
  // userId가 변경되면 Profile이 재마운트되어 comment가 ''로 리셋됨
  // ...
}
```

#### 4. **Props 변경 시 일부 state 조정**

```jsx
// ❌ 나쁨: Effect로 동기화
function List({ items }) {
  const [selection, setSelection] = useState(null);

  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}

// ✅ 좋음: 렌더링 중 조정
function List({ items }) {
  const [selectedId, setSelectedId] = useState(null);
  const [prevItems, setPrevItems] = useState(items);
  
  if (items !== prevItems) {
    setPrevItems(items);
    setSelectedId(null);
  }
  // ...
}

// ✅ 더 좋음: 모든 것을 렌더링 중 계산
function List({ items }) {
  const [selectedId, setSelectedId] = useState(null);
  const selection = items.find(item => item.id === selectedId) ?? null;
  // ...
}
```

#### 5. **이벤트 핸들러 간 로직 공유**

```jsx
// ❌ 나쁨: Effect로 처리
function ProductPage({ product, addToCart }) {
  useEffect(() => {
    if (product.isInCart) {
      showNotification(`Added ${product.name} to the shopping cart!`);
    }
  }, [product]);

  function handleBuyClick() {
    addToCart(product);
  }

  function handleCheckoutClick() {
    addToCart(product);
    navigateTo('/checkout');
  }
  // ...
}

// ✅ 좋음: 이벤트 핸들러에서 호출
function ProductPage({ product, addToCart }) {
  function buyProduct() {
    addToCart(product);
    showNotification(`Added ${product.name} to the shopping cart!`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo('/checkout');
  }
  // ...
}
```

#### 6. **POST 요청 보내기**

```jsx
// ❌ 나쁨: 렌더링 시마다 전송
function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  useEffect(() => {
    post('/analytics/event', { eventName: 'edit_form' });
  }, [firstName, lastName]);

  function handleSubmit(e) {
    e.preventDefault();
    post('/api/register', { firstName, lastName });
  }
  // ...
}

// ✅ 좋음: 적절한 시점에 전송
function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  function handleSubmit(e) {
    e.preventDefault();
    post('/api/register', { firstName, lastName });
    post('/analytics/event', { eventName: 'submit_form' });
  }

  function handleChange(e) {
    setFirstName(e.target.value);
    post('/analytics/event', { eventName: 'edit_form' });
  }
  // ...
}
```

#### 7. **연쇄 계산**

```jsx
// ❌ 나쁨: 연쇄 Effect
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);
  const [isGameOver, setIsGameOver] = useState(false);

  useEffect(() => {
    if (card !== null && card.gold) {
      setGoldCardCount(c => c + 1);
    }
  }, [card]);

  useEffect(() => {
    if (goldCardCount > 3) {
      setRound(r => r + 1);
      setGoldCardCount(0);
    }
  }, [goldCardCount]);

  useEffect(() => {
    if (round > 5) {
      setIsGameOver(true);
    }
  }, [round]);

  useEffect(() => {
    alert('Good game!');
  }, [isGameOver]);
  // ...
}

// ✅ 좋음: 렌더링 중 계산 또는 이벤트 핸들러에서 처리
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);

  const isGameOver = round > 5;

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('Game already ended.');
    }

    setCard(nextCard);
    if (nextCard.gold) {
      if (goldCardCount <= 3) {
        setGoldCardCount(goldCardCount + 1);
      } else {
        setGoldCardCount(0);
        setRound(round + 1);
        if (round === 5) {
          alert('Good game!');
        }
      }
    }
  }
  // ...
}
```

#### 8. **애플리케이션 초기화**

```jsx
// ❌ 나쁨: Effect로 초기화 (두 번 실행될 수 있음)
function App() {
  useEffect(() => {
    loadDataFromLocalStorage();
    checkAuthToken();
  }, []);
  // ...
}

// ✅ 좋음: 최상위에서 한 번만 실행
if (typeof window !== 'undefined') {
  loadDataFromLocalStorage();
  checkAuthToken();
}

function App() {
  // ...
}
```

#### 9. **부모에게 state 변경 알리기**

```jsx
// ❌ 나쁨: Effect로 부모에게 알림
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  useEffect(() => {
    onChange(isOn);
  }, [isOn, onChange]);

  function handleClick() {
    setIsOn(!isOn);
  }
  // ...
}

// ✅ 좋음: 이벤트 핸들러에서 함께 처리
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  function handleClick() {
    const nextIsOn = !isOn;
    setIsOn(nextIsOn);
    onChange(nextIsOn);
  }
  // ...
}
```

#### 10. **부모에게 데이터 전달**

```jsx
// ❌ 나쁨: Effect로 전달
function Parent() {
  const [data, setData] = useState(null);
  return <Child onFetched={setData} />;
}

function Child({ onFetched }) {
  const data = useSomeAPI();
  
  useEffect(() => {
    if (data) {
      onFetched(data);
    }
  }, [onFetched, data]);
  // ...
}

// ✅ 좋음: 부모가 데이터 페칭
function Parent() {
  const data = useSomeAPI();
  return <Child data={data} />;
}

function Child({ data }) {
  // ...
}
```

### Effect를 사용해야 하는 경우

**외부 시스템과 동기화할 때만 사용하세요:**

- 브라우저 API (타이머, 네트워크 등)
- 서드파티 위젯
- 네트워크 연결
- 브라우저 DOM (포커스, 스크롤 등)

---

## 반응형 Effect의 생명주기

### Effect의 생명주기는 컴포넌트와 다릅니다

**컴포넌트:**

- 마운트 (Mount)
- 업데이트 (Update)
- 언마운트 (Unmount)

**Effect:**

- 동기화 시작 (Start synchronizing)
- 동기화 중지 (Stop synchronizing)

### 예제: 채팅방

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to {roomId}!</h1>;
}
```

**생명주기:**

1. `roomId = "general"`로 마운트
   - Effect: `general` 방에 연결

2. `roomId = "travel"`로 업데이트
   - Effect 클린업: `general` 방 연결 해제
   - Effect: `travel` 방에 연결

3. 컴포넌트 언마운트
   - Effect 클린업: `travel` 방 연결 해제

### 의존성 배열의 중요성

```jsx
// ❌ 경고: roomId가 의존성에 없음
useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => connection.disconnect();
}, []); // 🔴 React Hook useEffect has a missing dependency: 'roomId'

// ✅ 올바름
useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => connection.disconnect();
}, [roomId]);
```

### 각 Effect는 독립적인 동기화 프로세스

```jsx
// ❌ 나쁨: 관련 없는 로직을 하나의 Effect에
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
}

// ✅ 좋음: 각 동기화 프로세스를 별도 Effect로
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
}
```

### Effect는 반응형 값에 "반응"합니다

```jsx
function ChatRoom({ roomId, serverUrl }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
  // ...
}
```

**반응형 값:**

- Props
- State
- 컴포넌트 본문에 직접 선언된 변수와 함수

**비반응형 값:**

- 컴포넌트 외부의 값
- `ref.current` (의도적으로 변경 가능)

### 빈 의존성 배열 `[]`

```jsx
useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => connection.disconnect();
}, []); // 마운트 시에만 실행
```

**의미:** "컴포넌트가 마운트될 때만 실행"

⚠️ **주의:** 반응형 값을 사용하는데 의존성에 없으면 버그 발생!

---

## Effect에서 이벤트 분리하기

### 이벤트 핸들러 vs Effect

**이벤트 핸들러:**

- 특정 상호작용에 응답
- 수동으로 트리거

**Effect:**

- 동기화가 필요할 때마다 실행
- 자동으로 트리거

### 문제: Effect가 너무 자주 실행됨

```jsx
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);  // theme 변경 시에도 재연결! 😱
  // ...
}
```

### 해결: useEffectEvent (실험적)

```jsx
import { useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);  // theme은 의존성 아님!
  // ...
}
```

**`useEffectEvent`:**

- Effect에서 비반응형 로직 추출
- 항상 최신 props와 state 사용
- 의존성에 포함하지 않음

### Effect Event 제한사항

- **Effect 내부에서만 호출**
- **다른 컴포넌트나 Hook에 전달 금지**

```jsx
// ❌ 잘못됨
function Timer() {
  const [count, setCount] = useState(0);

  const onTick = useEffectEvent(() => {
    setCount(count + 1);
  });

  useTimer(() => {
    onTick();  // 다른 Hook에서 호출 불가!
  }, 1000);
  // ...
}

// ✅ 올바름
function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const onTick = () => {
      setCount(count + 1);
    };

    const id = setInterval(onTick, 1000);
    return () => clearInterval(id);
  }, [count]);
  // ...
}
```

---

## Effect 의존성 제거하기

### 불필요한 의존성 제거

#### 1. **객체 의존성**

```jsx
// ❌ 나쁨: 객체는 매 렌더링마다 재생성
function ChatRoom({ options }) {
  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);  // 매 렌더링마다 재연결!
}

function App() {
  const [isDark, setIsDark] = useState(false);
  const options = { serverUrl: 'https://localhost:1234', roomId: 'music' };
  return <ChatRoom options={options} />;
}

// ✅ 좋음: 필요한 값만 의존성으로
function ChatRoom({ options }) {
  const { serverUrl, roomId } = options;
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [serverUrl, roomId]);
}
```

#### 2. **함수 의존성**

```jsx
// ❌ 나쁨: 함수는 매 렌더링마다 재생성
function ChatRoom({ getOptions }) {
  useEffect(() => {
    const options = getOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [getOptions]);  // 매 렌더링마다 재연결!
}

// ✅ 좋음: 함수를 Effect 안으로
function ChatRoom({ roomId }) {
  useEffect(() => {
    function getOptions() {
      return { serverUrl: 'https://localhost:1234', roomId };
    }
    
    const options = getOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
}
```

#### 3. **동적 객체/함수 생성**

```jsx
// ❌ 나쁨
function ChatRoom({ roomId }) {
  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
}

// ✅ 좋음
function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);  // serverUrl은 컴포넌트 외부의 상수
}

const serverUrl = 'https://localhost:1234';
```

### State로부터 다음 state 계산

```jsx
// ❌ 나쁨: messages가 의존성
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId, messages]);  // messages 변경 시마다 재연결!
}

// ✅ 좋음: 업데이터 함수 사용
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId]);  // messages는 의존성 아님!
}
```

### 값을 읽되 "반응"하고 싶지 않을 때

```jsx
// ❌ 나쁨: theme 변경 시 재연결
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);
}

// ✅ 좋음: Effect Event 사용
function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', onConnected);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
}
```

---

## 커스텀 Hook으로 로직 재사용하기

### 커스텀 Hook이란?

**커스텀 Hook**은 컴포넌트 로직을 재사용 가능한 함수로 추출한 것입니다.

**명명 규칙:** `use`로 시작

```jsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return isOnline;
}
```

### 커스텀 Hook 사용

```jsx
function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('✅ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}
```

### 커스텀 Hook은 state를 공유하지 않습니다

```jsx
// 각 컴포넌트는 독립적인 isOnline state를 가짐
function StatusBar() {
  const isOnline = useOnlineStatus();  // 독립적
  // ...
}

function SaveButton() {
  const isOnline = useOnlineStatus();  // 독립적
  // ...
}
```

### 커스텀 Hook 예제 모음

#### 1. **useLocalStorage**

```jsx
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    const saved = localStorage.getItem(key);
    return saved !== null ? JSON.parse(saved) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

// 사용
function App() {
  const [name, setName] = useLocalStorage('name', '');
  
  return (
    <input
      value={name}
      onChange={e => setName(e.target.value)}
    />
  );
}
```

#### 2. **useWindowSize**

```jsx
import { useState, useEffect } from 'react';

function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    function handleResize() {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return size;
}

// 사용
function App() {
  const { width, height } = useWindowSize();
  return <p>Window size: {width} x {height}</p>;
}
```

#### 3. **useFetch**

```jsx
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    setError(null);

    fetch(url)
      .then(response => response.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error);
        setLoading(false);
      });
  }, [url]);

  return { data, loading, error };
}

// 사용
function UserProfile({ userId }) {
  const { data, loading, error } = useFetch(`/api/users/${userId}`);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;
  return <h1>{data.name}</h1>;
}
```

#### 4. **useDebounce**

```jsx
import { useState, useEffect } from 'react';

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// 사용
function SearchBar() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // API 호출
      searchAPI(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <input
      value={searchTerm}
      onChange={e => setSearchTerm(e.target.value)}
    />
  );
}
```

#### 5. **usePrevious**

```jsx
import { useRef, useEffect } from 'react';

function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

// 사용
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <h1>Now: {count}, before: {prevCount}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

#### 6. **useInterval**

```jsx
import { useEffect, useRef } from 'react';

function useInterval(callback, delay) {
  const savedCallback = useRef();

  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  useEffect(() => {
    function tick() {
      savedCallback.current();
    }
    
    if (delay !== null) {
      const id = setInterval(tick, delay);
      return () => clearInterval(id);
    }
  }, [delay]);
}

// 사용
function Counter() {
  const [count, setCount] = useState(0);

  useInterval(() => {
    setCount(count + 1);
  }, 1000);

  return <h1>{count}</h1>;
}
```

### 커스텀 Hook 작성 모범 사례

#### 1. **이름은 `use`로 시작**

```jsx
// ✅ 좋음
function useOnlineStatus() { }
function useFormInput() { }
function useFetch() { }

// ❌ 나쁨
function getOnlineStatus() { }
function formInput() { }
```

#### 2. **높은 수준의 사용 사례에 집중**

```jsx
// ❌ 나쁨: 너무 일반적
function useEffect2(fn, deps) {
  // ...
}

// ✅ 좋음: 구체적인 목적
function useChatRoom({ serverUrl, roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [serverUrl, roomId]);
}
```

#### 3. **Hook은 순수해야 합니다**

```jsx
// ✅ 좋음: 순수 함수
function useFormInput(initialValue) {
  const [value, setValue] = useState(initialValue);
  
  function handleChange(e) {
    setValue(e.target.value);
  }
  
  return {
    value,
    onChange: handleChange
  };
}

// ❌ 나쁨: 부작용
function useFormInput(initialValue) {
  console.log('Rendering!');  // 순수하지 않음
  const [value, setValue] = useState(initialValue);
  return { value, setValue };
}
```

#### 4. **이벤트 핸들러를 Hook으로 추출하지 마세요**

```jsx
// ❌ 나쁨
function useSubmit(onSubmit) {
  return (e) => {
    e.preventDefault();
    onSubmit();
  };
}

// ✅ 좋음: 일반 함수로
function handleSubmit(e, onSubmit) {
  e.preventDefault();
  onSubmit();
}
```

### Vue와 비교

```javascript
// Vue: Composables (커스텀 Hook과 유사)
import { ref, onMounted, onUnmounted } from 'vue'

export function useOnlineStatus() {
  const isOnline = ref(true)

  function handleOnline() {
    isOnline.value = true
  }

  function handleOffline() {
    isOnline.value = false
  }

  onMounted(() => {
    window.addEventListener('online', handleOnline)
    window.addEventListener('offline', handleOffline)
  })

  onUnmounted(() => {
    window.removeEventListener('online', handleOnline)
    window.removeEventListener('offline', handleOffline)
  })

  return { isOnline }
}
```

---

## 다음 단계

### 이 챕터에서 배운 내용 요약

✅ **useRef**: 리렌더링 없이 값 기억  
✅ **DOM Ref**: DOM 노드에 접근  
✅ **useEffect**: 외부 시스템과 동기화  
✅ **Effect 최적화**: 불필요한 Effect 제거  
✅ **Effect 생명주기**: 동기화 시작/중지  
✅ **Effect Event**: 비반응형 로직 분리  
✅ **의존성 제거**: Effect 최적화  
✅ **커스텀 Hook**: 로직 재사용

### 연습 문제

#### 1. 타이머 구현

```jsx
// TODO: useInterval 커스텀 Hook 사용하여 타이머 구현
// - 시작/정지/리셋 기능
// - 분:초 형식으로 표시
import { useState } from 'react';
import { useInterval } from './useInterval';

export default function Timer() {
  // 여기에 코드 작성
}
```

#### 2. 무한 스크롤

```jsx
// TODO: useIntersectionObserver 커스텀 Hook 구현
// - 스크롤 끝에 도달하면 더 많은 데이터 로드
// - 로딩 인디케이터 표시
```

#### 3. 폼 검증

```jsx
// TODO: useFormValidation 커스텀 Hook 구현
// - 실시간 검증
// - 에러 메시지 표시
// - 제출 가능 여부 체크
```

### 축하합니다! 🎉

React 공식 문서의 **Learn React** 섹션을 모두 완료했습니다!

**다음 학습 단계:**

1. **API Reference**: Hook과 컴포넌트 API 상세 학습
2. **실전 프로젝트**: 배운 내용을 활용한 프로젝트 구축
3. **고급 패턴**: Suspense, Concurrent Rendering 등
4. **라이브러리**: React Router, React Query, Zustand 등

---

## 참고 자료

- [React 공식 문서 - Escape Hatches](https://react.dev/learn/escape-hatches)
- [React 공식 문서 - API Reference](https://react.dev/reference/react)
- [useEffect Hook](https://react.dev/reference/react/useEffect)
- [useRef Hook](https://react.dev/reference/react/useRef)
- [커스텀 Hook](https://react.dev/learn/reusing-logic-with-custom-hooks)

---

**작성일**: 2025-10-11  
**출처**: [React Official Documentation](https://react.dev/learn/escape-hatches)  
**대상**: React 중급-고급 학습자

---

## 학습 체크리스트

- [ ] useRef를 적절히 사용할 수 있다
- [ ] DOM Ref로 요소를 조작할 수 있다
- [ ] useEffect를 올바르게 사용할 수 있다
- [ ] 불필요한 Effect를 제거할 수 있다
- [ ] Effect 의존성을 올바르게 관리할 수 있다
- [ ] Effect Event를 사용할 수 있다
- [ ] 커스텀 Hook을 작성할 수 있다
- [ ] 로직을 재사용 가능하게 추출할 수 있다

모든 항목을 체크했다면 React 마스터입니다! 🚀
