---
title: "[React 성능 1/3] 최적화 기초 - 렌더링과 측정"
date: "2025-09-29"
description: "측정으로 병목을 분류하고, React 렌더링 비용을 줄이는 기본 원리를 정리한다"
tags: ["React", "성능", "중급", "프론트엔드"]
series: "React 성능"
seriesOrder: 1
---

# 성능 최적화는 측정부터 시작한다

React 성능 최적화의 핵심은 기술 목록이 아니라 “어디가 느린가”를 분류하는 능력이다.
측정 없이 최적화를 시작하면, 대부분은 비용만 늘고 결과는 불확실해진다.

이 글은 다음 순서로 정리한다.

- 측정 모델: Lab과 Field, 지표의 의미
- 원인 분류: CPU/네트워크/레이아웃/입력 지연
- React 관점: 렌더 비용을 줄이는 기본 도구와 함정

## Lab과 Field를 구분한다

성능은 두 종류의 데이터로 본다.

| 구분 | 의미 | 예시 | 장단점 |
| --- | --- | --- | --- |
| Lab(실험실) | 재현 가능한 측정 | Chrome DevTools, Lighthouse, React Profiler | 원인 분석에 강하다. 실제 사용자 분포는 놓친다 |
| Field(현장) | 실제 사용자 측정(RUM) | Web Vitals 수집, 로그 기반 지표 | 현실을 반영한다. 원인 분해가 어렵다 |

최적화 작업의 기본 루프는 다음이다.

1. Field에서 문제가 있다는 신호를 잡는다
2. Lab에서 재현하고 원인을 분해한다
3. 변경 후 Lab에서 회귀 여부를 확인한다
4. Field에서 실제 개선이 일어났는지 확인한다

## 지표의 의미를 먼저 고정한다

프런트엔드 성능 문제는 대개 다음 축으로 분해된다.

- **LCP**: 주요 콘텐츠가 보이기까지 걸린 시간이다. 이미지, 폰트, 큰 렌더 비용이 흔한 원인이다.
- **CLS**: 레이아웃이 얼마나 흔들렸는지다. 이미지 크기 미지정, 동적 삽입이 흔한 원인이다.
- **INP**: 입력(클릭, 타이핑)에 대한 반응 지연이다. 긴 작업(long task), 과도한 렌더링이 흔한 원인이다.
- **네트워크 워터폴**: 데이터/코드/이미지 로딩 순서가 직렬화되어 전체 시간을 늘린다.

React 최적화는 보통 INP와 CPU 비용(스크립팅/렌더)을 줄이는 데 직접 연결된다. LCP/CLS는 자산과 레이아웃 설계가 더 큰 축이다.

## React 렌더링의 비용 구조

React에서 “느림”은 다음 중 하나로 나타난다.

- **렌더가 자주 일어난다**: 리렌더링 빈도가 높다
- **렌더 1회가 비싸다**: 리스트, 큰 계산, 비싼 컴포넌트가 있다
- **커밋 이후가 비싸다**: 레이아웃 계산, 페인트가 크다

React의 렌더링은 대략 다음 단계로 이해하면 된다.

```text
1) render: 컴포넌트 함수 실행, 다음 UI 트리 계산
2) commit: 변경 사항을 DOM에 반영
3) paint: 브라우저가 화면을 그린다
```

## 리렌더링이 발생하는 조건

리렌더링은 다음 조건에서 발생한다.

1. **state 변경**
2. **props 변경**
3. **부모 리렌더링**

여기서 “부모 리렌더링”이 실무 병목의 대부분이다. 상태가 상위에 있으면 영향 범위가 커진다.

## 측정: React Profiler로 리렌더 원인을 본다

React DevTools Profiler는 “어떤 컴포넌트가 얼마나 자주, 얼마나 오래 렌더링되는가”를 보여준다.
이 데이터로 다음 질문에 답해야 한다.

- 어떤 상호작용에서 느려지는가
- 어떤 컴포넌트가 렌더 시간을 소비하는가
- 왜 다시 렌더되는가(props, state, context)

코드 레벨로는 `Profiler` 컴포넌트도 쓸 수 있다.

```tsx
import React, { Profiler } from "react";

function onRender(
  id: string,
  phase: "mount" | "update",
  actualDuration: number,
) {
  console.log({ id, phase, actualDuration });
}

export function AppProfiler({ children }: { children: React.ReactNode }) {
  return (
    <Profiler id="App" onRender={onRender}>
      {children}
    </Profiler>
  );
}
```

이 값은 “대략적인 비용”이다. 최종 판단은 브라우저 Performance 패널과 함께 해야 한다.

## 처방 0순위: 상태 위치를 내려서 영향 범위를 줄인다

`React.memo`나 `useMemo`는 CPU 비용을 줄이는 도구다. 그 이전에 “영향 범위”를 줄이는 설계가 먼저다.

```tsx
import React from "react";

function Page() {
  // 나쁜 예: Page의 state 하나가 전체를 리렌더링한다
  const [open, setOpen] = React.useState(false);

  return (
    <div>
      <button onClick={() => setOpen((v) => !v)}>toggle</button>
      <ExpensiveList />
      <Modal open={open} />
    </div>
  );
}
```

`open`이 리스트와 무관하면, state를 Modal 근처로 옮기는 편이 영향 범위를 줄인다.

## React.memo: 리렌더링을 “허용된 경우”로 제한한다

`React.memo`는 props가 동일하면 이전 렌더 결과를 재사용한다. 기본 비교는 얕은 비교다.

```tsx
import React from "react";

const Child = React.memo(function Child({ name }: { name: string }) {
  return <div>{name}</div>;
});

export function Parent() {
  const [count, setCount] = React.useState(0);
  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>{count}</button>
      <Child name="John" />
    </div>
  );
}
```

커스텀 비교 함수는 최후 수단이다. 비교 로직 자체가 비용이 될 수 있고, 버그를 만들기 쉽다.

## useMemo: 비싼 계산을 캐시한다

`useMemo`는 “계산 결과”를 캐시한다. 가장 흔한 사용처는 정렬, 필터링, 매핑 비용이 큰 리스트다.

```tsx
import React from "react";

type Item = { id: string; price: number };

export function SortedList({ items }: { items: Item[] }) {
  const sorted = React.useMemo(() => {
    return [...items].sort((a, b) => a.price - b.price);
  }, [items]);

  return (
    <ul>
      {sorted.map((item) => (
        <li key={item.id}>{item.price}</li>
      ))}
    </ul>
  );
}
```

## useCallback: 함수 참조를 안정화한다

`useCallback`은 함수 자체가 빨라지는 것이 아니라, 함수 참조가 바뀌지 않게 만든다.
`React.memo`와 함께 쓸 때 의미가 커진다.

```tsx
import React from "react";

const Button = React.memo(function Button({
  onClick,
}: {
  onClick: () => void;
}) {
  return <button onClick={onClick}>click</button>;
});

export function Page() {
  const [count, setCount] = React.useState(0);

  const onClick = React.useCallback(() => {
    setCount((c) => c + 1);
  }, []);

  return (
    <div>
      <div>{count}</div>
      <Button onClick={onClick} />
    </div>
  );
}
```

## 흔한 함정

### 1) useMemo/useCallback 남용

메모이제이션에도 비용이 있다. “느리다”는 신호가 없으면 적용하지 않는다.

### 2) 참조 동일성 깨짐

부모가 매번 새 객체/새 배열을 props로 만들면 `React.memo`가 의미를 잃는다.

### 3) key 설계 오류

리스트에서 index를 key로 쓰면, 재정렬/삽입에서 DOM 재사용이 깨져 비용이 커질 수 있다.

## Vue와 비교

Vue의 반응성은 “어떤 데이터가 바뀌면 어떤 컴포넌트가 갱신되는가”를 추적하는 편이다.
React는 “상태가 바뀌면 해당 컴포넌트를 다시 실행해서 다음 UI를 계산한다”에 가깝다.

실무 관점에서는 다음 차이가 남는다.

- React: 상태 위치와 props 경계가 리렌더 비용을 크게 좌우한다
- Vue: 반응성 추적이 갱신 범위를 줄이기도 하지만, 컴포지션 구조에 따라 추적 비용이 증가할 수 있다

## 체크리스트

- [ ] Field와 Lab 측정의 차이를 설명할 수 있다
- [ ] LCP/CLS/INP가 무엇을 의미하는지 설명할 수 있다
- [ ] React Profiler로 “무엇이, 왜” 렌더링되는지 추적할 수 있다
- [ ] 상태 위치를 내려 영향 범위를 줄일 수 있다
- [ ] `React.memo`, `useMemo`, `useCallback`을 측정 결과 기반으로 적용할 수 있다
