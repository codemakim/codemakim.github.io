---
title: "⚡ [React 성능 1/3] 최적화 기초 - 렌더링 원리"
date: "2025-09-29"
description: "React 렌더링 3단계 프로세스와 React.memo, useMemo, useCallback의 동작 원리를 이해합니다"
tags: ["React", "성능", "중급"]
---

# React 성능 최적화 기초

> React 애플리케이션 성능 최적화 학습 자료

---

## 📚 목차

1. [개요](#개요)
2. [React.memo](#reactmemo)
3. [useMemo](#usememo)
4. [useCallback](#usecallback)
5. [성능 측정](#성능-측정)
6. [최적화 체크리스트](#최적화-체크리스트)

---

## 개요

### 성능 최적화가 필요한 이유

**불필요한 리렌더링:**

- 부모 컴포넌트가 리렌더링되면 모든 자식도 리렌더링
- 큰 리스트나 복잡한 계산은 성능 저하

### 🔍 React 렌더링의 동작 원리 (핵심!)

**렌더링이 발생하는 3가지 경우:**

1. **State 변경**

   ```jsx
   const [count, setCount] = useState(0);
   setCount(1);  // 이 컴포넌트 리렌더링 트리거!
   ```

2. **Props 변경**

   ```jsx
   <Child name={name} />  // name 변경 → Child 리렌더링

   ```

3. **부모 리렌더링**

   ```jsx
   function Parent() {
     const [count, setCount] = useState(0);
     return (
       <div>
         <button onClick={() => setCount(count + 1)}>
           {count}
         </button>
         <Child />  {/* count 변경 → Child도 리렌더링! */}
       </div>
     );
   }
   ```

### 🎯 React의 렌더링 프로세스 (상세)

```
1. 렌더 단계 (Render Phase)
   → 컴포넌트 함수 호출
   → 새 Virtual DOM 생성
   → 이전 Virtual DOM과 비교 (Diffing/Reconciliation)
   → 변경사항 목록 생성

2. 커밋 단계 (Commit Phase)
   → 변경사항만 실제 DOM에 적용
   → useEffect 실행
   → 브라우저가 화면 페인팅
```

**왜 느릴 수 있나?**

```jsx
// 문제 상황
function App() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      
      {/* 10,000개 항목 */}
      {items.map(item => (
        <ExpensiveItem key={item.id} data={item} />
      ))}
    </div>
  );
}

// count 변경 시:
// 1. App 리렌더링
// 2. 10,000개 ExpensiveItem 모두 리렌더링!
// 3. 각각 Virtual DOM 생성 & 비교
// 4. 결과: 버튼 하나만 변경
// → 불필요한 작업 9,999개!
```

### 💡 실무 TIP: "리렌더링은 왜 발생하고 어떻게 방지하나요?"

**답변 예시:**

"React에서 리렌더링은 3가지 경우에 발생합니다: State 변경, Props 변경, 부모 리렌더링.

**핵심 문제:**
부모가 리렌더링되면 기본적으로 **모든 자식 컴포넌트**가 리렌더링됩니다. Props가 변경되지 않았어도요.

**왜 이렇게 설계됐나?**
안전성 우선입니다. React는 모든 컴포넌트를 리렌더링하여 UI가 항상 최신 state를 반영하도록 보장합니다.

**최적화 방법:**

1. **React.memo**: Props가 동일하면 리렌더링 스킵

   ```jsx
   const Child = React.memo(function Child({ name }) {
     return <div>{name}</div>;
   });
   ```

   동작: 이전 props와 얕은 비교 → 동일하면 이전 결과 재사용

2. **useMemo**: 비싼 계산 결과 캐싱

3. **useCallback**: 함수 참조 유지 (React.memo와 함께 사용)

**주의:**
과도한 최적화는 오히려 성능 저하. Profiler로 측정 후 병목 지점만 최적화해야 합니다."

**최적화 도구:**

- `React.memo`: 컴포넌트 메모이제이션
- `useMemo`: 값 메모이제이션
- `useCallback`: 함수 메모이제이션

---

## React.memo

### 기본 사용

```jsx
// ❌ 최적화 전
function Child({ name }) {
  console.log('Child rendered');
  return <div>{name}</div>;
}

function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
      <Child name="John" />  {/* count 변경 시마다 리렌더링! */}
    </div>
  );
}

// ✅ 최적화 후
const Child = React.memo(function Child({ name }) {
  console.log('Child rendered');
  return <div>{name}</div>;
});

function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
      <Child name="John" />  {/* props 변경 없으면 리렌더링 안함! */}
    </div>
  );
}
```

### 커스텀 비교 함수

```jsx
const Child = React.memo(
  function Child({ user }) {
    return <div>{user.name}</div>;
  },
  (prevProps, nextProps) => {
    // true 반환 = 리렌더링 하지 않음
    return prevProps.user.id === nextProps.user.id;
  }
);
```

---

## useMemo

### 기본 사용

```jsx
import { useMemo } from 'react';

function TodoList({ todos, filter }) {
  // 비싼 계산 메모이제이션
  const filteredTodos = useMemo(() => {
    console.log('Filtering todos...');
    return todos.filter(todo => {
      if (filter === 'all') return true;
      if (filter === 'active') return !todo.completed;
      if (filter === 'completed') return todo.completed;
    });
  }, [todos, filter]);  // todos나 filter 변경 시에만 재계산

  return (
    <ul>
      {filteredTodos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

### 언제 사용하나?

```jsx
// ✅ 좋음: 비싼 계산
const sortedList = useMemo(() => {
  return items.sort((a, b) => a.price - b.price);
}, [items]);

// ❌ 불필요: 간단한 계산
const doubled = useMemo(() => count * 2, [count]);  // 오버헤드만 증가

// ✅ 좋음: 참조 동일성이 중요한 경우
const config = useMemo(() => ({ theme, locale }), [theme, locale]);
```

---

## useCallback

### 기본 사용

```jsx
import { useCallback } from 'react';

function Parent() {
  const [count, setCount] = useState(0);

  // 함수 메모이제이션
  const handleClick = useCallback(() => {
    console.log('Clicked!');
  }, []);  // 의존성 없음 = 절대 재생성 안됨

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>
        Count: {count}
      </button>
      <Child onClick={handleClick} />
    </div>
  );
}

const Child = React.memo(function Child({ onClick }) {
  console.log('Child rendered');
  return <button onClick={onClick}>Click me</button>;
});
```

### 의존성 배열

```jsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);

  const handleSearch = useCallback(async () => {
    const data = await fetch(`/api/search?q=${query}`);
    setResults(data);
  }, [query]);  // query 변경 시에만 재생성

  useEffect(() => {
    handleSearch();
  }, [handleSearch]);

  return <ResultList results={results} />;
}
```

---

## 성능 측정

### React DevTools Profiler

```jsx
import { Profiler } from 'react';

function onRenderCallback(
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) {
  console.log(`${id} (${phase}) took ${actualDuration}ms`);
}

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <YourApp />
    </Profiler>
  );
}
```

### Performance API

```javascript
performance.mark('start');

// 작업 수행
doExpensiveWork();

performance.mark('end');
performance.measure('work', 'start', 'end');

const measure = performance.getEntriesByName('work')[0];
console.log(`Duration: ${measure.duration}ms`);
```

---

## 최적화 체크리스트

### 필수 최적화

- [ ] 리스트에 `key` 사용
- [ ] 이미지 최적화 (next/image)
- [ ] 코드 분할 (React.lazy)
- [ ] 필요한 곳에만 React.memo
- [ ] 큰 계산에만 useMemo
- [ ] Props로 전달되는 함수에 useCallback

### 고급 최적화

- [ ] 가상화 (react-window)
- [ ] Web Workers
- [ ] Service Workers

---

**작성일**: 2025-10-11  
**대상**: React 개발자
