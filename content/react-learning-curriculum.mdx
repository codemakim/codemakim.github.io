---
title: "📖 [필독] React 완전 정복 - 학습 커리큘럼 & 면접 가이드"
date: "2024-06-30"
description: "6년차 Vue 개발자가 단기간에 React 전문가가 되기 위한 체계적 커리큘럼과 면접 필수 10문"
tags: ["React", "커리큘럼", "학습로드맵", "면접", "Vue비교"]
---

# React 완전 정복 커리큘럼 (Vue 개발자 → React 전문가)

> 6년차 Vue 개발자가 단기간에 React/Next.js 전문가가 되기 위한 완벽한 학습 로드맵

---

## 🎯 학습 목표

**기간:** 6-8주 (하루 2-3시간 투자)  
**목표:** 이직 면접 통과 + 실무 투입 가능 수준

### 달성할 수 있는 것

- ✅ React 핵심 개념 완벽 이해
- ✅ Next.js 서버 컴포넌트/액션 마스터
- ✅ 상태 관리 라이브러리 활용
- ✅ 테스팅 전략 수립
- ✅ 성능 최적화 실무 적용
- ✅ 면접 질문 완벽 대응

---

## 📚 전체 커리큘럼 구조

```
docs/
├── 📖 nextjs-guide-for-vue-developers.md
│   └── Next.js 프로젝트 구조 및 Vue와 비교
│
├── react-learning/                    # Phase 1: 기초 (2주)
│   ├── 01-describing-the-ui.md
│   ├── 02-adding-interactivity.md
│   ├── 03-managing-state.md
│   └── 04-escape-hatches.md
│
├── react-advanced/                    # Phase 2: 고급 (2주)
│   ├── 01-react-router.md
│   ├── 02-data-fetching.md
│   ├── 03-state-management.md
│   └── 04-nextjs-advanced.md
│
├── react-testing/                     # Phase 3: 테스팅 (1주)
│   ├── 01-jest-basics.md
│   ├── 02-react-testing-library.md
│   └── 03-e2e-testing.md
│
└── react-performance/                 # Phase 4: 최적화 (1주)
    ├── 01-optimization-basics.md
    ├── 02-code-splitting.md
    └── 03-advanced-patterns.md
```

---

## 🗓️ 주차별 학습 계획

### Week 1-2: React 기초 마스터 (필수!)

**학습 목표:** Vue 사고방식에서 React 사고방식으로 전환

#### Week 1: UI 표현 & 상호작용

**Day 1-2: `01-describing-the-ui.md`**

- ✅ 컴포넌트 작성 패턴
- ✅ Props 전달 메커니즘
- ✅ 조건부/리스트 렌더링
- 🎯 **핵심 질문:** "Vue template과 JSX의 근본적 차이는?"

**Day 3-4: `02-adding-interactivity.md`**

- ✅ useState의 동작 원리 (스냅샷 개념!)
- ✅ 이벤트 핸들링
- ✅ State 업데이트 큐 이해
- ✅ 불변성 개념
- 🎯 **핵심 질문:** "왜 setState는 즉시 반영되지 않나요?"

#### Week 2: State 관리 & 고급 Hook

**Day 5-6: `03-managing-state.md`**

- ✅ State 끌어올리기
- ✅ Reducer 패턴 이해
- ✅ Context API 동작 원리

- 🎯 **핵심 질문:** "언제 Context를 사용하고 언제 props를 사용하나요?"

**Day 7-8: `04-escape-hatches.md`**

- ✅ useRef vs useState 차이의 본질
- ✅ useEffect의 동작 원리와 클린업
- ✅ Effect 의존성 배열의 의미

- ✅ 커스텀 Hook 설계
- 🎯 **핵심 질문:** "Effect는 언제 실행되고 클린업은 언제 실행되나요?"

**Week 1-2 마무리 프로젝트:**

```
할 일 앱 (CRUD + LocalStorage)
- useState, useEffect 활용
- Context로 전역 상태 관리
- 커스텀 Hook 작성
```

---

### Week 3-4: React 고급 & 라이브러리 (실무 필수!)

**학습 목표:** 실무에서 사용하는 라이브러리와 패턴 마스터

#### Week 3: 라우팅 & 데이터 페칭

**Day 9-10: `react-advanced/01-react-router.md`**

- ✅ 클라이언트 사이드 라우팅 원리

- ✅ 중첩 라우트와 Outlet 개념
- ✅ Protected Routes 구현
- ✅ Router의 내부 동작 (History API)
- 🎯 **핵심 질문:** "SPA에서 라우팅은 어떻게 작동하나요?"

**Day 11-12: `react-advanced/02-data-fetching.md`**

- ✅ React Query의 캐싱 전략 이해
- ✅ Stale Time vs Cache Time의 차이

- ✅ 낙관적 업데이트 원리
- ✅ Query Invalidation 메커니즘
- 🎯 **핵심 질문:** "React Query는 어떻게 자동으로 캐시를 관리하나요?"

#### Week 4: 상태 관리 & Next.js 심화

**Day 13-14: `react-advanced/03-state-management.md`**

- ✅ Zustand의 구독 메커니즘
- ✅ Redux의 단방향 데이터 흐름
- ✅ Flux 아키텍처 이해
- ✅ 언제 어떤 라이브러리를 선택할지

**Day 15-16: `react-advanced/04-nextjs-advanced.md`**

- ✅ 서버 컴포넌트 vs 클라이언트 컴포넌트 동작 원리
- ✅ 서버 액션의 보안 메커니즘
- ✅ ISR과 SSG의 차이와 활용
- 🎯 **핵심 질문:** "서버 컴포넌트는 어떻게 번들 크기를 줄이나요?"

**Week 3-4 마무리 프로젝트:**

```
블로그 플랫폼 확장
- React Router로 라우팅
- React Query로 데이터 관리
- Zustand로 UI 상태 관리

- 서버 액션으로 CRUD
```

---

### Week 5: 테스팅 마스터 (차별화 포인트!)

**학습 목표:** 테스트 작성 능력으로 시니어 개발자 어필

**Day 17-18: `react-testing/01-jest-basics.md`**

- ✅ 테스트 피라미드 이해
- ✅ Mock의 필요성과 동작 원리
- ✅ 비동기 테스트 전략
- 🎯 **핵심 질문:** "왜 테스트를 작성해야 하나요?"

**Day 19-20: `react-testing/02-react-testing-library.md`**

- ✅ RTL의 철학: "구현이 아닌 동작 테스트"
- ✅ 쿼리 우선순위의 이유 (접근성!)
- ✅ user-event vs fireEvent 차이
- ✅ 비동기 렌더링 테스트
- 🎯 **핵심 질문:** "왜 testId를 최후의 수단으로 사용하나요?"

**Day 21: `react-testing/03-e2e-testing.md`**

- ✅ E2E 테스트의 가치
- ✅ Playwright vs Cypress 선택 기준
- 🎯 **핵심 질문:** "단위 테스트와 E2E 테스트의 균형은?"

**Week 5 실습:**

```
기존 프로젝트에 테스트 추가
- 컴포넌트 단위 테스트 작성
- 통합 테스트 작성
- E2E 시나리오 작성
```

---

### Week 6: 성능 최적화 (전문가 레벨!)

**학습 목표:** 성능 문제를 식별하고 해결할 수 있는 능력

**Day 22-23: `react-performance/01-optimization-basics.md`**

- ✅ React 렌더링 프로세스 깊이 이해
- ✅ Virtual DOM의 동작 원리
- ✅ Reconciliation 알고리즘
- ✅ useMemo/useCallback이 필요한 진짜 이유

- 🎯 **핵심 질문:** "리렌더링은 왜 발생하고 어떻게 방지하나요?"

**Day 24: `react-performance/02-code-splitting.md`**

- ✅ Tree Shaking 원리
- ✅ Dynamic Import의 동작 방식
- 🎯 **핵심 질문:** "코드 분할은 어떻게 로딩 속도를 개선하나요?"

**Day 25: `react-performance/03-advanced-patterns.md`**

- ✅ 가상화(Virtualization)의 필요성
- ✅ Web Vitals 지표 이해
- ✅ Concurrent Rendering 개념
- 🎯 **핵심 질문:** "10,000개 리스트를 빠르게 렌더링하려면?"

**Week 6 실습:**

```
프로젝트 성능 최적화
- Profiler로 병목 지점 찾기
- 불필요한 리렌더링 제거

- 번들 크기 분석 및 최적화
```

---

## 💼 면접 대비 핵심 질문 & 답변 가이드

### React 핵심 개념

**Q1: Virtual DOM이 무엇이고 왜 사용하나요?**

**답변 구조:**

1. **정의**: Virtual DOM은 실제 DOM의 가벼운 JavaScript 표현

2. **이유**:
   - 실제 DOM 조작은 느림 (리플로우, 리페인트)
   - Virtual DOM에서 diff 계산 (빠름)
   - 변경된 부분만 실제 DOM에 적용 (효율적)
3. **동작 과정**:

   ```
   State 변경 → 새 Virtual DOM 생성
   → 이전 Virtual DOM과 비교 (Diffing)
   → 변경사항만 실제 DOM에 적용 (Reconciliation)
   ```

4. **실무 영향**: 대부분 자동으로 처리되지만, 큰 리스트는 key가 중요

**참조 문서:** `react-learning/01-describing-the-ui.md`

---

**Q2: useState는 왜 즉시 업데이트되지 않나요?**

**답변 구조:**

1. **배치 업데이트**: React는 성능을 위해 여러 setState를 모아서 한 번에 처리
2. **스냅샷 개념**: 각 렌더링은 고정된 state 스냅샷을 가짐
   ```jsx
   function handleClick() {
     setCount(count + 1);  // 0 + 1
     console.log(count);   // 여전히 0! (스냅샷)
   }
   ```

3. **해결책**: 업데이터 함수 사용
   ```jsx
   setCount(c => c + 1);
   setCount(c => c + 1);  // 이제 2 증가!
   ```

4. **실무 영향**: 비동기 작업 후 state 사용 시 주의

**참조 문서:** `react-learning/02-adding-interactivity.md`

---

**Q3: useEffect의 클린업 함수는 언제 실행되나요?**

**답변 구조:**

1. **실행 시점**:
   - 컴포넌트 언마운트 시
   - Effect가 다시 실행되기 **직전**
2. **왜 필요한가**:
   - 메모리 누수 방지
   - 이벤트 리스너 제거
   - 타이머 정리
3. **예제**:

   ```jsx
   useEffect(() => {
     const id = setInterval(() => {
       console.log('Tick');
     }, 1000);
     
     return () => clearInterval(id);  // 클린업!
   }, []);
   ```

4. **실무 영향**: WebSocket, 구독 등 외부 연결 관리 필수

**참조 문서:** `react-learning/04-escape-hatches.md`

---

**Q4: React.memo, useMemo, useCallback의 차이는?**

**답변 구조:**

| 도구 | 메모이제이션 대상 | 사용 시기 |
|------|----------------|----------|
| `React.memo` | **컴포넌트** | Props 변경 없으면 리렌더링 방지 |
| `useMemo` | **값** | 비싼 계산 결과 캐싱 |
| `useCallback` | **함수** | 함수 참조 동일성 유지 |

**실무 예제:**

```jsx
// React.memo: 컴포넌트 메모이제이션
const ExpensiveChild = React.memo(({ data }) => {
  // data 변경 시에만 리렌더링

});

// useMemo: 값 메모이제이션
const sortedData = useMemo(() => {
  return data.sort((a, b) => a.price - b.price);
}, [data]);

// useCallback: 함수 메모이제이션
const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);

```

**주의사항:** 과도한 메모이제이션은 오히려 성능 저하!

**참조 문서:** `react-performance/01-optimization-basics.md`

---

### Next.js 핵심 개념

**Q5: 서버 컴포넌트와 클라이언트 컴포넌트의 차이는?**

**답변 구조:**

1. **실행 위치**:
   - 서버 컴포넌트: 서버에서만 실행 (기본값)
   - 클라이언트 컴포넌트: 브라우저에서 실행 (`"use client"`)

2. **번들 크기**:

   ```
   서버 컴포넌트:
   - 서버에서 실행 → HTML 생성 → 클라이언트로 전송
   - JavaScript 번들에 포함 안됨 (0KB!)
   

   클라이언트 컴포넌트:
   - JavaScript 번들에 포함됨
   - 브라우저가 다운로드 & 실행
   ```

3. **언제 무엇을 사용?**:

   ```jsx

   // ✅ 서버 컴포넌트 (기본)
   - 데이터 페칭
   - 백엔드 리소스 직접 접근
   - 민감한 정보 (API 키 등)
   
   // ✅ 클라이언트 컴포넌트 ("use client")
   - useState, useEffect 등 Hook 사용
   - 이벤트 리스너 (onClick 등)
   - 브라우저 전용 API (window, localStorage)
   ```

4. **면접 포인트**:
   - "Next.js의 서버 컴포넌트는 PHP나 JSP와 다릅니다"
   - "React의 하이드레이션과 결합되어 인터랙티브함 유지"

**참조 문서:** `nextjs-guide-for-vue-developers.md`, `react-advanced/04-nextjs-advanced.md`

---

**Q6: 서버 액션(Server Actions)의 동작 원리는?**

**답변 구조:**

1. **기존 방식의 문제**:

   ```jsx
   // 기존: API Route 필요
   // 1. app/api/posts/route.js 생성
   // 2. 클라이언트에서 fetch 호출
   // 3. 타입 안전성 부족
   ```

2. **서버 액션의 해결책**:

   ```jsx
   
   export async function createPost(formData) {
     // 서버에서 실행!
     await db.posts.create({ ... });
     revalidatePath('/posts');
   }
   ```

3. **보안**:
   - 클라이언트에 노출 안됨
   - 데이터베이스 직접 접근 가능
   - API 키 노출 걱정 없음

4. **동작 방식**:

   ```
   폼 제출 → Next.js가 서버 액션 감지
   → 서버에서 함수 실행
   → 결과 반환 & 캐시 업데이트
   ```

**참조 문서:** `react-advanced/04-nextjs-advanced.md`

---

### 아키텍처 & 디자인 패턴

**Q7: React Query와 일반 useState + useEffect의 차이는?**

**답변 구조:**

1. **문제 인식**:

   ```jsx
   // ❌ 일반적인 방법 (100줄+)
   function Users() {
     const [data, setData] = useState([]);
     const [loading, setLoading] = useState(false);
     const [error, setError] = useState(null);
     
     useEffect(() => {
       setLoaing(true);
       fetch('/api/users')
         .then(data => {
           setData(data);
           setLoading(false);
         })
         .catch(err => {
           setError(err);
           setLoading(false);
         });
     }, []);
     
     // 캐싱 없음, 중복 요청 방지 없음, 재시도 없음...
   }
   ```

2. **React Query의 해결**:

   ```jsx
   // ✅ React Query (10줄)
   function Users() {
     const { data, isLoading, error } = useQuery({
       queryKey: ['users'],
       queryFn: fetchUsers

     });
     
     // 자동 캐싱, 중복 제거, 재시도, 백그라운드 리페치...
   }
   ```

3. **내부 동작**:
   - Query Key로 캐시 관리
   - Stale/Fresh 상태 추적
   - Window Focus 시 자동 리페치
   - 동일한 Query Key면 단일 요청만 전송

4. **실무 가치**:
   - 서버 상태와 클라이언트 상태 분리
   - 보일러플레이트 90% 감소
   - 사용자 경험 향상

**참조 문서:** `react-advanced/02-data-fetching.md`

---

**Q8: Context API는 언제 사용하고 언제 상태 관리 라이브러리를 사용하나요?**

**답변 구조:**

1. **Context API 적합한 경우**:

   - 테마, 언어, 인증 등 **느리게 변하는 전역 상태**
   - 깊은 컴포넌트 트리에 props 전달
   - 외부 의존성 피하고 싶을 때

2. **상태 관리 라이브러리 필요한 경우**:
   - **자주 변하는 상태** (장바구니, 폼 상태)
   - 성능 최적화 필요 (선택적 구독)
   - DevTools, 미들웨어 필요
   - 복잡한 비즈니스 로직

3. **성능 차이**:

   ```jsx
   // ❌ Context: 값 변경 시 모든 Consumer 리렌더링
   const { theme, user, cart } = useContext(AppContext);
   // theme만 변경되어도 리렌더링!

   
   // ✅ Zustand: 필요한 값만 구독
   const theme = useStore(state => state.theme);
   // theme 변경 시에만 리렌더링!
   ```

4. **실무 조합**:
   - Context: 테마, 언어, 인증
   - Zustand/Redux: UI 상태, 비즈니스 로직
   - React Query: 서버 상태

**참조 문서:** `react-advanced/03-state-management.md`, `react-learning/03-managing-state.md`

---

### 테스팅 전략

**Q9: 테스트 피라미드에 대해 설명해주세요.**

**답변 구조:**

1. **피라미드 구조**:

   ```
         /\
        /E2E\      (10%) - 느림, 비쌈, 중요 플로우만
       /------\
      /통합 테스트\  (20%) - 여러 컴포넌트 조합
     /----------\
    / 단위 테스트  \  (70%) - 빠름, 저렴, 많이 작성
   /--------------\
   ```

2. **각 레벨의 역할**:
   - **단위 테스트**: 개별 함수/컴포넌트 검증
   - **통합 테스트**: 컴포넌트 간 상호작용 검증
   - **E2E 테스트**: 전체 사용자 플로우 검증

3. **실무 적용**:

   ```
   단위: 버튼 컴포넌트, 유틸 함수
   E2E: 회원가입 → 로그인 → 포스트 작성 → 로그아웃
   ```

4. **비용 vs 가치**: E2E는 유지보수 비용이 높으므로 핵심 플로우만

**참조 문서:** `react-testing/` 전체

---

**Q10: RTL에서 getByRole을 왜 우선적으로 사용하나요?**

**답변 구조:**

1. **접근성 중심**:
   - `getByRole`은 스크린 리더가 보는 것과 동일
   - 접근성 좋은 코드 = 테스트하기 좋은 코드

2. **구현 세부사항 독립적**:

   ```jsx
   // ❌ 나쁨: class에 의존
   getByClassName('submit-button')
   
   // ❌ 나쁨: 구조에 의존
   container.querySelector('div > button')
   
   // ✅ 좋음: 사용자 관점
   getByRole('button', { name: /submit/i })
   ```

3. **리팩토링 안전**:
   - Role은 의미론적이므로 안정적

4. **면접 포인트**: "사용자가 보는 대로 테스트"

---

## 🎯 면접 시나리오별 대응

### 시나리오 1: "성능 최적화 경험은?"

**답변 예시:**

"Vue 프로젝트에서 큰 테이블 렌더링 최적화 경험이 있습니다. React에서도 동일한 원리를 적용할 수 있습니다.

**문제 파악:**

- Chrome DevTools Performance 탭으로 병목 지점 확인
- React DevTools Profiler로 불필요한 리렌더링 발견

**적용한 최적화:**

1. **React.memo**: 변경 없는 자식 컴포넌트 메모이제이션
2. **useMemo**: 정렬/필터링 같은 비싼 계산 캐싱
3. **react-window**: 1000개 이상 리스트는 가상화
4. **코드 분할**: 관리자 페이지는 lazy loading

**결과:**

- 초기 로딩: 3.2초 → 1.1초
- FCP: 2.1초 → 0.8초
- 번들 크기: 450KB → 180KB

Vue의 `computed`나 `v-memo`와 유사하지만, React는 명시적으로 최적화해야 합니다."

---

### 시나리오 2: "Next.js를 왜 사용하나요?"

**답변 예시:**

"Next.js는 React에 프로덕션 필수 기능을 추가한 프레임워크입니다.

**핵심 가치:**

- CSR: 빈 HTML → JS 다운로드 → 렌더링 (느림)

- SSR: 완성된 HTML 전송 → 하이드레이션 (빠름)

2. **파일 기반 라우팅**:
   - `app/posts/[id]/page.jsx` → `/posts/:id`
   - 직관적이고 자동 코드 분할

3. **서버 컴포넌트**:
   - DB 직접 접근 가능
   - 번들 크기 0KB
   - API 라우트 불필요

4. **이미지 최적화**:
   - 자동 리사이징, WebP 변환
   - Lazy loading, Blur placeholder

**Nuxt와 비교하면:**

- Nuxt: Vue 생태계의 메타 프레임워크
- Next.js: React 생태계의 메타 프레임워크

실무에서는 CSR만으로는 한계가 있고, Next.js는 업계 표준입니다."

---

### 시나리오 3: "큰 리스트 렌더링을 최적화하려면?"

**답변 예시:**

"10,000개 항목 렌더링 시 여러 단계 최적화가 필요합니다.

**1단계: 페이지네이션**

// 가장 간단: 10개씩만 표시
const displayedItems = items.slice((page - 1) *10, page* 10);

```

**2단계: 가상화 (Virtualization)**

```jsx
// react-window 사용
// 화면에 보이는 것만 렌더링 (예: 20개)
// 10,000개여도 20개만 DOM에 존재
```

**원리:**

- 스크롤 위치 계산
- 보이는 범위의 항목만 렌더링
- 나머지는 높이만 차지 (DOM 생성 안함)

**3단계: 메모이제이션**

```jsx
// 각 아이템 컴포넌트를 React.memo로
const ListItem = React.memo(({ item }) => {
  return <div>{item.name}</div>;
});

```

**성능 개선:**

- 렌더링 시간: 5000ms → 50ms
- 메모리 사용: 500MB → 50MB

Vue의 `v-virtual-scroller`와 동일한 원리입니다."

---

## 📖 학습 방법론

### 효과적인 학습 전략

**1. 읽기 → 실습 → 정리 → 질문**

```
문서 읽기 (30분)
   ↓
직접 코드 작성 (1시간)
   ↓
개념 정리 & 메모 (15분)
   ↓
면접 질문 만들기 (15분)
```

**2. Vue와 비교하며 학습**

모든 개념을 "Vue에서는 이렇게, React에서는 이렇게"로 정리하세요.

```markdown
# 내 학습 노트

## State 관리
Vue: ref(), reactive() - 자동 반응성
React: useState() - 명시적 setter

왜 차이가 있나?
- Vue: Proxy 기반 반응성 시스템
- React: 불변성 기반 비교

실무에서 차이:
- Vue: 직접 수정 가능 (편함)
- React: 새 객체 생성 (명확함, 디버깅 쉬움)
```

**3. 면접 질문 스스로 만들기**

각 문서 학습 후:

- "이 기술의 핵심 원리는?"
- "왜 이 방법을 사용하나?"
- "대안은 무엇이고 왜 이게 더 나은가?"
- "실무에서 어떤 문제를 해결하나?"

---

## 🎤 면접 준비 체크리스트

### 기술 면접 필수 주제

#### React 핵심 (필수! ⭐⭐⭐)

- [ ] Virtual DOM과 Reconciliation
- [ ] useState의 스냅샷 개념
- [ ] useEffect의 의존성 배열
- [ ] 렌더링 최적화 (memo, useMemo, useCallback)

- [ ] 제어/비제어 컴포넌트
- [ ] 합성 vs 상속
- [ ] Hooks 규칙과 이유

#### Next.js 핵심 (필수! ⭐⭐⭐)

- [ ] SSR vs SSG vs CSR 차이
- [ ] 서버 컴포넌트 동작 원리

- [ ] 서버 액션의 보안 메커니즘
- [ ] App Router vs Pages Router
- [ ] ISR과 캐싱 전략
- [ ] Image 최적화 원리

#### 상태 관리 (중요! ⭐⭐)

- [ ] Context API vs Redux vs Zustand 비교
- [ ] Flux 아키텍처 이해
- [ ] React Query의 캐싱 전략

#### 성능 최적화 (중요! ⭐⭐)

- [ ] 리렌더링 발생 조건
- [ ] 번들 크기 최적화 방법
- [ ] 코드 분할 전략

#### 테스팅 (차별화! ⭐)

- [ ] 테스트 피라미드
- [ ] RTL의 철학
- [ ] 단위 vs 통합 vs E2E

---

## 📝 주간 학습 점검표

### Week 1-2 체크포인트

**기술 이해도:**

- [ ] JSX를 자연스럽게 작성할 수 있다
- [ ] useState와 useEffect를 설명할 수 있다
- [ ] Props와 State의 차이를 안다
- [ ] 불변성을 이해한다

- [ ] "Virtual DOM이 뭔가요?" 답변 준비
- [ ] "useState는 왜 비동기인가요?" 답변 준비
- [ ] Vue와 React의 차이 3가지 이상 설명 가능

- [ ] Todo 앱 완성
- [ ] 커스텀 Hook 2개 이상 작성

---

### Week 3-4 체크포인트

**기술 이해도:**

- [ ] React Router를 능숙하게 사용할 수 있다
- [ ] React Query의 캐싱을 이해한다
- [ ] 상태 관리 라이브러리를 선택할 수 있다
- [ ] 서버 컴포넌트를 설명할 수 있다
**면접 준비:**

- [ ] "SPA 라우팅은 어떻게 작동하나요?" 답변 준비
- [ ] "서버 컴포넌트의 장점은?" 답변 준비
- [ ] "Context vs Redux 언제 사용?" 답변 준비

- [ ] 블로그 플랫폼에 검색/필터 추가
- [ ] Zustand로 전역 상태 관리

- [ ] 서버 액션으로 CRUD 구현

---

### Week 5-6 체크포인트

**기술 이해도:**

- [ ] 테스트를 작성할 수 있다
- [ ] 번들 크기를 최적화할 수 있다

**면접 준비:**

- [ ] "테스트 전략은?" 답변 준비
- [ ] "성능 최적화 경험은?" 답변 준비
-[ ] "10,000개 리스트 최적화?" 답변 준비

**실습:**

- [ ] 주요 컴포넌트에 테스트 작성
- [ ] Profiler로 성능 분석
- [ ] 번들 크기 50% 이상 감소

---

## 🚀 최종 목표: 포트폴리오 프로젝트

**프로젝트:** 풀스택 블로그 플랫폼

**기술 스택:**

```
Frontend:
- Next.js 15 (App Router)
- TypeScript
- Tailwind CSS
- React Query
- Zustand

Testing:
- Jest + RTL
- Playwright


Performance:
- Lighthouse 95점 이상
- 코드 분할 적용
- 이미지 최적화

```

**핵심 기능:**

1. ✅ 포스트 CRUD (서버 액션)
2. ✅ 실시간 검색 (React Query + Debounce)
3. ✅ 무한 스크롤 (useInfiniteQuery)
4. ✅ 다크 모드 (Zustand + LocalStorage)
5. ✅ SEO 최적화 (메타데이터)

6. ✅ 테스트 커버리지 80%+

**면접에서 어필 포인트:**

- "서버 컴포넌트로 번들 크기 60% 감소"

- "React Query로 네트워크 요청 50% 감소"
- "가상화로 10,000개 리스트 렌더링 최적화"

---

## 💡 실전 팁

### 면접관이 좋아하는 답변 구조

**나쁜 답변:**
> "React.memo를 사용하면 성능이 좋아집니다."

**좋은 답변:**

> "React.memo는 Props가 변경되지 않았을 때 컴포넌트 리렌더링을 방지합니다.
>
> **동작 원리:**
> React는 기본적으로 부모가 리렌더링되면 모든 자식을 리렌더링합니다. React.memo는 이전 props와 새 props를 얕은 비교(shallow comparison)하여 동일하면 이전 렌더링 결과를 재사용합니다.
>
> **주의사항:**
> 객체나 함수 props는 매번 새로 생성되므로 useMemo/useCallback과 함께 사용해야 합니다. 과도한 메모이제이션은 오히려 성능 저하를 일으킬 수 있습니다.
>
> **실무 경험:**

> 이전 프로젝트에서 1000개 카드 리스트의 각 카드를 React.memo로 감싸고, 부모의 filter state 변경 시 필터링된 카드만 리렌더링되도록 최적화했습니다."

---

### 질문을 역으로 하기

면접관에게 질문할 것:

- "팀에서 사용하는 상태 관리 전략은?"
- "테스트 커버리지 목표는?"
- "성능 모니터링은 어떻게 하시나요?"
- "서버 컴포넌트를 프로덕션에 적용하셨나요?"

→ **기술 이해도를 은연중에 보여줌!**

---

## 📚 문서별 학습 포인트

### React 기초 문서 (react-learning/)

**학습 포인트:**

- ✅ **원리 이해**: 왜 이렇게 동작하는가?
- ✅ **실습**: 각 개념을 직접 코드로

**면접 대비:**

- Virtual DOM 설명
- Hooks 규칙의 이유
- 렌더링 프로세스 3단계

---

### React 고급 문서 (react-advanced/)

**학습 포인트:**

- ✅ **실무 패턴**: 실제로 어떻게 사용?
- ✅ **트레이드오프**: 각 선택의 장단점
- ✅ **아키텍처**: 전체 구조 설계

**면접 대비:**

- 라이브러리 선택 기준
- 캐싱 전략 수립

---

### 테스팅 문서 (react-testing/)

**학습 포인트:**

- ✅ **테스트 철학**: 무엇을 어떻게 테스트?
- ✅ **ROI**: 테스트의 비용 대비 가치
- ✅ **전략**: 어디에 집중할 것인가?

**면접 대비:**

- 테스트 피라미드 설명
- TDD 경험 (있으면 강점!)
- 테스트 커버리지 의견

---

### 성능 최적화 문서 (react-performance/)

**학습 포인트:**

- ✅ **측정**: 문제를 어떻게 찾나?
- ✅ **해결**: 어떤 도구로 해결?
- ✅ **검증**: 개선을 어떻게 증명?

**면접 대비:**

- 성능 최적화 사례

- Web Vitals 이해
- 번들 크기 최적화 경험

---

## 🎓 졸업 기준

다음을 모두 할 수 있으면 이직 준비 완료!

### 기술 역량

- [ ] React 앱을 처음부터 설계하고 구현할 수 있다
- [ ] Next.js로 SEO 최적화된 앱을 만들 수 있다
- [ ] 적절한 상태 관리 전략을 선택하고 적용할 수 있다
- [ ] 테스트 전략을 수립하고 실행할 수 있다
- [ ] 성능 문제를 분석하고 해결할 수 있다

### 면접 역량

- [ ] 10개 핵심 질문에 "원리부터" 답변할 수 있다
- [ ] Vue와 React를 비교하여 설명할 수 있다
- [ ] 실무 경험처럼 프로젝트를 설명할 수 있다
- [ ] 기술 선택의 이유를 설명할 수 있다

### 포트폴리오

- [ ] GitHub에 2-3개 프로젝트
- [ ] README에 기술 선택 이유 명시
- [ ] 성능 최적화 결과 수치화

---

## 🌟 성공 전략

### 단기 집중 (6-8주)

**Week 1-2:** React 기초 (매일 2시간)  
**Week 3-4:** React 고급 (매일 2-3시간)  
**Week 5:** 테스팅 (매일 2시간)  
**Week 6:** 성능 + 포트폴리오 (매일 3시간)  
**Week 7-8:** 면접 준비 + 모의 면접

### 일일 루틴

```
09:00-10:00  문서 읽기 & 개념 이해
10:00-11:30  실습 코드 작성
11:30-12:00  정리 & 면접 질문 만들기
```

### 주말 집중 학습

```
토요일: 주간 프로젝트 (4-6시간)
일요일: 복습 & 면접 시뮬레이션 (3-4시간)
```

---

## 📞 추가 지원

### 질문 가이드

각 문서 학습 중 궁금한 점:

1. **개념 이해**: "왜 이렇게 동작하나요?"
2. **실무 적용**: "실제로 어떻게 사용하나요?"
3. **면접 대비**: "이걸 면접에서 어떻게 설명하죠?"

### 피드백 받기

주간 학습 후:

- 작성한 코드 리뷰 요청
- 면접 답변 검토 요청
- 포트폴리오 피드백 요청

---

## 🎯 최종 목표

**6-8주 후:**

✅ React/Next.js 중급 개발자 수준  
✅ 실무 투입 가능한 기술 스택  
✅ 면접 통과 가능한 지식 & 경험  
✅ 포트폴리오 2-3개 완성  
✅ 시니어 개발자로 가는 발판 마련

---

**작성일**: 2025-10-12  
**대상**: Vue → React 전환 개발자  
**예상 기간**: 6-8주

---

**화이팅! 당신은 할 수 있습니다!** 🚀💪

6년차 경력에 JavaScript 이해도가 있다면 충분히 가능합니다.  
이 커리큘럼을 따라가면 단기간에 React 전문가가 될 수 있습니다!
