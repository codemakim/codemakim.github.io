---
title: "Spring 의존성 주입 방식 비교"
description: "필드 주입, 세터 주입, 생성자 주입의 차이점과 생성자 주입을 권장하는 이유, Lombok과의 관계를 정리했다."
date: "2025-09-21"
tags: ["Spring", "Java", "백엔드"]
---

# Spring 의존성 주입 방식 비교

Spring에서 의존성을 주입하는 방법은 필드 주입, 세터 주입, 생성자 주입 세 가지가 있다. 실무에서는 생성자 주입을 권장하는데 그 이유와 Lombok을 활용한 방법을 정리했다.

## 의존성 주입의 세 가지 방식

### 필드 주입

가장 간단해 보이지만 권장하지 않는 방식이다.

```java
@RestController
public class UserController {

    @Autowired
    private UserService userService;

    @Autowired
    private EmailService emailService;

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}
```

편해 보이지만 여러 문제가 있다.

### 세터 주입

선택적 의존성에 사용할 수 있지만 거의 쓰지 않다.

```java
@RestController
public class UserController {

    private UserService userService;
    private EmailService emailService;

    @Autowired
    public void setUserService(UserService userService) {
        this.userService = userService;
    }

    @Autowired
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
}
```

의존성을 나중에 변경할 수 있어서 불변성이 보장되지 않다.

### 생성자 주입

Spring 4.3부터 권장하는 방식이다.

```java
@RestController
public class UserController {

    private final UserService userService;
    private final EmailService emailService;

    @Autowired // 생성자가 하나면 생략 가능
    public UserController(UserService userService, EmailService emailService) {
        this.userService = userService;
        this.emailService = emailService;
    }

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}
```

생성자가 하나만 있으면 `@Autowired`도 생략할 수 있다.

```java
@RestController
public class UserController {

    private final UserService userService;
    private final EmailService emailService;

    // @Autowired 생략 가능
    public UserController(UserService userService, EmailService emailService) {
        this.userService = userService;
        this.emailService = emailService;
    }
}
```

## 필드 주입을 쓰면 안 되는 이유

필드 주입은 코드가 짧아서 편해 보이지만 여러 문제를 가지고 있다.

### 불변성을 보장하지 못함

`final` 키워드를 사용할 수 없어서 의존성이 중간에 바뀔 수 있다.

```java
@RestController
public class UserController {

    @Autowired
    private UserService userService; // final 불가능

    public void someMethod() {
        this.userService = null; // 이렇게 바뀔 수 있음
    }
}
```

생성자 주입은 `final`을 사용해서 불변성을 보장한다.

```java
@RestController
public class UserController {

    private final UserService userService; // 생성 후 변경 불가

    public UserController(UserService userService) {
        this.userService = userService;
    }
}
```

### 테스트가 어려움

순수 자바 코드로 테스트할 때 의존성을 주입할 방법이 없다.

```java
public class UserControllerTest {

    @Test
    void test() {
        // 필드 주입: 의존성을 주입할 방법이 없음
        UserController controller = new UserController();
        // controller.userService는 null 상태

        // 생성자 주입: 의존성을 쉽게 주입
        UserService mockService = mock(UserService.class);
        UserController controller = new UserController(mockService);
    }
}
```

필드 주입은 리플렉션을 사용하거나 Spring 컨테이너를 띄워야 테스트가 가능한다.

### 순환 참조 감지가 늦음

필드 주입은 런타임에 순환 참조를 발견하지만, 생성자 주입은 애플리케이션 시작 시점에 발견한다.

```java
@Service
public class UserService {
    @Autowired
    private OrderService orderService; // 순환 참조
}

@Service
public class OrderService {
    @Autowired
    private UserService userService; // 순환 참조
}
```

필드 주입은 이 코드가 실행되기 전까지 문제를 모른다. 생성자 주입이었다면 애플리케이션 시작이 실패해서 즉시 알 수 있다.

```java
@Service
public class UserService {
    private final OrderService orderService;

    public UserService(OrderService orderService) {
        this.orderService = orderService;
    }
}

@Service
public class OrderService {
    private final UserService userService;

    public OrderService(UserService userService) {
        this.userService = userService;
    }
}
// 애플리케이션 시작 실패: BeanCurrentlyInCreationException
```

### 의존성이 많을 때 경고 신호를 놓침

필드 주입은 의존성을 계속 추가해도 코드가 짧아서 문제를 못 느낀다.

```java
@Service
public class UserService {
    @Autowired private UserRepository userRepository;
    @Autowired private EmailService emailService;
    @Autowired private SmsService smsService;
    @Autowired private NotificationService notificationService;
    @Autowired private LogService logService;
    @Autowired private AuditService auditService;
    @Autowired private CacheService cacheService;
    @Autowired private ValidationService validationService;
    // 의존성이 너무 많은데 눈에 잘 안 띔
}
```

생성자 주입은 생성자가 길어져서 클래스가 너무 많은 책임을 가지고 있다는 신호를 준다.

```java
@Service
public class UserService {

    public UserService(
            UserRepository userRepository,
            EmailService emailService,
            SmsService smsService,
            NotificationService notificationService,
            LogService logService,
            AuditService auditService,
            CacheService cacheService,
            ValidationService validationService) {
        // 생성자가 너무 길다 = 리팩토링 필요
    }
}
```

이 경우 클래스를 분리하거나 책임을 나누는 리팩토링이 필요한다.

## Autowired vs Inject

`@Autowired`는 Spring 전용이고 `@Inject`는 Java 표준이다.

### Autowired

Spring Framework에서 제공하는 애노테이션이다.

```java
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class UserService {

    private final UserRepository userRepository;

    @Autowired // Spring 전용
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

`required` 속성으로 필수 여부를 지정할 수 있다.

```java
@Service
public class EmailService {

    private final MailSender mailSender;

    @Autowired(required = false) // 없어도 됨
    public void setMailSender(MailSender mailSender) {
        this.mailSender = mailSender;
    }
}
```

### Inject

JSR-330 Java 표준 애노테이션이다.

```java
import javax.inject.Inject; // Spring Boot 2.x
import jakarta.inject.Inject; // Spring Boot 3.x

@Service
public class UserService {

    private final UserRepository userRepository;

    @Inject // Java 표준
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

의존성을 추가해야 사용할 수 있다.

```xml
<!-- Maven -->
<dependency>
    <groupId>jakarta.inject</groupId>
    <artifactId>jakarta.inject-api</artifactId>
    <version>2.0.1</version>
</dependency>
```

```text
// Gradle
implementation 'jakarta.inject:jakarta.inject-api:2.0.1'
```

### 차이점

기능적으로는 거의 동일하지만 몇 가지 차이가 있다.

```java
// @Autowired는 required 옵션이 있음
@Autowired(required = false)
private Optional<CacheService> cacheService;

// @Inject는 required 옵션이 없음
@Inject
private Optional<CacheService> cacheService;
```

실무에서는 Spring을 사용하고 있으니 `@Autowired`를 쓰거나 생성자 주입에서는 아예 생략하는 것을 권장한다.

## Lombok과 생성자 주입

생성자 주입은 코드가 길어지는데 Lombok을 사용하면 간결하게 작성할 수 있다.

### RequiredArgsConstructor

`final` 필드만 포함하는 생성자를 자동으로 생성해 준다.

```java
import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor // 생성자 자동 생성
public class UserController {

    private final UserService userService;
    private final EmailService emailService;

    // 생성자가 자동으로 생성됨
    // public UserController(UserService userService, EmailService emailService) {
    //     this.userService = userService;
    //     this.emailService = emailService;
    // }

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
}
```

이렇게 하면 필드 주입처럼 간결하면서도 생성자 주입의 장점을 모두 가질 수 있다.

### AllArgsConstructor vs RequiredArgsConstructor

```java
@AllArgsConstructor // 모든 필드를 포함하는 생성자
public class UserService {

    private final UserRepository userRepository;
    private final EmailService emailService;
    private String configValue; // final이 아닌 필드도 포함됨
}

@RequiredArgsConstructor // final 필드만 포함하는 생성자
public class UserService {

    private final UserRepository userRepository;
    private final EmailService emailService;
    private String configValue; // 생성자에 포함 안 됨
}
```

의존성 주입에는 `@RequiredArgsConstructor`를 사용한다.

### NonNull과 함께 사용

`@NonNull`이 붙은 필드도 생성자에 포함된다.

```java
@RequiredArgsConstructor
public class UserService {

    private final UserRepository userRepository; // 포함됨
    @NonNull
    private EmailService emailService; // 포함됨
    private String configValue; // 포함 안 됨

    // 생성된 생성자:
    // public UserService(UserRepository userRepository, EmailService emailService)
}
```

하지만 의존성 주입에서는 대부분 `final`만 사용한다.

### Lombok 의존성 추가

```xml
<!-- Maven -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <scope>provided</scope>
</dependency>
```

```text
// Gradle
compileOnly 'org.projectlombok:lombok'
annotationProcessor 'org.projectlombok:lombok'
```

## Bean 스코프

Spring의 Bean은 생명주기를 가지고 있고 스코프로 관리된다.

### Singleton 스코프

기본 스코프이다. 애플리케이션 전체에서 하나의 인스턴스만 생성된다.

```java
@Service
@Scope("singleton") // 생략 가능 (기본값)
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

같은 Bean을 여러 곳에서 주입받아도 모두 같은 인스턴스이다.

```java
@RestController
public class UserController {
    private final UserService userService; // 인스턴스 A
}

@RestController
public class AdminController {
    private final UserService userService; // 동일한 인스턴스 A
}
```

대부분의 Bean은 Singleton으로 사용한다.

### Prototype 스코프

요청할 때마다 새로운 인스턴스를 생성한다.

```java
@Service
@Scope("prototype")
public class ReportGenerator {

    private String reportData;

    public void setReportData(String data) {
        this.reportData = data;
    }
}
```

주입받을 때마다 다른 인스턴스가 생성된다.

```java
@RestController
public class ReportController {

    private final ApplicationContext context;

    @GetMapping("/reports")
    public Report generate() {
        // 매번 새로운 인스턴스
        ReportGenerator generator1 = context.getBean(ReportGenerator.class);
        ReportGenerator generator2 = context.getBean(ReportGenerator.class);
        // generator1 != generator2
    }
}
```

생성자 주입으로는 Prototype Bean을 제대로 사용할 수 없다. 생성자는 한 번만 호출되기 때문이다.

```java
@RestController
public class ReportController {

    private final ReportGenerator generator; // 처음 한 번만 생성됨

    public ReportController(ReportGenerator generator) {
        this.generator = generator; // Prototype이지만 계속 같은 인스턴스
    }
}
```

Prototype Bean이 필요하면 `Provider`나 `ObjectFactory`를 사용한다.

```java
@RestController
public class ReportController {

    private final ObjectProvider<ReportGenerator> generatorProvider;

    public ReportController(ObjectProvider<ReportGenerator> generatorProvider) {
        this.generatorProvider = generatorProvider;
    }

    @GetMapping("/reports")
    public Report generate() {
        ReportGenerator generator = generatorProvider.getObject(); // 매번 새로운 인스턴스
        generator.setReportData("data");
        return generator.generate();
    }
}
```

### Request 스코프

HTTP 요청마다 새로운 인스턴스를 생성한다. 웹 애플리케이션에서만 사용할 수 있다.

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestContext {

    private String requestId;
    private LocalDateTime requestTime;

    public RequestContext() {
        this.requestId = UUID.randomUUID().toString();
        this.requestTime = LocalDateTime.now();
    }
}
```

`proxyMode`를 설정해야 Singleton Bean에 주입할 수 있다.

```java
@RestController
@RequiredArgsConstructor
public class UserController {

    private final RequestContext requestContext; // 프록시가 주입됨

    @GetMapping("/users/{id}")
    public User getUser(@PathVariable Long id) {
        log.info("Request ID: {}", requestContext.getRequestId());
        // 실제 메서드 호출 시점에 현재 요청의 Bean을 가져옴
        return userService.findById(id);
    }
}
```

요청마다 다른 `RequestContext` 인스턴스가 사용된다.

### Session 스코프

HTTP 세션마다 새로운 인스턴스를 생성한다.

```java
@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ShoppingCart {

    private List<Item> items = new ArrayList<>();

    public void addItem(Item item) {
        items.add(item);
    }
}
```

같은 세션의 요청은 같은 인스턴스를 공유한다.

### Application 스코프

ServletContext 생명주기와 같다. Singleton과 비슷하지만 웹 애플리케이션 전체에서 하나만 생성된다.

```java
@Component
@Scope("application")
public class AppConfig {

    private final Map<String, String> configs = new HashMap<>();

    public void setConfig(String key, String value) {
        configs.put(key, value);
    }
}
```

### 스코프 선택 기준

대부분의 경우 Singleton을 사용한다.

```
- 상태가 없는 Service, Repository, Controller → Singleton (기본값)
- 요청마다 다른 데이터를 저장해야 함 → Request
- 세션마다 다른 데이터를 저장해야 함 → Session
- 매번 새로운 인스턴스가 필요함 → Prototype
```

상태를 가지는 Bean을 Singleton으로 만들면 동시성 문제가 발생한다.

```java
@Service // Singleton
public class UserService {

    private User currentUser; // 모든 요청이 공유 - 위험!

    public void process(Long userId) {
        this.currentUser = userRepository.findById(userId);
        // 다른 요청이 currentUser를 덮어쓸 수 있음
    }
}
```

이런 경우 상태를 제거하거나 다른 스코프를 사용해야 한다.

```java
@Service
public class UserService {

    // 상태 제거 - 메서드 파라미터로 전달
    public void process(User user) {
        // user는 메서드 스택에 저장되므로 스레드 안전
    }
}
```

## 실전 패턴

### 선택적 의존성

특정 Bean이 없어도 동작해야 하는 경우이다.

```java
@Service
@RequiredArgsConstructor
public class NotificationService {

    private final EmailService emailService;
    private final Optional<SmsService> smsService; // 선택적

    public void notify(User user, String message) {
        emailService.send(user.getEmail(), message);

        smsService.ifPresent(service ->
            service.send(user.getPhone(), message)
        );
    }
}
```

### 같은 타입의 여러 Bean

인터페이스의 구현체가 여러 개인 경우이다.

```java
public interface PaymentGateway {
    void pay(int amount);
}

@Component("creditCard")
public class CreditCardPayment implements PaymentGateway {
    public void pay(int amount) { /* 신용카드 결제 */ }
}

@Component("bankTransfer")
public class BankTransferPayment implements PaymentGateway {
    public void pay(int amount) { /* 계좌이체 */ }
}
```

`@Qualifier`로 특정 Bean을 선택할 수 있다.

```java
@Service
public class PaymentService {

    private final PaymentGateway creditCardPayment;
    private final PaymentGateway bankTransferPayment;

    public PaymentService(
            @Qualifier("creditCard") PaymentGateway creditCardPayment,
            @Qualifier("bankTransfer") PaymentGateway bankTransferPayment) {
        this.creditCardPayment = creditCardPayment;
        this.bankTransferPayment = bankTransferPayment;
    }
}
```

또는 모든 구현체를 List로 받을 수 있다.

```java
@Service
@RequiredArgsConstructor
public class PaymentService {

    private final List<PaymentGateway> gateways;

    public void payAll(int amount) {
        gateways.forEach(gateway -> gateway.pay(amount));
    }
}
```

Map으로 받으면 Bean 이름을 키로 사용할 수 있다.

```java
@Service
@RequiredArgsConstructor
public class PaymentService {

    private final Map<String, PaymentGateway> gatewayMap;

    public void pay(String method, int amount) {
        PaymentGateway gateway = gatewayMap.get(method);
        gateway.pay(amount);
    }
}
```

### Primary Bean

여러 구현체 중 기본값을 지정할 수 있다.

```java
@Component
@Primary // 기본 구현체
public class CreditCardPayment implements PaymentGateway {
    public void pay(int amount) { /* 신용카드 결제 */ }
}

@Component
public class BankTransferPayment implements PaymentGateway {
    public void pay(int amount) { /* 계좌이체 */ }
}
```

```java
@Service
@RequiredArgsConstructor
public class PaymentService {

    private final PaymentGateway gateway; // CreditCardPayment가 주입됨
}
```

### 지연 초기화

Bean을 실제로 사용할 때까지 생성을 미루고 싶을 때 사용한다.

```java
@Service
@Lazy
public class HeavyService {

    public HeavyService() {
        // 무거운 초기화 작업
        System.out.println("HeavyService created");
    }
}
```

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final HeavyService heavyService; // 아직 생성 안 됨

    public void someMethod() {
        heavyService.doSomething(); // 이 시점에 생성됨
    }
}
```

또는 특정 의존성만 지연 초기화할 수 있다.

```java
@Service
public class UserService {

    private final EmailService emailService;
    private final HeavyService heavyService;

    public UserService(
            EmailService emailService,
            @Lazy HeavyService heavyService) { // 이것만 지연
        this.emailService = emailService;
        this.heavyService = heavyService;
    }
}
```

## 정리

Spring의 의존성 주입은 생성자 주입을 기본으로 사용하는 것이 좋다.
Lombok의 `@RequiredArgsConstructor`를 함께 사용하면 코드도 간결해진다.
필드 주입은 테스트가 어렵고 불변성을 보장하지 못하며 순환 참조를 늦게 발견하는 등 여러 문제가 있어서 피하는 것이 좋다.

Bean 스코프는 대부분 Singleton을 사용하고, 특별한 경우에만 Prototype, Request, Session 같은 다른 스코프를 고려한다.
상태를 가지는 Bean은 동시성 문제를 일으킬 수 있으므로 주의해야 한다.
