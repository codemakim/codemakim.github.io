---
title: "[React Router 6/12] React Router - Protected Routes"
date: "2025-08-20"
description: "인증 기반 라우트 보호, 리다이렉트 처리"
tags: ["React", "고급", "프론트엔드"]
series: "React Router"
seriesOrder: 6
---

# React Router 가이드 - Protected Routes

> React Router v6를 기반으로 한 라우팅 학습 자료  
> 출처: [React Router Documentation](https://reactrouter.com/)

---

## Protected Routes

Protected routes는 “라우트에 접근할 수 있는 조건”을 코드로 표현하는 패턴이다. 인증 여부, 역할(RBAC), 구독 상태, 조직 멤버십 같은 정책이 여기에 들어간다.

실무에서 이 주제는 단순히 “안 들어가게 막는다” 수준이 아니라, 다음까지 포함한다.

- 로그인 전: 막는다
- 로그인 후: 원래 가려던 페이지로 되돌린다
- 권한 부족: 403(unauthorized) 화면으로 보낸다
- 인증 상태 확인 중: 깜빡임 없이 로딩 상태를 보여준다
- 보안: 클라이언트 가드는 UX일 뿐, 서버에서도 권한을 강제한다

---

## 1. 가장 단순한 인증 가드

```tsx
import { Navigate } from "react-router-dom";

export function RequireAuth({
  isAuthenticated,
  children,
}: {
  isAuthenticated: boolean;
  children: React.ReactNode;
}) {
  if (!isAuthenticated) return <Navigate to="/login" replace />;
  return children;
}
```

이 방식은 “렌더 결과를 바꾼다”는 점에서 안전하다. 렌더링 중에 `navigate()`를 호출하지 않는다.

---

## 2. 원래 가려던 페이지로 되돌리기

로그인 성공 후 원래 경로로 복귀시키려면, “차단된 순간의 목적지”를 저장해야 한다.

여기서 흔한 실수는 `location` 객체 전체를 통째로 넣는 것이다. 팀 규칙과 직렬화 이슈를 피하려면 문자열로 최소화하는 편이 낫다.

```tsx
import { Navigate, useLocation } from "react-router-dom";

export function RequireAuth({
  isAuthenticated,
  children,
}: {
  isAuthenticated: boolean;
  children: React.ReactNode;
}) {
  const location = useLocation();

  if (!isAuthenticated) {
    const from = location.pathname + location.search + location.hash;
    return <Navigate to="/login" replace state={{ from }} />;
  }

  return children;
}
```

로그인 페이지는 `state.from`으로 복귀한다.

```tsx
import { useLocation, useNavigate } from "react-router-dom";

type LoginState = { from?: string };

export default function LoginPage() {
  const navigate = useNavigate();
  const location = useLocation();
  const state = (location.state ?? {}) as LoginState;

  async function handleLogin() {
    // 로그인 성공 가정
    const to = state.from ?? "/dashboard";
    navigate(to, { replace: true });
  }

  return <button onClick={handleLogin}>login</button>;
}
```

### 실무 포인트: open redirect를 막는다

`from`이 외부 URL로 변조되면 피싱으로 이어질 수 있다. `from`은 “앱 내부 경로”만 허용하도록 검증하는 편이 안전하다.

---

## 3. 인증 로딩 상태(깜빡임) 처리

실무에서 가장 많이 터지는 UX는 “처음에는 비로그인으로 보였다가 곧 로그인으로 바뀌며 화면이 튄다”는 현상이다.

인증 확인이 비동기라면 로딩 상태를 분리해야 한다.

```tsx
import { Navigate, useLocation } from "react-router-dom";

type AuthState =
  | { status: "loading" }
  | { status: "authenticated"; user: { role: string } }
  | { status: "anonymous" };

export function RequireAuth({
  auth,
  children,
}: {
  auth: AuthState;
  children: React.ReactNode;
}) {
  const location = useLocation();

  if (auth.status === "loading") return <div>loading...</div>;

  if (auth.status === "anonymous") {
    const from = location.pathname + location.search + location.hash;
    return <Navigate to="/login" replace state={{ from }} />;
  }

  return children;
}
```

---

## 4. 역할 기반 접근 제어(RBAC)

권한은 인증과 다르다. 로그인했어도 권한이 없으면 접근을 막아야 한다.

```tsx
import { Navigate } from "react-router-dom";

export function RequireRole({
  userRole,
  allowedRoles,
  children,
}: {
  userRole: string;
  allowedRoles: string[];
  children: React.ReactNode;
}) {
  if (!allowedRoles.includes(userRole)) {
    return <Navigate to="/unauthorized" replace />;
  }
  return children;
}
```

실무에서는 “권한 정책은 서버에서 강제한다”가 기본이고, 클라이언트는 사용자 경험을 위해 빠르게 차단하는 역할을 한다.

---

## 5. 라우트에 적용하는 방식

Protected route는 컴포넌트로 감싸서 적용한다.

```tsx
import { Routes, Route } from "react-router-dom";

<Routes>
  <Route path="/login" element={<LoginPage />} />
  <Route
    path="/admin"
    element={
      <RequireAuth auth={auth}>
        <RequireRole userRole={auth.status === "authenticated" ? auth.user.role : ""} allowedRoles={["admin"]}>
          <AdminPage />
        </RequireRole>
      </RequireAuth>
    }
  />
</Routes>;

## Vue Router와 비교

Vue Router는 라우트 메타와 전역 가드가 먼저 떠오른다. React Router는 “라우트를 컴포넌트로 감싼다”는 구성이 더 자연스럽다.

### Vue Router: meta + navigation guard

```javascript
// router.beforeEach 기반 (개념 예시)
router.beforeEach((to, from, next) => {
  const isAuthenticated = authStore.isAuthenticated;
  const role = authStore.user?.role;

  if (to.meta.requiresAuth && !isAuthenticated) {
    next({ path: "/login", query: { from: to.fullPath } });
    return;
  }

  if (to.meta.role && to.meta.role !== role) {
    next({ path: "/unauthorized" });
    return;
  }

  next();
});
```

### React Router: wrapper component + `<Navigate />`

```tsx
import { Navigate, useLocation } from "react-router-dom";

function RequireAuth({ isAuthenticated, children }: { isAuthenticated: boolean; children: React.ReactNode }) {
  const location = useLocation();
  if (!isAuthenticated) {
    const from = location.pathname + location.search + location.hash;
    return <Navigate to="/login" replace state={{ from }} />;
  }
  return children;
}
```

두 방식 모두 목표는 동일하다. 차이는 “정책을 어디에 둬서 팀이 유지보수하기 쉬운가”에 있다. React Router에서는 라우트 정의에서 감싸는 방식이 컴포넌트 합성에 잘 맞는다.

---
