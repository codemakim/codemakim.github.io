---
title: "[상태 관리 4/5] 상태 관리 - 상태 관리 라이브러리 비교"
date: "2025-09-04"
description: "Zustand, Redux, Jotai 비교 및 선택 가이드"
tags: ["React", "고급", "프론트엔드"]
series: "상태 관리"
seriesOrder: 4
---

# React 상태 관리 라이브러리 가이드 - 상태 관리 라이브러리 비교

> Zustand, Redux Toolkit을 중심으로 한 상태 관리 학습 자료

---

## 상태 관리 라이브러리 비교

상태 관리 라이브러리 비교
Jotai

### 개요

Jotai는 원자적(atomic) 접근 방식의 상태 관리 라이브러리이다.
특징:

- 원자(atom) 기반
- 최소한의 보일러플레이트
- TypeScript 친화적
- Suspense 지원

### 설치

```bash
npm install jotai
```

### 기본 사용법

```jsx
// atoms.js
import { atom } from "jotai";
export const countAtom = atom(0);
export const nameAtom = atom("John");
```

```jsx
// components/Counter.jsx
import { useAtom } from "jotai";
import { countAtom } from "../atoms";
export default function Counter() {
  const [count, setCount] = useAtom(countAtom);
  return (
    <div>
      <h1>{count}</h1>
      <button onClick={() => setCount((c) => c + 1)}>Increment</button>
    </div>
  );
}
```

### 읽기 전용 / 쓰기 전용

```jsx
import { useAtomValue, useSetAtom } from "jotai";
function Display() {
  const count = useAtomValue(countAtom); // 읽기 전용
  return <h1>{count}</h1>;
}
function Controls() {
  const setCount = useSetAtom(countAtom); // 쓰기 전용
  return <button onClick={() => setCount((c) => c + 1)}>+</button>;
}
```

### 파생 Atom

```jsx
import { atom } from "jotai";
const countAtom = atom(0);
const doubleCountAtom = atom((get) => get(countAtom) * 2);
function Display() {
  const [count] = useAtom(countAtom);
  const [doubleCount] = useAtom(doubleCountAtom);

  return (
    <div>
      <p>Count: {count}</p>
      <p>Double: {doubleCount}</p>
    </div>
  );
}
```

### 비동기 Atom

```jsx
import { atom } from "jotai";
const userIdAtom = atom(1);
const userAtom = atom(async (get) => {
  const userId = get(userIdAtom);
  const response = await fetch(`/api/users/${userId}`);
  return response.json();
});
function UserProfile() {
  const [user] = useAtom(userAtom);

  return <div>{user.name}</div>;
}
```

### Atom with Storage

```jsx
import { atomWithStorage } from "jotai/utils";
const themeAtom = atomWithStorage("theme", "light");
function ThemeToggle() {
  const [theme, setTheme] = useAtom(themeAtom);

  return (
    <button onClick={() => setTheme(theme === "light" ? "dark" : "light")}>
      {theme}
    </button>
  );
}
```

---

## 상태 관리 라이브러리 비교

### 번들 크기

```
Zustand:        ~1KB
Jotai:          ~3KB
Redux Toolkit:  ~13KB
Recoil:         ~20KB
```

### 성능 비교

| 라이브러리    | 리렌더링 최적화 | DevTools   | TypeScript |
| ------------- | --------------- | ---------- | ---------- |
| Zustand       | ⭐⭐⭐⭐⭐      | ⭐⭐⭐     | ⭐⭐⭐⭐⭐ |
| Redux Toolkit | ⭐⭐⭐⭐        | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐   |
| Jotai         | ⭐⭐⭐⭐⭐      | ⭐⭐⭐     | ⭐⭐⭐⭐⭐ |

### API 복잡도

```jsx
// Zustand (가장 간단)
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

// Jotai (원자적)
const countAtom = atom(0);
const [count, setCount] = useAtom(countAtom);

// Redux Toolkit (구조화됨)
const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value++;
    },
  },
});
```

---

## 언제 무엇을 사용할까

### Zustand를 사용하라

장점:

- 매우 간단한 API
- 보일러플레이트 거의 없음
- 번들 크기 최소
  사용 사례:
- 중소형 앱
- 빠른 프로토타이핑
- 간단한 전역 상태

```jsx
// 간단한 인증 상태
const useAuthStore = create((set) => ({
  user: null,
  login: (user) => set({ user }),
  logout: () => set({ user: null }),
}));
```

### Redux Toolkit을 사용하라

장점:

- 강력한 DevTools
- 시간 여행 디버깅
- 대규모 팀에 검증됨
  사용 사례:
- 대규모 앱
- 복잡한 상태 로직
- 많은 비동기 작업

```jsx
// 복잡한 비즈니스 로직
const orderSlice = createSlice({
  name: "orders",
  initialState: { list: [], filters: {}, sorting: {} },
  reducers: {
    // 많은 reducer...
  },
});
```

### Jotai를 사용하라

장점:

- 원자적 업데이트
- Suspense 지원
- 최소 리렌더링
  사용 사례:
- 세밀한 상태 제어
- Suspense 활용
- 원자적 상태 관리

```jsx
// 독립적인 상태 조각들
const userAtom = atom(null);
const settingsAtom = atom({});
const themeAtom = atom("light");
```

### Context API를 사용하라

언제:

- 상태가 적을 때
- 성능이 중요하지 않을 때
- 외부 의존성을 피하고 싶을 때

```jsx
const ThemeContext = createContext();
```

---

## 실전 예제: E-Commerce 앱

### Zustand 버전

```jsx
// stores/useCartStore.js
import { create } from "zustand";
import { persist } from "zustand/middleware";

const useCartStore = create(
  persist(
    (set, get) => ({
      items: [],

      addItem: (product) =>
        set((state) => {
          const existing = state.items.find((item) => item.id === product.id);
          if (existing) {
            return {
              items: state.items.map((item) =>
                item.id === product.id
                  ? { ...item, quantity: item.quantity + 1 }
                  : item,
              ),
            };
          }
          return { items: [...state.items, { ...product, quantity: 1 }] };
        }),

      removeItem: (productId) =>
        set((state) => ({
          items: state.items.filter((item) => item.id !== productId),
        })),

      updateQuantity: (productId, quantity) =>
        set((state) => ({
          items: state.items.map((item) =>
            item.id === productId ? { ...item, quantity } : item,
          ),
        })),

      clearCart: () => set({ items: [] }),

      getTotal: () => {
        const { items } = get();
        return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
      },
    }),
    { name: "cart-storage" },
  ),
);

export default useCartStore;
```

```jsx
// components/Cart.jsx
import useCartStore from "../stores/useCartStore";

export default function Cart() {
  const items = useCartStore((state) => state.items);
  const removeItem = useCartStore((state) => state.removeItem);
  const updateQuantity = useCartStore((state) => state.updateQuantity);
  const getTotal = useCartStore((state) => state.getTotal);

  return (
    <div>
      <h2>Shopping Cart</h2>
      {items.map((item) => (
        <div key={item.id}>
          <span>{item.name}</span>
          <input
            type="number"
            value={item.quantity}
            onChange={(e) => updateQuantity(item.id, Number(e.target.value))}
          />
          <span>${item.price * item.quantity}</span>
          <button onClick={() => removeItem(item.id)}>Remove</button>
        </div>
      ))}
      <div>Total: ${getTotal()}</div>
    </div>
  );
}
```

### Redux Toolkit 버전

```jsx
// slices/cartSlice.js
import { createSlice } from "@reduxjs/toolkit";

const cartSlice = createSlice({
  name: "cart",
  initialState: {
    items: [],
  },
  reducers: {
    addItem: (state, action) => {
      const existing = state.items.find(
        (item) => item.id === action.payload.id,
      );
      if (existing) {
        existing.quantity++;
      } else {
        state.items.push({ ...action.payload, quantity: 1 });
      }
    },
    removeItem: (state, action) => {
      state.items = state.items.filter((item) => item.id !== action.payload);
    },
    updateQuantity: (state, action) => {
      const item = state.items.find((item) => item.id === action.payload.id);
      if (item) {
        item.quantity = action.payload.quantity;
      }
    },
    clearCart: (state) => {
      state.items = [];
    },
  },
});

export const { addItem, removeItem, updateQuantity, clearCart } =
  cartSlice.actions;

export const selectCartItems = (state) => state.cart.items;
export const selectCartTotal = (state) =>
  state.cart.items.reduce((sum, item) => sum + item.price * item.quantity, 0);

export default cartSlice.reducer;
```

---
