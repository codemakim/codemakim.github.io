---
title: "[React Query 4/8] React Query - 캐싱 전략"
date: "2025-08-27"
description: "Stale Time, Cache Time, Query Invalidation"
tags: ["React", "고급", "프론트엔드"]
series: "React Query"
seriesOrder: 4
---

# React Query 가이드 - 캐싱 전략

> TanStack Query v5를 기반으로 한 데이터 페칭 학습 자료  
> 출처: [TanStack Query Documentation](https://tanstack.com/query/)

---

## 캐싱 전략

캐싱 전략은 단순히 staleTime 값을 정하는 문제가 아니다. 실무에서는 다음을 결정해야 한다.

- 어떤 데이터를 캐시할지
- 캐시 키(queryKey)를 어떻게 설계할지
- 언제 리페치할지(신선도 정책)
- 변경 이후 어떤 범위를 최신화할지(무효화/직접 업데이트)

---

## 1. 캐시의 상태 모델: fresh / stale / inactive

- fresh: `staleTime` 안에 있는 데이터다. 자동 리페치가 억제되는 구간이 된다.
- stale: `staleTime`이 지난 데이터다. 여전히 캐시로 즉시 렌더링할 수 있지만, 정책에 따라 리페치가 일어난다.
- inactive: 현재 이 쿼리를 구독하는 컴포넌트가 0개인 상태다. v5에서는 `gcTime` 이후에 제거 대상이 된다.

이 모델을 이해하면 “왜 지금 리페치가 일어났는가”를 설명할 수 있다.

---

## 2. staleTime과 gcTime(v5)을 분리한다

TanStack Query v5 기준으로 정리한다.

| 옵션 | 의미 | 실무 영향 |
| --- | --- | --- |
| `staleTime` | 신선도 | 리페치 빈도, UX(깜빡임/백그라운드 갱신) |
| `gcTime` | 메모리 유지 | 화면 재진입 시 캐시 재사용 여부, 메모리 사용량 |

```tsx
useQuery({
  queryKey: ["user", userId],
  queryFn: () => fetchUser(userId),
  staleTime: 1000 * 60, // 1분
  gcTime: 1000 * 60 * 10, // 10분
});
```

---

## 3. 리페치 트리거를 정책으로 고정한다

리페치는 자동으로도 일어난다. 실무에서는 기본 정책을 통일하지 않으면 화면마다 UX가 달라진다.

- `refetchOnWindowFocus`: 탭 복귀 시 최신화
- `refetchOnReconnect`: 네트워크 복구 시 최신화
- `refetchOnMount`: 마운트 시 리페치 여부

데이터 최신성이 강하게 요구되는 화면(예: 알림, 결제 상태)은 트리거를 켜고, 그렇지 않은 화면은 끄는 식으로 나눈다.

---

## 4. 무효화(invalidate)는 “리페치 예약”이다

무효화는 캐시를 삭제하는 행위가 아니다. 보통은 해당 쿼리를 stale로 만들고, 관찰자가 있다면 리페치를 트리거한다.

```tsx
import { useQueryClient } from "@tanstack/react-query";

const queryClient = useQueryClient();
queryClient.invalidateQueries({ queryKey: ["users"] });
```

### 실무 포인트: 무효화 범위를 좁힌다

`invalidateQueries()`를 남발하면 모든 쿼리가 리페치되어 성능이 무너진다. queryKey 설계를 먼저 잡고, 접두사/정확 일치/필터를 사용한다.

```tsx
queryClient.invalidateQueries({ queryKey: ["users"], exact: true });
queryClient.invalidateQueries({ queryKey: ["user", userId] });
```

---

## 5. 캐시 직접 업데이트는 “정합성 비용”과 교환한다

목록에 새 항목을 추가하거나, 상세의 특정 필드를 바꾸는 경우 직접 업데이트가 UX를 크게 개선한다.

```tsx
queryClient.setQueryData(["user", userId], (old: any) => {
  if (!old) return old;
  return { ...old, nickname: "kim" };
});
```

하지만 캐시를 직접 업데이트하는 순간, “어떤 쿼리들이 같은 도메인 데이터를 공유하는가”를 추적해야 한다. 그래서 실무에서는 다음 규칙이 필요하다.

- 단일 쿼리만 영향을 받는 경우에만 setQueryData를 우선한다.
- 다수의 목록/필터 조합이 영향을 받는 경우에는 invalidate가 더 안전하다.

---

## 6. Query Key 팩토리로 캐시 설계를 고정한다

queryKey는 프로젝트 규모가 커질수록 흩어진다. 키를 한 곳에 모으면 무효화 범위가 명확해진다.

```tsx
export const userKeys = {
  all: ["users"] as const,
  lists: () => [...userKeys.all, "list"] as const,
  list: (filters: { page: number; role?: string }) => [...userKeys.lists(), filters] as const,
  details: () => [...userKeys.all, "detail"] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};
```

이 구조는 “무효화 규칙”을 코드로 만든다.

```tsx
queryClient.invalidateQueries({ queryKey: userKeys.all });
queryClient.invalidateQueries({ queryKey: userKeys.detail(userId) });
```

---

## Vue와 비교

Vue에서도 Vue Query를 쓰면 캐시 모델은 동일하다. Pinia 중심으로 서버 상태를 관리하면 “staleTime/gcTime에 해당하는 정책”을 팀이 직접 구현하게 된다.

| 관심사 | Vue Query | React Query |
| --- | --- | --- |
| 신선도/메모리 정책 | `staleTime`, `gcTime` | `staleTime`, `gcTime` |
| 무효화 | `invalidateQueries` | `invalidateQueries` |
| 키 팩토리 | composable/모듈 | 모듈 |

---

## 체크리스트

- `staleTime`과 `gcTime`의 역할을 분리해서 설명할 수 있다.
- 무효화가 “삭제”가 아니라 “stale 처리 + 리페치 트리거”라는 점을 이해한다.
- queryKey 팩토리로 무효화 범위를 안정적으로 설계할 수 있다.

---
