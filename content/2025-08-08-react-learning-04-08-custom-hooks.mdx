---
title: "[React 기초 4-8/9] 커스텀 Hook으로 로직 재사용하기"
date: "2025-08-08"
description: "커스텀 Hook을 만들고 사용하는 방법과 모범 사례"
tags: ["React", "학습", "Hook", "중급"]
series: "React 기초"
seriesOrder: 34
---

# 커스텀 Hook으로 로직 재사용하기

동일한 로직을 여러 컴포넌트에서 사용한다면 커스텀 Hook으로 추출해야 한다.

## 커스텀 Hook이란?

React는 `useState`, `useEffect` 같은 내장 Hook을 제공하지만, 직접 Hook을 만들 수도 있다.

**커스텀 Hook**은 컴포넌트 로직을 재사용 가능한 함수로 추출한 것이다.

### 기본 규칙

**명명 규칙:** `use`로 시작해야 한다

```jsx
// 좋은 예
function useOnlineStatus() { }
function useFormInput() { }
function useFetch() { }

// 나쁜 예
function getOnlineStatus() { }  // Hook이 아님
function formInput() { }  // Hook이 아님
```

**왜 `use`로 시작해야 하나?**

React는 함수 이름으로 Hook인지 판단한다. `use`로 시작하지 않으면 Hook의 규칙을 검증할 수 없다.

## 첫 번째 커스텀 Hook: useOnlineStatus

온라인/오프라인 상태를 감지하는 로직을 여러 컴포넌트에서 사용한다고 가정한다.

### Before: 중복된 로직

```jsx
// StatusBar 컴포넌트
function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return <h1>{isOnline ? 'Online' : 'Disconnected'}</h1>;
}

// SaveButton 컴포넌트
function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return (
    <button disabled={!isOnline}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}
```

두 컴포넌트가 같은 로직을 중복해서 사용한다.

### After: 커스텀 Hook으로 추출

```jsx
// useOnlineStatus.js
import { useState, useEffect } from 'react';

function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  
  return isOnline;
}

export default useOnlineStatus;
```

이제 컴포넌트에서 간단하게 사용할 수 있다:

```jsx
// StatusBar 컴포넌트
function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? 'Online' : 'Disconnected'}</h1>;
}

// SaveButton 컴포넌트
function SaveButton() {
  const isOnline = useOnlineStatus();

  return (
    <button disabled={!isOnline}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}
```

훨씬 간결하고 이해하기 쉽다.

## 커스텀 Hook은 state를 공유하지 않는다

**중요:** 커스텀 Hook은 로직만 공유하고, 각 컴포넌트는 독립적인 state를 가진다.

```jsx
function StatusBar() {
  const isOnline = useOnlineStatus();  // 독립적인 state
  // ...
}

function SaveButton() {
  const isOnline = useOnlineStatus();  // 독립적인 state
  // ...
}
```

`StatusBar`와 `SaveButton`은 각각 자신만의 `isOnline` state를 가진다. 하나가 변경되어도 다른 하나에 영향을 주지 않는다.

**커스텀 Hook의 동작:**

- `useOnlineStatus()`를 호출할 때마다 새로운 `useState`와 `useEffect`가 실행된다
- 각 컴포넌트는 독립적인 state와 Effect를 가진다
- 로직(코드)은 공유하지만, 데이터(state)는 공유하지 않는다

## 실전 커스텀 Hook 예제 6가지

### 1. useLocalStorage - localStorage 동기화

```jsx
import { useState, useEffect } from 'react';

function useLocalStorage(key, initialValue) {
  // localStorage에서 초기값 읽기
  const [value, setValue] = useState(() => {
    const saved = localStorage.getItem(key);
    return saved !== null ? JSON.parse(saved) : initialValue;
  });

  // value가 변경되면 localStorage에 저장
  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(value));
  }, [key, value]);

  return [value, setValue];
}

// 사용 예
function App() {
  const [name, setName] = useLocalStorage('name', '');
  
  return (
    <input
      value={name}
      onChange={e => setName(e.target.value)}
      placeholder="Your name"
    />
  );
}
```

**장점:** 자동으로 localStorage와 동기화된다.

### 2. useWindowSize - 창 크기 추적

```jsx
import { useState, useEffect } from 'react';

function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  useEffect(() => {
    function handleResize() {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    }

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  return size;
}

// 사용 예
function App() {
  const { width, height } = useWindowSize();
  return <p>Window size: {width} x {height}</p>;
}
```

**용도:** 반응형 레이아웃, 모바일/데스크톱 분기 처리

### 3. useFetch - 데이터 페칭

```jsx
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    setError(null);

    fetch(url)
      .then(response => response.json())
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        setError(error);
        setLoading(false);
      });
  }, [url]);

  return { data, loading, error };
}

// 사용 예
function UserProfile({ userId }) {
  const { data, loading, error } = useFetch(`/api/users/${userId}`);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;
  return <h1>{data.name}</h1>;
}
```

**개선점:** 실제로는 cleanup과 race condition 처리가 필요하다.

### 4. useDebounce - 입력 지연

```jsx
import { useState, useEffect } from 'react';

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

// 사용 예
function SearchBar() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      // API 호출 (사용자가 타이핑을 멈춘 후 500ms 후에 실행)
      searchAPI(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <input
      value={searchTerm}
      onChange={e => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

**용도:** 검색, 자동완성, API 호출 최적화

### 5. usePrevious - 이전 값 기억

```jsx
import { useRef, useEffect } from 'react';

function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

// 사용 예
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);

  return (
    <div>
      <h1>Now: {count}, before: {prevCount}</h1>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**용도:** 애니메이션, 변경 감지, 비교 로직

### 6. useInterval - 안전한 타이머

```jsx
import { useEffect, useRef } from 'react';

function useInterval(callback, delay) {
  const savedCallback = useRef();

  // 최신 callback을 저장
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);

  // interval 설정
  useEffect(() => {
    function tick() {
      savedCallback.current();
    }
    
    if (delay !== null) {
      const id = setInterval(tick, delay);
      return () => clearInterval(id);
    }
  }, [delay]);
}

// 사용 예
function Counter() {
  const [count, setCount] = useState(0);

  useInterval(() => {
    setCount(count + 1);
  }, 1000);

  return <h1>{count}</h1>;
}
```

**특징:** callback이 변경되어도 interval이 재시작되지 않는다.

## 커스텀 Hook 작성 모범 사례

### 1. 이름은 use로 시작

```jsx
// 좋은 예
function useFormInput(initialValue) { }
function useFetch(url) { }

// 나쁜 예
function getFormInput(initialValue) { }
function fetchData(url) { }
```

### 2. 높은 수준의 사용 사례에 집중

**나쁜 예: 너무 일반적**

```jsx
// 너무 일반적이고 추상적
function useEffect2(fn, deps) {
  // useEffect를 감싸기만 함
}
```

**좋은 예: 구체적인 목적**

```jsx
// 구체적이고 목적이 명확
function useChatRoom({ serverUrl, roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [serverUrl, roomId]);
}
```

### 3. Hook은 순수해야 한다

**좋은 예: 순수 함수**

```jsx
function useFormInput(initialValue) {
  const [value, setValue] = useState(initialValue);
  
  function handleChange(e) {
    setValue(e.target.value);
  }
  
  return {
    value,
    onChange: handleChange
  };
}
```

**나쁜 예: 부작용**

```jsx
function useFormInput(initialValue) {
  console.log('Rendering!');  // 순수하지 않음
  const [value, setValue] = useState(initialValue);
  return { value, setValue };
}
```

### 4. 이벤트 핸들러를 Hook으로 추출하지 말 것

**나쁜 예**

```jsx
// 이벤트 핸들러를 Hook으로
function useSubmit(onSubmit) {
  return (e) => {
    e.preventDefault();
    onSubmit();
  };
}
```

**좋은 예**

```jsx
// 일반 함수로
function handleSubmit(e, onSubmit) {
  e.preventDefault();
  onSubmit();
}
```

이벤트 핸들러는 Hook의 규칙을 따를 필요가 없으므로 일반 함수로 작성한다.

## 언제 커스텀 Hook을 만들어야 하나?

**커스텀 Hook을 만들어야 할 때:**

- 동일한 로직을 2개 이상의 컴포넌트에서 사용할 때
- Effect 로직이 복잡하고 이해하기 어려울 때
- 재사용 가능한 라이브러리를 만들 때

**커스텀 Hook을 만들지 말아야 할 때:**

- 한 컴포넌트에서만 사용하는 로직
- 단순한 이벤트 핸들러
- 너무 추상적이고 일반적인 로직

## 정리

- 커스텀 Hook은 `use`로 시작하는 함수다
- 로직을 재사용 가능하게 만든다
- state는 공유하지 않는다 (각 컴포넌트가 독립적)
- 구체적인 목적을 가져야 한다
- 순수 함수로 작성해야 한다
- 동일한 로직을 여러 곳에서 사용할 때 추출한다
