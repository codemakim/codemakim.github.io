---
title: "[React Router 9/9] React Router - 실전 예제 & 다음 단계"
date: "2025-08-23"
description: "블로그 애플리케이션 구현 및 학습 체크리스트"
tags: ["React", "고급", "프론트엔드"]
series: "React 라이브러리"
seriesOrder: 13
---

# React Router 가이드 - 실전 예제 & 다음 단계

> React Router v6를 기반으로 한 라우팅 학습 자료  
> 출처: [React Router Documentation](https://reactrouter.com/)

---

## 실전 예제 & 다음 단계

이 글은 앞선 내용을 한 번에 묶어 “실무에서 자주 등장하는 라우팅 요구사항”을 구현 가능한 단위로 분해한다.

목표는 다음이다.

- 라우트 정의를 분리해 규모가 커져도 유지보수 가능하게 만든다.
- 공통 UX(스크롤 복구, breadcrumb, 모달 라우트)를 규칙으로 고정한다.
- 코드 스플리팅을 라우트 경계에서 안정적으로 적용한다.

### 1. Route 구성 분리

```jsx
// routes/index.jsx
import { lazy } from "react";
const Home = lazy(() => import("../pages/Home"));
const About = lazy(() => import("../pages/About"));
const Dashboard = lazy(() => import("../pages/Dashboard"));
export const routes = [
  {
    path: "/",
    element: <Layout />,
    children: [
      { index: true, element: <Home /> },
      { path: "about", element: <About /> },
      {
        path: "dashboard",
        element: (
          <ProtectedRoute>
            <Dashboard />
          </ProtectedRoute>
        ),
      },
    ],
  },
];
// App.jsx
import { useRoutes } from "react-router-dom";
import { routes } from "./routes";
export default function App() {
  const element = useRoutes(routes);
  return element;
}
```

#### 왜 필요한가

라우트가 20개를 넘어가면 JSX 중첩만으로는 파악이 어려워진다. 라우트 정의를 별도 모듈로 분리하면 다음이 된다.

- URL 설계가 한 파일에서 보인다.
- 접근 제어, 코드 스플리팅, breadcrumb 같은 정책을 라우트 정의에 모을 수 있다.
- 테스트/리뷰가 쉬워진다.

### 2. Breadcrumbs

```jsx
import { useMatches, Link } from "react-router-dom";
function Breadcrumbs() {
  const matches = useMatches();

  const crumbs = matches
    .filter((match) => match.handle?.crumb)
    .map((match) => match.handle.crumb(match.data));

  return (
    <nav>
      {crumbs.map((crumb, index) => (
        <span key={index}>
          {index > 0 && " > "}
          {crumb}
        </span>
      ))}
    </nav>
  );
}
// 라우트 설정
<Route
  path="/users/:userId"
  element={<User />}
  handle={{
    crumb: (data) => <Link to={`/users/${data.userId}`}>{data.name}</Link>,
  }}
/>;
```

#### 왜 필요한가

breadcrumb은 “현재 위치를 설명하는 UI”다. 계층이 깊은 B2B 대시보드에서 특히 중요하다.

실무 포인트는 “화면에서 breadcrumb을 하드코딩하지 않는다”는 점이다. 라우트 정의에 breadcrumb 생성 규칙을 붙여야 구조 변경에 강해진다.

### 3. Scroll Restoration

```jsx
import { useEffect } from "react";
import { useLocation } from "react-router-dom";
function ScrollToTop() {
  const { pathname } = useLocation();

  useEffect(() => {
    window.scrollTo(0, 0);
  }, [pathname]);

  return null;
}
// App.jsx
<BrowserRouter>
  <ScrollToTop />
  <Routes>{/* ... */}</Routes>
</BrowserRouter>;
```

#### 실무 포인트

목록 → 상세 → 뒤로가기에서 스크롤 복구가 필요하다면 “항상 top으로 올린다”는 오히려 UX를 망친다. 이 경우에는 다음 중 하나를 선택한다.

- 리스트 화면의 스크롤 위치를 저장하고 복원한다.
- 상세 진입 시만 top으로 올리고, 뒤로가기는 브라우저 기본 복구에 맡긴다.

앱이 `window`가 아니라 특정 스크롤 컨테이너를 쓰면 `window.scrollTo`는 원하는 대로 동작하지 않는다. 이때는 스크롤 컨테이너 기준으로 복원해야 한다.

### 4. Route-based Code Splitting

```jsx
import { lazy, Suspense } from "react";
const AdminLayout = lazy(() => import("./pages/admin/AdminLayout"));
const AdminDashboard = lazy(() => import("./pages/admin/Dashboard"));
const AdminUsers = lazy(() => import("./pages/admin/Users"));
const routes = [
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Home />,
      },
      {
        path: "admin",
        element: (
          <Suspense fallback={<Loading />}>
            <AdminLayout />
          </Suspense>
        ),
        children: [
          {
            index: true,
            element: (
              <Suspense fallback={<Loading />}>
                <AdminDashboard />
              </Suspense>
            ),
          },
          {
            path: "users",
            element: (
              <Suspense fallback={<Loading />}>
                <AdminUsers />
              </Suspense>
            ),
          },
        ],
      },
    ],
  },
];
```

#### 왜 이렇게 구성하는가

`lazy(() => import(...))`는 “컴포넌트”를 만든다. 그래서 `element`에는 그 컴포넌트를 JSX로 렌더링해야 한다.

- 잘못된 형태: `element: lazy(() => import(...))`
- 올바른 형태: `const X = lazy(...); element: <X />`

또한 `Suspense`는 “lazy 컴포넌트를 렌더링하는 경계”다. 코드 스플리팅을 라우트 단위로 적용할 때는 해당 라우트의 `element`를 `Suspense`로 감싸는 방식이 가장 직관적이다.

### 5. Modal Routes

```jsx
function App() {
  const location = useLocation();
  const state = location.state;
  return (
    <>
      <Routes location={state?.backgroundLocation || location}>
        <Route path="/" element={<Home />} />
        <Route path="/gallery" element={<Gallery />} />
      </Routes>
      {state?.backgroundLocation && (
        <Routes>
          <Route path="/img/:id" element={<ImageModal />} />
        </Routes>
      )}
    </>
  );
}
function Gallery() {
  const location = useLocation();
  return (
    <div>
      {images.map((img) => (
        <Link
          key={img.id}
          to={`/img/${img.id}`}
          state={{ backgroundLocation: location }}
        >
          <img src={img.thumbnail} alt={img.title} />
        </Link>
      ))}
    </div>
  );
}
```

#### 왜 필요한가

모달 라우트는 URL을 가진 모달을 만든다. 실무에서 다음을 해결한다.

- 이미지 상세, 빠른 미리보기, 선택 모달을 “브라우저 뒤로가기”와 자연스럽게 연결한다.
- 모달을 새로고침/공유했을 때도 같은 상태로 재현한다(단독 진입).

핵심은 `backgroundLocation`을 state로 저장해 “뒤에 깔린 화면”을 유지하는 것이다.

---

## 실전 예제: 블로그 애플리케이션

이 예제는 다음 요구사항을 한 번에 담는다.

- 중첩 라우트로 `Layout`을 재사용한다.
- `/posts` 아래에 목록/상세/작성/수정 흐름을 만든다.
- 작성/수정/프로필은 protected route로 보호한다.
- 코드 스플리팅으로 초기 로딩을 줄인다.

```jsx
// App.jsx
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { Suspense, lazy } from "react";

const Layout = lazy(() => import("./components/Layout"));
const Home = lazy(() => import("./pages/Home"));
const PostList = lazy(() => import("./pages/PostList"));
const PostDetail = lazy(() => import("./pages/PostDetail"));
const CreatePost = lazy(() => import("./pages/CreatePost"));
const EditPost = lazy(() => import("./pages/EditPost"));
const Login = lazy(() => import("./pages/Login"));
const Profile = lazy(() => import("./pages/Profile"));
const NotFound = lazy(() => import("./pages/NotFound"));

export default function App() {
  return (
    <BrowserRouter>
      <Suspense fallback={<LoadingScreen />}>
        <Routes>
          <Route path="/" element={<Layout />}>
            <Route index element={<Home />} />
            <Route path="login" element={<Login />} />

            <Route path="posts">
              <Route index element={<PostList />} />
              <Route path=":postId" element={<PostDetail />} />
              <Route
                path="new"
                element={
                  <ProtectedRoute>
                    <CreatePost />
                  </ProtectedRoute>
                }
              />
              <Route
                path=":postId/edit"
                element={
                  <ProtectedRoute>
                    <EditPost />
                  </ProtectedRoute>
                }
              />
            </Route>

            <Route
              path="profile"
              element={
                <ProtectedRoute>
                  <Profile />
                </ProtectedRoute>
              }
            />

            <Route path="*" element={<NotFound />} />
          </Route>
        </Routes>
      </Suspense>
    </BrowserRouter>
  );
}
```

---

## 학습 체크리스트

- URL 파라미터와 쿼리 스트링의 역할을 구분해 설계한다.
- 중첩 라우트에서 레이아웃과 본문(`Outlet`)의 책임을 분리한다.
- 프로그래밍 네비게이션에서 `replace`와 `state`의 의미를 설명할 수 있다.
- protected route가 UX 문제이며, 보안은 서버에서 강제된다는 점을 이해한다.
- 코드 로딩과 데이터 로딩을 분리해 로딩 UI를 설계한다.
- 라우트 정의를 모듈로 분리해 규모 확장에 대비한다.

---

## Vue Router와 비교

Vue Router도 같은 요구사항을 푼다. 차이는 라우트 정의 형식과 경계(loading/error/guard)를 어디에 두는가다.

| 요구사항 | Vue Router | React Router |
| --- | --- | --- |
| 라우트 분리 | routes 배열 모듈화 | `useRoutes`/JSX 라우트 모듈화 |
| breadcrumb | meta + 컴포넌트 조합 | `handle`/matches 기반(데이터 라우터) 또는 별도 규칙 |
| 스크롤 | `scrollBehavior` | `useLocation` 기반 훅/컴포넌트 |
| 코드 스플리팅 | `() => import()` | `React.lazy` + `Suspense` |
| 모달 라우트 | 상태 + 라우트 조합 | `backgroundLocation` 패턴 |

---
