---
title: "[React Router 7/12] React Router - 로딩 및 에러 처리"
date: "2025-08-21"
description: "Suspense, ErrorBoundary, Lazy Loading 적용"
tags: ["React", "고급", "프론트엔드"]
series: "React Router"
seriesOrder: 7
---

# React Router 가이드 - 로딩 및 에러 처리

> React Router v6를 기반으로 한 라우팅 학습 자료  
> 출처: [React Router Documentation](https://reactrouter.com/)

---

## 로딩 및 에러 처리

로딩과 에러 처리는 라우팅에서 UX 품질을 결정하는 축이다. 화면 전환이 빠르더라도, 데이터와 코드가 준비되지 않으면 사용자는 “멈춘 앱”으로 인지한다.

이 글은 다음을 목표로 한다.

- 라우트 전환 시 로딩 UI를 어디에 둘지 결정한다.
- 비동기 에러가 어디서 터지는지 분류한다.
- 에러를 “복구 가능한 형태”로 만든다.

---

## 1. 로딩의 종류를 먼저 나눈다

실무에서 로딩은 크게 두 가지다.

- 코드 로딩: 번들 분할로 인해 해당 화면 컴포넌트 자체가 아직 없다.
- 데이터 로딩: 컴포넌트는 떠 있지만 API 응답을 기다린다.

두 로딩은 해결책이 다르다.

| 로딩 종류 | 대표 원인 | 대표 해결책 |
| --- | --- | --- |
| 코드 로딩 | `React.lazy()` / dynamic import | `Suspense fallback` |
| 데이터 로딩 | fetch/React Query 등 | skeleton/placeholder, 캐시, prefetch |

---

## 2. 코드 로딩: 라우트 단위 코드 스플리팅

```tsx
import React, { Suspense } from "react";
import { Routes, Route } from "react-router-dom";

const HomePage = React.lazy(() => import("./pages/HomePage"));
const DashboardPage = React.lazy(() => import("./pages/DashboardPage"));

function PageFallback() {
  return <div>loading...</div>;
}

export default function App() {
  return (
    <Suspense fallback={<PageFallback />}>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/dashboard" element={<DashboardPage />} />
      </Routes>
    </Suspense>
  );
}
```

### 실무 포인트: fallback은 “전체 화면”이 아닐 수도 있다

레이아웃(헤더/사이드바)은 유지하고 본문만 로딩 상태로 전환하는 편이 읽기 경험이 안정된다.

- 상위 레이아웃은 즉시 렌더링한다.
- 본문 `Outlet` 영역만 `Suspense`로 감싼다.

---

## 3. 데이터 로딩: 화면 상태와 URL 상태를 분리한다

데이터 로딩은 라우터가 아니라 데이터 레이어의 책임인 경우가 많다. 실무에서는 React Query 같은 캐시 레이어를 두고 다음을 만든다.

- 이전 데이터 유지(keep previous data)
- 낙관적 업데이트
- 실패 시 재시도/복구

라우터 관점에서는 “로딩 중 UI가 어디까지 유지돼야 하는가”가 핵심이다.

```tsx
import { useParams } from "react-router-dom";

export default function UserProfile() {
  const { userId } = useParams();

  // userId 기반 fetch가 여기에 붙는다(React Query 등).
  // 아래는 로딩/에러 UI를 어디에 두는지의 형태만 보여준다.
  const loading = false;
  const error: Error | null = null;
  const user = { name: "kim", email: "kim@example.com" };

  if (loading) return <div>loading...</div>;
  if (error) return <div>error: {error.message}</div>;
  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}
```

---

## 4. 에러의 종류를 나누면 처리 전략이 선명해진다

에러는 크게 세 가지로 나뉜다.

- 렌더링 에러: 컴포넌트 코드 버그로 render 과정에서 터진다.
- 이벤트 에러: 클릭/submit 같은 이벤트 핸들러에서 터진다.
- 비동기 에러: `fetch`/promise 체인에서 터진다.

Error Boundary는 “렌더링 에러”만 잡는다. `fetch`의 실패는 Error Boundary가 자동으로 잡지 않는다.

---

## 5. Error Boundary를 라우트 경계에 둔다

실무에서는 “앱 전체를 하나의 ErrorBoundary로 감싼다”보다 “라우트 영역마다 경계를 둔다”가 유리하다.

- 특정 페이지에서만 터진 에러가 전체 앱을 죽이지 않는다.
- 복구(재시도, 홈으로 이동)가 페이지 단위로 가능해진다.

```tsx
import React from "react";

export class ErrorBoundary extends React.Component<
  { children: React.ReactNode; fallback?: React.ReactNode },
  { hasError: boolean; error?: Error }
> {
  state = { hasError: false, error: undefined as Error | undefined };

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback ?? <div>something went wrong</div>;
    }
    return this.props.children;
  }
}
```

---

## 6. 404와 “존재하지 않는 리소스”는 분리한다

- 404(Not Found): 라우트 자체가 없다. `path="*"`로 처리한다.
- 리소스 없음: 라우트는 맞지만 `/users/999`가 없다. API 404를 화면에서 처리해야 한다.

```tsx
import { Routes, Route, Link } from "react-router-dom";

function NotFoundPage() {
  return (
    <div>
      <h1>404</h1>
      <Link to="/">home</Link>
    </div>
  );
}

<Routes>
  <Route path="/" element={<div>home</div>} />
  <Route path="*" element={<NotFoundPage />} />
</Routes>;
```

---

## Vue Router와 비교

Vue는 `defineAsyncComponent`와 `<Suspense>` 조합이 자주 쓰이고, 에러는 전역 핸들러/컴포넌트 경계로 처리한다. React는 `React.lazy`/`Suspense`와 Error Boundary 조합이 기본이다.

| 관심사 | Vue Router 생태계 | React Router 생태계 |
| --- | --- | --- |
| 코드 로딩 | async component + `<Suspense>` | `React.lazy` + `<Suspense>` |
| 렌더 에러 | `errorCaptured`/전역 핸들러 | Error Boundary |
| 데이터 로딩 | Pinia + 요청/캐시 라이브러리 | React Query 등 + 요청/캐시 라이브러리 |

---
