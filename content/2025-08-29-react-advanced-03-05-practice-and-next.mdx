---
title: "[상태 관리 5/5] 상태 관리 - 실전 예제 & 다음 단계"
date: "2025-09-05"
description: "E-Commerce 시나리오로 상태의 경계를 설계한다"
tags: ["React", "고급", "프론트엔드"]
series: "상태 관리"
seriesOrder: 5
---

# 상태 관리 - 실전 예제 & 다음 단계

이 글은 앞선 1~4편을 “실무 화면”에 매핑한다. 목표는 하나다.

상태의 경계를 잘라서, 서버 상태와 클라이언트 상태가 서로의 문제를 떠안지 않게 만든다.

---

## 1. 실무 기준: 상태를 3종류로 분해한다

E-Commerce를 예로 들면 상태는 다음으로 갈린다.

1. 서버 상태: 상품 목록, 가격, 재고, 주문 내역  
2. 클라이언트 전역 상태: 장바구니, 인증 토큰, 전역 UI(모달/토스트)  
3. 클라이언트 로컬 상태: 입력 폼, 탭 선택, 임시 필터 UI

이 분해가 되면 라이브러리 선택은 자연스럽다.

- 서버 상태: React Query
- 전역 UI/장바구니: Zustand 또는 Redux Toolkit
- 파생/조합 상태: Jotai가 편할 때가 있다

---

## 2. 예제 설계: 상품은 React Query, 장바구니는 store

### 2-1. 상품 목록은 서버 상태다

```tsx
import { useQuery } from "@tanstack/react-query";

type Product = { id: string; name: string; price: number };

async function fetchProducts(): Promise<Product[]> {
  const res = await fetch("/api/products");
  if (!res.ok) throw new Error("failed");
  return await res.json();
}

export function ProductList() {
  const query = useQuery({ queryKey: ["products"], queryFn: fetchProducts });
  if (query.isPending) return <div>loading...</div>;
  if (query.isError) return <div>error</div>;

  return (
    <ul>
      {query.data.map((p) => (
        <li key={p.id}>
          {p.name} {p.price}
        </li>
      ))}
    </ul>
  );
}
```

상품을 store에 넣기 시작하면 가격 변경/재고 변경/새로고침/동기화 비용을 store가 떠안는다.

### 2-2. 장바구니는 클라이언트 전역 상태다

장바구니는 다음 특성이 있다.

- 사용자가 “지금 선택한 상태”가 진실이다.
- 여러 화면에서 같은 값이 필요하다.
- 새로고침 후에도 유지돼야 할 수 있다.

이런 상태는 store가 적합하다.

---

## 3. Zustand 버전: 장바구니 store

```tsx
import { create } from "zustand";
import { persist } from "zustand/middleware";

type CartItem = { id: string; name: string; price: number; quantity: number };

type CartState = {
  items: CartItem[];
  add: (item: Omit<CartItem, "quantity">) => void;
  remove: (id: string) => void;
  setQuantity: (id: string, quantity: number) => void;
  clear: () => void;
  total: () => number;
};

export const useCartStore = create<CartState>()(
  persist(
    (set, get) => ({
      items: [],
      add: (item) =>
        set((s) => {
          const found = s.items.find((x) => x.id === item.id);
          if (found) {
            return {
              items: s.items.map((x) =>
                x.id === item.id ? { ...x, quantity: x.quantity + 1 } : x
              ),
            };
          }
          return { items: [...s.items, { ...item, quantity: 1 }] };
        }),
      remove: (id) => set((s) => ({ items: s.items.filter((x) => x.id !== id) })),
      setQuantity: (id, quantity) =>
        set((s) => ({
          items: s.items.map((x) => (x.id === id ? { ...x, quantity } : x)),
        })),
      clear: () => set({ items: [] }),
      total: () => get().items.reduce((sum, x) => sum + x.price * x.quantity, 0),
    }),
    { name: "cart" }
  )
);
```

컴포넌트는 selector 기반으로 필요한 값만 구독한다.

```tsx
import { useCartStore } from "./useCartStore";

export function CartSummary() {
  const total = useCartStore((s) => s.total());
  return <div>{total}</div>;
}
```

실무에서는 `total()` 같은 계산을 selector로 읽는 순간 리렌더링 비용을 의식해야 한다. 규모가 커지면 “파생 계산을 memoized selector로 고정”하거나 Jotai 파생 atom으로 옮기는 판단이 필요해진다.

---

## 4. Redux Toolkit 버전: 장바구니 slice

Redux Toolkit은 “규칙과 디버깅”이 강점이다. 장바구니가 단순하면 Zustand로 충분하지만, 할인/쿠폰/배송 정책이 복잡해지면 Redux 쪽이 유리해진다.

```tsx
import { createSlice, PayloadAction } from "@reduxjs/toolkit";

type CartItem = { id: string; name: string; price: number; quantity: number };
type CartState = { items: CartItem[] };

const cartSlice = createSlice({
  name: "cart",
  initialState: { items: [] } as CartState,
  reducers: {
    add: (state, action: PayloadAction<Omit<CartItem, "quantity">>) => {
      const found = state.items.find((x) => x.id === action.payload.id);
      if (found) found.quantity += 1;
      else state.items.push({ ...action.payload, quantity: 1 });
    },
    remove: (state, action: PayloadAction<string>) => {
      state.items = state.items.filter((x) => x.id !== action.payload);
    },
    setQuantity: (state, action: PayloadAction<{ id: string; quantity: number }>) => {
      const found = state.items.find((x) => x.id === action.payload.id);
      if (found) found.quantity = action.payload.quantity;
    },
    clear: (state) => {
      state.items = [];
    },
  },
});

export const { add, remove, setQuantity, clear } = cartSlice.actions;
export default cartSlice.reducer;
```

합계 같은 계산은 selector로 고정한다.

```tsx
import { createSelector } from "@reduxjs/toolkit";

const selectItems = (s: any) => s.cart.items as CartItem[];
export const selectTotal = createSelector([selectItems], (items) =>
  items.reduce((sum, x) => sum + x.price * x.quantity, 0)
);
```

---

## 5. Jotai 버전: 파생 상태가 중심인 화면

Jotai는 “상태 그래프”가 핵심인 화면에서 편하다. 예를 들어 체크아웃 화면에서 다음이 있다고 가정한다.

- items
- 배송비 규칙
- 쿠폰 규칙
- 최종 결제 금액

이때 최종 금액은 파생 상태로 두는 편이 자연스럽다.

```tsx
import { atom } from "jotai";

type CartItem = { price: number; quantity: number };

export const itemsAtom = atom<CartItem[]>([]);
export const couponAtom = atom<number>(0); // 할인 금액

export const subtotalAtom = atom((get) =>
  get(itemsAtom).reduce((sum, x) => sum + x.price * x.quantity, 0)
);

export const totalAtom = atom((get) => {
  const subtotal = get(subtotalAtom);
  const coupon = get(couponAtom);
  return Math.max(0, subtotal - coupon);
});
```

---

## 다음 단계

상태 관리가 실무 레벨이 되려면 다음이 필요하다.

- React Query(서버 상태)와 전역 store(클라이언트 상태)의 경계를 팀 규칙으로 고정한다.
- 라우팅과 상태를 결합할 때 URL을 상태로 활용한다(필터/페이지네이션).
- 테스트에서 “상태 변경 규칙”을 고정한다(reducer 테스트, store 단위 테스트).

---

## Vue와 비교

Vue에서는 Pinia가 기본 선택이 되는 경우가 많고, 서버 상태는 Vue Query 또는 직접 구현으로 갈린다. React는 서버 상태(React Query)와 클라이언트 상태(전역 store)를 더 강하게 분리하는 편이 비용이 낮아진다.

| 영역 | Vue | React |
| --- | --- | --- |
| 서버 상태 | Vue Query 또는 직접 | React Query |
| 전역 UI 상태 | Pinia | Zustand/Redux/Jotai |
| 파생 상태 | computed | derived atom/selector |

---

## 체크리스트

- 서버 상태와 클라이언트 상태를 예제로 분리할 수 있다.
- 장바구니를 store에 두는 이유를 설명할 수 있다.
- 규칙이 복잡해지면 Zustand에서 Redux Toolkit으로 넘어갈 수 있는 기준을 갖는다.
