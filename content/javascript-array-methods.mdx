---
title: "자바스크립트 Array 메서드 정리"
description: "자바스크립트 배열에서 자주 사용되는 메서드들의 특징과 사용법을 정리했습니다."
date: "2021-03-17"
tags: ["JavaScript", "프론트엔드"]
---

# 자바스크립트 Array 메서드 정리

자바스크립트에서 배열을 다룰 때 자주 사용되는 메서드들을 정리했습니다. 각 메서드의 특징과 주의사항, 실제 사용 예제를 포함하고 있습니다.

## Array.prototype.sort()

**배열을 정렬하는 메서드입니다.**

### ⚠️ 중요: 원본 배열을 변경합니다

```javascript
const arr = [3, 1, 2];
arr.sort(); // arr은 [1, 2, 3]으로 변경됨
```

### 매개변수

- `compareFunction` (선택사항): 정렬 순서를 정의하는 함수

#### compareFunction이 없는 경우

요소를 **문자열로 변환**한 후 유니코드 순서로 정렬합니다.

```javascript
const numbers = [1, 30, 4, 21, 100000];
numbers.sort(); // [1, 100000, 21, 30, 4] - 문자열로 변환되어 정렬
```

#### compareFunction이 있는 경우

- 반환값이 **0보다 작으면**: a가 b보다 앞에 위치
- 반환값이 **0보다 크면**: b가 a보다 앞에 위치
- 반환값이 **0이면**: 순서 변경 없음

### 실제 사용 예제

#### 숫자 정렬 (오름차순)

```javascript
const numbers = [2, 1, 3, 10];
numbers.sort((a, b) => a - b); // [1, 2, 3, 10]
```

#### 숫자 정렬 (내림차순)

```javascript
const numbers = [2, 1, 3, 10];
numbers.sort((a, b) => b - a); // [10, 3, 2, 1]
```

#### 객체 정렬

```javascript
const products = [
  { name: "banana", price: 3000 },
  { name: "apple", price: 1000 },
  { name: "orange", price: 2000 },
];

// 가격 기준 오름차순 정렬
products.sort((a, b) => a.price - b.price);
```

## Array.prototype.every()

**배열의 모든 요소가 조건을 만족하는지 테스트합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 특징

- **빈 배열**에서 호출하면 **항상 true**를 반환
- 조건을 만족하지 않는 요소를 찾으면 **즉시 false 반환**하고 순회 중단

### 매개변수

```javascript
arr.every(callback(currentValue, index, array), thisArg);
```

### 사용 예제

```javascript
const numbers = [12, 5, 8, 130, 44];

// 모든 요소가 10보다 큰지 확인
numbers.every((num) => num > 10); // false

// 모든 요소가 1보다 큰지 확인
numbers.every((num) => num > 1); // true
```

## Array.prototype.some()

**배열의 요소 중 하나라도 조건을 만족하는지 테스트합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 특징

- **빈 배열**에서 호출하면 **항상 false**를 반환
- 조건을 만족하는 요소를 찾으면 **즉시 true 반환**하고 순회 중단

### 사용 예제

```javascript
const numbers = [1, 2, 3, 4, 5];

// 10 이상의 값이 있는지 확인
numbers.some((num) => num >= 10); // false

// 3 이상의 값이 있는지 확인
numbers.some((num) => num >= 3); // true

// 특정 값이 존재하는지 확인
numbers.some((num) => num === 3); // true
```

## Array.prototype.find()

**조건을 만족하는 첫 번째 요소의 값을 반환합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 반환값

- 조건을 만족하는 **첫 번째 요소의 값**
- 조건을 만족하는 요소가 없으면 **undefined**

### 사용 예제

```javascript
const users = [
  { name: "apple", age: 25 },
  { name: "banana", age: 30 },
  { name: "cherry", age: 28 },
];

// 이름이 "banana"인 사용자 찾기
const user = users.find((user) => user.name === "banana");
// { name: "banana", age: 30 }

// 나이가 35 이상인 사용자 찾기
const oldUser = users.find((user) => user.age >= 35);
// undefined
```

## Array.prototype.findIndex()

**조건을 만족하는 첫 번째 요소의 인덱스를 반환합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 반환값

- 조건을 만족하는 **첫 번째 요소의 인덱스**
- 조건을 만족하는 요소가 없으면 **-1**

### 사용 예제

```javascript
const numbers = [5, 12, 8, 130, 44];

// 10보다 큰 첫 번째 요소의 인덱스
const index = numbers.findIndex((num) => num > 10); // 1

// 1000보다 큰 요소의 인덱스
const notFound = numbers.findIndex((num) => num > 1000); // -1
```

## Array.prototype.includes()

**배열이 특정 요소를 포함하고 있는지 확인합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 매개변수

- `searchElement`: 탐색할 요소
- `fromIndex` (선택): 검색을 시작할 위치 (기본값: 0)

### 사용 예제

```javascript
const fruits = ["apple", "banana", "orange"];

fruits.includes("banana"); // true
fruits.includes("grape"); // false

// 특정 인덱스부터 검색
fruits.includes("apple", 1); // false (인덱스 1부터 검색)
```

## Array.prototype.filter()

**조건을 만족하는 모든 요소를 모아 새로운 배열을 반환합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 반환값

- 조건을 만족하는 요소들로 이루어진 **새로운 배열**
- 조건을 만족하는 요소가 없으면 **빈 배열**

### 사용 예제

```javascript
const numbers = [1, 4, 6, 8, 12];

// 5보다 큰 수들만 필터링
const filtered = numbers.filter((num) => num > 5); // [6, 8, 12]

// 짝수만 필터링
const evenNumbers = numbers.filter((num) => num % 2 === 0); // [4, 6, 8, 12]
```

#### 객체 배열 필터링

```javascript
const products = [
  { name: "laptop", price: 1000, available: true },
  { name: "phone", price: 500, available: false },
  { name: "tablet", price: 300, available: true },
];

// 구매 가능한 상품만 필터링
const availableProducts = products.filter((product) => product.available);

// 500 이상인 상품들
const expensiveProducts = products.filter((product) => product.price >= 500);
```

## Array.prototype.forEach()

**배열의 각 요소에 대해 함수를 실행합니다.**

### ✅ 원본 배열을 변경하지 않습니다 (단, callback이 변경할 수는 있음)

### 반환값

**undefined** (값을 반환하지 않음)

### 중요한 특징

- 예외를 던지지 않고는 중간에 멈출 수 없음
- 삭제되었거나 초기화되지 않은 인덱스는 실행하지 않음

### 사용 예제

```javascript
const fruits = ["apple", "banana", "orange"];

// 각 과일 출력
fruits.forEach((fruit) => {
  console.log(fruit);
});

// 인덱스와 함께 출력
fruits.forEach((fruit, index) => {
  console.log(`${index}: ${fruit}`);
});
```

## Array.prototype.map()

**배열의 모든 요소에 함수를 적용한 결과로 새로운 배열을 생성합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 반환값

각 요소에 callback을 적용한 결과를 모은 **새로운 배열**

### 사용 예제

```javascript
const numbers = [1, 4, 6, 8];

// 각 숫자를 2배로
const doubled = numbers.map((num) => num * 2); // [2, 8, 12, 16]

// 제곱 계산
const squared = numbers.map((num) => num ** 2); // [1, 16, 36, 64]
```

#### 객체 배열 변환

```javascript
const users = [
  { firstName: "John", lastName: "Doe" },
  { firstName: "Jane", lastName: "Smith" },
];

// 전체 이름으로 변환
const fullNames = users.map((user) => `${user.firstName} ${user.lastName}`);
// ["John Doe", "Jane Smith"]

// 새로운 객체 구조로 변환
const userSummary = users.map((user) => ({
  name: `${user.firstName} ${user.lastName}`,
  initials: `${user.firstName[0]}.${user.lastName[0]}.`,
}));
```

## Array.prototype.reduce()

**배열의 각 요소에 대해 reducer 함수를 실행하여 하나의 값으로 축약합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 매개변수

```javascript
arr.reduce(
  callback(accumulator, currentValue, currentIndex, array),
  initialValue
);
```

- `accumulator`: 누산기 (이전 callback 결과값)
- `currentValue`: 현재 처리 중인 요소
- `initialValue`: 초기값 (선택사항, 제공하지 않으면 첫 번째 요소 사용)

### 사용 예제

#### 배열 합계

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, cur) => acc + cur, 0); // 15
```

#### 객체 배열에서 값 합계

```javascript
const products = [
  { name: "laptop", price: 1000 },
  { name: "phone", price: 500 },
  { name: "tablet", price: 300 },
];

const totalPrice = products.reduce((acc, product) => acc + product.price, 0); // 1800
```

#### 배열을 객체로 변환

```javascript
const fruits = ["apple", "banana", "apple", "orange", "banana"];

// 각 과일의 개수 세기
const fruitCount = fruits.reduce((acc, fruit) => {
  acc[fruit] = (acc[fruit] || 0) + 1;
  return acc;
}, {});
// { apple: 2, banana: 2, orange: 1 }
```

#### 배열 평탄화

```javascript
const nestedArray = [
  [1, 2],
  [3, 4],
  [5, 6],
];
const flattened = nestedArray.reduce((acc, cur) => acc.concat(cur), []);
// [1, 2, 3, 4, 5, 6]
```

## Array.prototype.flat()

**중첩된 배열을 평탄화합니다.**

### ✅ 원본 배열을 변경하지 않습니다

### 매개변수

- `depth` (선택): 평탄화할 깊이 (기본값: 1)

### 사용 예제

```javascript
const arr1 = [1, 2, [3, 4]];
arr1.flat(); // [1, 2, 3, 4]

const arr2 = [1, 2, [3, 4, [5, 6]]];
arr2.flat(); // [1, 2, 3, 4, [5, 6]]
arr2.flat(2); // [1, 2, 3, 4, 5, 6]

// 모든 깊이 평탄화
const deepArray = [1, [2, [3, [4, [5]]]]];
deepArray.flat(Infinity); // [1, 2, 3, 4, 5]
```

## Array.prototype.splice() vs Array.prototype.slice()

### splice() - 원본 배열 변경 ⚠️

**배열의 기존 요소를 삭제하거나 교체하고 새 요소를 추가합니다.**

```javascript
const arr = [1, 2, 3, 4, 5];
arr.splice(2, 1, "new"); // [3] (제거된 요소 반환)
console.log(arr); // [1, 2, 'new', 4, 5] (원본 변경됨)
```

### slice() - 원본 배열 유지 ✅

**배열의 일부를 얕은 복사하여 새로운 배열을 반환합니다.**

```javascript
const arr = [1, 2, 3, 4, 5];
const newArr = arr.slice(1, 4); // [2, 3, 4]
console.log(arr); // [1, 2, 3, 4, 5] (원본 그대로)
```

## 🔧 수정된 내용

1. **BR 태그 제거**: 모든 `<br/>` 태그를 제거하고 마크다운 문법으로 대체
2. **잘못된 타이핑 수정**: "인데긋" → "인덱스"
3. **내용 구조화**: 섹션별로 명확하게 구분하고 일관성 있는 형식으로 정리
4. **실용적인 예제 추가**: 실제 개발에서 자주 사용되는 패턴들로 예제 개선
5. **주의사항 명확화**: 원본 배열 변경 여부를 시각적으로 표시
6. **현대적인 문법 적용**: ES6+ 문법으로 예제 업데이트
7. **splice vs slice 비교 추가**: 헷갈리기 쉬운 두 메서드 비교 설명

이제 훨씬 읽기 쉽고 실용적인 자바스크립트 배열 메서드 가이드가 되었습니다!
