---
title: "[React Query 3/8] React Query - 뮤테이션"
date: "2025-08-26"
description: "useMutation, 낙관적 업데이트, 에러 처리"
tags: ["React", "고급", "프론트엔드"]
series: "React Query"
seriesOrder: 3
---

# React Query 가이드 - 뮤테이션

> TanStack Query v5를 기반으로 한 데이터 페칭 학습 자료  
> 출처: [TanStack Query Documentation](https://tanstack.com/query/)

---

## 뮤테이션

뮤테이션은 “서버 데이터를 변경하는 작업”을 표현한다. 실무에서 뮤테이션은 다음 문제를 함께 푼다.

- 중복 제출 방지(두 번 클릭)
- 성공/실패 UI 처리
- 성공 후 캐시 동기화(목록/상세 최신화)
- 실패 시 롤백(낙관적 업데이트)

쿼리가 “읽기”라면 뮤테이션은 “쓰기”다. 그래서 캐시 정책과 흐름이 다르다.

---

## 1. `useMutation`의 최소 형태

```tsx
import { useMutation } from "@tanstack/react-query";

type CreateUserInput = { name: string; email: string };

async function createUser(input: CreateUserInput) {
  const res = await fetch("/api/users", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(input),
  });
  if (!res.ok) throw new Error("failed");
  return await res.json();
}

export function CreateUserForm() {
  const mutation = useMutation({ mutationFn: createUser });

  function onSubmit(e: React.FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const fd = new FormData(e.currentTarget);
    mutation.mutate({
      name: String(fd.get("name") ?? ""),
      email: String(fd.get("email") ?? ""),
    });
  }

  return (
    <form onSubmit={onSubmit}>
      <input name="name" />
      <input name="email" />
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? "saving..." : "create"}
      </button>
      {mutation.isError && <div>error</div>}
      {mutation.isSuccess && <div>done</div>}
    </form>
  );
}
```

`mutationFn`은 “변경 요청”을 수행한다. 성공하면 데이터를 반환하고, 실패하면 throw한다.

---

## 2. 성공 후 캐시 동기화: invalidate vs 직접 업데이트

뮤테이션이 성공하면 화면은 보통 두 가지 중 하나를 해야 한다.

- 목록을 다시 가져온다(invalidate)
- 캐시를 직접 수정한다(setQueryData)

둘의 선택 기준은 다음이다.

- invalidate: 단순하고 안전하지만 네트워크 요청이 늘 수 있다.
- setQueryData: 빠르고 UX가 좋지만 캐시 정합성 책임이 커진다.

### invalidateQueries

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

const queryKeyUsers = ["users"];

function CreateUser() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: createUser,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: queryKeyUsers });
    },
  });

  return <button onClick={() => mutation.mutate({ name: "a", email: "a@a.com" })}>create</button>;
}
```

### setQueryData(캐시 직접 업데이트)

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

function CreateUser() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: createUser,
    onSuccess: (newUser) => {
      queryClient.setQueryData(["users"], (old: any[] | undefined) => {
        const prev = old ?? [];
        return [...prev, newUser];
      });
    },
  });

  return <button onClick={() => mutation.mutate({ name: "a", email: "a@a.com" })}>create</button>;
}
```

실무에서는 “서버가 반환한 최종 결과”를 기준으로 캐시를 업데이트해야 한다. 입력값을 그대로 넣으면 서버에서 보정된 값(id, createdAt 등)이 누락된다.

---

## 3. 에러 처리 전략: 어디에 무엇을 보여줄지 결정한다

뮤테이션 에러는 크게 두 종류로 나뉜다.

- 사용자 입력 오류(검증): 폼 필드 근처에서 보여준다.
- 시스템 오류(네트워크/서버): 토스트/에러 영역 등 전역 UX로 처리한다.

이를 구분하지 않으면 사용자는 “내가 뭘 잘못했는지”를 알 수 없다.

---

## 4. 실무 패턴: 삭제 후 목록/상세 동기화

삭제는 “목록에서도 사라져야 하고 상세도 접근 불가”가 된다.

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

async function deletePost(id: string) {
  const res = await fetch(`/api/posts/${id}`, { method: "DELETE" });
  if (!res.ok) throw new Error("failed");
}

export function DeletePostButton({ postId }: { postId: string }) {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: deletePost,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["posts"] });
      queryClient.removeQueries({ queryKey: ["post", postId] });
    },
  });

  return (
    <button onClick={() => mutation.mutate(postId)} disabled={mutation.isPending}>
      {mutation.isPending ? "deleting..." : "delete"}
    </button>
  );
}
```

`removeQueries`는 “이 캐시는 이제 무의미하다”를 명시한다. 상세 페이지에서 뒤로가기를 할 때 오래된 캐시가 깜빡이며 보이는 문제를 줄일 수 있다.

---

## 5. 자주 터지는 함정

### 1) 성공 시 invalidate를 안 한다

서버는 바뀌었는데 화면은 바뀌지 않는다. 이때 사용자는 “저장이 안 됐다”로 인지한다.

### 2) 무효화 범위를 과하게 잡는다

`invalidateQueries()`를 무조건 호출하면 모든 쿼리가 리페치되어 성능이 무너진다. queryKey 설계를 먼저 잡고, 필요한 범위만 무효화한다.

### 3) 뮤테이션을 재시도(retry)한다

쓰기 요청은 “중복 생성” 같은 부작용이 있다. 재시도는 멱등성이 보장되는 경우에만 팀 규칙으로 허용한다.

---

## Vue와 비교

Vue에서도 `@tanstack/vue-query`의 `useMutation`으로 동일한 모델을 쓴다. Pinia action으로 뮤테이션을 처리할 수도 있지만, 성공 후 캐시/동기화를 직접 설계해야 한다.

| 관심사 | Vue Query | React Query |
| --- | --- | --- |
| 쓰기 요청 | `useMutation` | `useMutation` |
| 성공 후 동기화 | `invalidateQueries`/cache update | `invalidateQueries`/cache update |
| 낙관적 업데이트 | `onMutate` + rollback | `onMutate` + rollback |

---

## 체크리스트

- 뮤테이션 성공 후 화면이 최신화되어야 하는 이유를 설명할 수 있다.
- invalidate와 setQueryData의 선택 기준을 설명할 수 있다.
- 뮤테이션 에러를 검증 오류와 시스템 오류로 분리해 UX를 설계할 수 있다.

---
