---
title: "[React 기초 4-5/9] 반응형 Effect의 생명주기"
date: "2025-08-05"
description: "Effect의 생명주기와 의존성 배열의 중요성을 이해한다"
tags: ["React", "학습", "Effect", "생명주기"]
series: "React 기초"
seriesOrder: 31
---

# 반응형 Effect의 생명주기

Effect의 생명주기를 올바르게 이해하면 많은 버그를 피할 수 있다.

## Effect의 생명주기는 컴포넌트와 다르다

많은 사람들이 Effect의 생명주기를 컴포넌트의 생명주기와 같다고 생각한다. 하지만 이는 잘못된 생각이다.

**컴포넌트의 생명주기:**

- 마운트 (Mount): 컴포넌트가 화면에 추가됨
- 업데이트 (Update): 컴포넌트가 새 props나 state를 받음
- 언마운트 (Unmount): 컴포넌트가 화면에서 제거됨

**Effect의 생명주기:**

- 동기화 시작 (Start synchronizing): Effect가 실행됨
- 동기화 중지 (Stop synchronizing): 클린업 함수가 실행됨

**핵심 차이:**

컴포넌트는 "마운트 → 업데이트 → 언마운트"라는 순차적 생명주기를 가진다. 하지만 Effect는 "동기화 시작 → 중지 → 시작 → 중지..."를 반복할 수 있다.

### 왜 이렇게 다를까?

컴포넌트는 UI 요소라서 생성되고 업데이트되고 파괴된다. 하지만 Effect는 "동기화 프로세스"다. 외부 시스템과 동기화를 시작하고 중지하는 것을 반복한다.

## 예제: 채팅방 생명주기

구체적인 예제로 Effect의 생명주기를 살펴본다.

```jsx
const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();

    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to {roomId}!</h1>;
}
```

### 시나리오 1: 컴포넌트 마운트

**1. `roomId = "general"`로 마운트**

- 렌더링: JSX 생성
- 커밋: DOM에 추가
- Effect 실행: `general` 방에 연결

컴포넌트 입장: "마운트되었다"
Effect 입장: "동기화를 시작했다"

### 시나리오 2: Props 변경

**2. `roomId`가 "travel"로 변경**

- 렌더링: 새 JSX 생성
- 커밋: DOM 업데이트
- Effect 클린업: `general` 방 연결 해제
- Effect 실행: `travel` 방에 연결

컴포넌트 입장: "업데이트되었다"
Effect 입장: "동기화를 중지하고 다시 시작했다"

### 시나리오 3: 컴포넌트 언마운트

**3. 컴포넌트 언마운트**

- Effect 클린업: `travel` 방 연결 해제
- DOM에서 제거

컴포넌트 입장: "언마운트되었다"
Effect 입장: "동기화를 중지했다"

## 의존성 배열의 중요성

Effect가 사용하는 모든 **반응형 값**을 의존성 배열에 포함해야 한다.

### 의존성을 빠뜨리면?

```jsx
// 잘못된 코드: roomId가 의존성에 없음
function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // roomId가 변경되어도 재실행되지 않음

  return <h1>Welcome to {roomId}!</h1>;
}
```

**문제:**

1. `roomId = "general"`로 마운트 → `general` 방에 연결
2. `roomId = "travel"`로 변경 → 여전히 `general` 방에 연결됨
3. 화면에는 "Welcome to travel!"이 표시되지만, 실제로는 `general` 방에 있음

**오류 메시지:**

```
React Hook useEffect has a missing dependency: 'roomId'
```

React는 이런 버그를 방지하기 위해 경고를 표시한다.

### 올바른 코드

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // roomId를 의존성에 포함

  return <h1>Welcome to {roomId}!</h1>;
}
```

이제 `roomId`가 변경되면:

1. 클린업: 이전 방 연결 해제
2. Effect: 새 방에 연결

## 각 Effect는 독립적인 동기화 프로세스

관련 없는 로직은 별도의 Effect로 분리해야 한다.

### 나쁜 예: 관련 없는 로직을 하나의 Effect에

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    // 로직 1: 방문 기록
    logVisit(roomId);

    // 로직 2: 채팅 연결
    const connection = createConnection(serverUrl, roomId);
    connection.connect();

    return () => {
      connection.disconnect();
    };
  }, [roomId]);

  return <h1>Welcome!</h1>;
}
```

**문제:**

- 방문 기록은 한 번만 실행되어야 한다 (마운트 시)
- 채팅 연결은 `roomId`가 변경될 때마다 재연결되어야 한다
- 하지만 하나의 Effect에 있어서 둘 다 `roomId` 변경 시 실행된다

### 좋은 예: 각 동기화 프로세스를 별도 Effect로

```jsx
function ChatRoom({ roomId }) {
  // Effect 1: 방문 기록 (한 번만)
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  // Effect 2: 채팅 연결 (roomId 변경 시마다)
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome!</h1>;
}
```

각 Effect는 독립적인 동기화 프로세스를 나타낸다. 하나의 Effect는 하나의 목적만 가져야 한다.

## Effect는 반응형 값에 "반응"한다

Effect는 props, state 등 반응형 값이 변경될 때마다 재실행된다.

```jsx
function ChatRoom({ roomId, serverUrl }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // 둘 중 하나라도 변경되면 재실행

  return <h1>Welcome!</h1>;
}
```

### 반응형 값이란?

**반응형 값:**

- Props
- State (useState, useReducer로 선언된 값)
- 컴포넌트 본문에 직접 선언된 변수와 함수

**비반응형 값:**

- 컴포넌트 외부의 값 (파일 최상단에 선언된 상수 등)
- `ref.current` (의도적으로 변경 가능하게 만든 값)

```jsx
// 비반응형 (컴포넌트 외부)
const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  // 반응형 (props)
  // roomId

  // 반응형 (state)
  const [message, setMessage] = useState("");

  // 반응형 (컴포넌트 본문의 변수)
  const options = { serverUrl, roomId };

  // 비반응형 (ref)
  const connectionRef = useRef(null);

  useEffect(() => {
    // roomId와 options는 의존성에 포함해야 함
    // serverUrl은 외부 값이므로 의존성에 불필요 (하지만 넣어도 됨)
    // connectionRef.current는 의존성에 불필요
  }, [roomId, options]);
}
```

## 빈 의존성 배열 []

빈 배열은 "마운트 시에만 실행"을 의미한다.

```jsx
useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => connection.disconnect();
}, []); // 마운트 시에만 실행, 언마운트 시에만 클린업
```

**의미:**

- 컴포넌트가 마운트될 때 Effect 실행
- 컴포넌트가 언마운트될 때 클린업 실행
- 컴포넌트가 업데이트되어도 Effect는 재실행되지 않음

**주의사항:**

반응형 값을 사용하는데 의존성에 없으면 버그가 발생한다.

```jsx
// 잘못된 코드
function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // roomId를 사용하는데 의존성에 없음
}
```

이 코드는:

- 첫 마운트 시 초기 `roomId`로 연결
- `roomId`가 변경되어도 재연결하지 않음
- 화면과 실제 연결 상태가 불일치

## 실전 패턴: 조건부 Effect

때로는 특정 조건에서만 동기화하고 싶을 때가 있다.

```jsx
function ChatRoom({ roomId, isOpen }) {
  useEffect(() => {
    if (!isOpen) {
      return; // 동기화하지 않음
    }

    const connection = createConnection(serverUrl, roomId);
    connection.connect();

    return () => connection.disconnect();
  }, [roomId, isOpen]);

  return <h1>{isOpen ? "Chat open" : "Chat closed"}</h1>;
}
```

**동작:**

- `isOpen = false`: Effect가 실행되지만 즉시 반환 (아무것도 하지 않음)
- `isOpen = true`: 연결 시작
- `isOpen = false`로 변경: 클린업 실행 (연결 해제)

## 정리

- Effect의 생명주기는 컴포넌트와 다르다
- Effect는 "동기화 시작/중지"를 반복한다
- 모든 반응형 값을 의존성 배열에 포함해야 한다
- 각 Effect는 독립적인 동기화 프로세스를 나타내야 한다
- 빈 의존성 배열은 "마운트 시에만 실행"을 의미한다
- 반응형 값을 사용하는데 의존성에 없으면 버그가 발생한다
