---
title: "[상태 관리 2/5] 상태 관리 - Redux Toolkit"
date: "2025-09-02"
description: "Redux Toolkit의 단방향 데이터 흐름과 실무 설계 기준"
tags: ["React", "고급", "프론트엔드"]
series: "상태 관리"
seriesOrder: 2
---

# 상태 관리 - Redux Toolkit

Redux Toolkit(RTK)은 Redux를 실무에서 쓰기 위한 공식 권장 방식이다. 핵심은 “예측 가능한 상태 변경”과 “디버깅 가능성”이다.

Zustand가 “가볍게 전역 상태를 공유한다”에 강하면, Redux Toolkit은 “규칙과 구조로 대규모 상태를 운영한다”에 강하다.

---

## 1. Redux가 풀려는 문제

상태가 커지면 다음 문제가 같이 커진다.

- 누가 언제 상태를 바꿨는지 추적하기 어렵다.
- 변경이 퍼져서 버그가 재현되지 않는다.
- 비즈니스 로직이 UI 컴포넌트에 섞인다.
- 리팩터링할수록 회귀가 늘어난다.

Redux는 “상태 변경을 이벤트(action)로 기록하고, reducer로만 변경한다”는 규칙으로 이 문제를 푼다.

---

## 2. 단방향 데이터 흐름(Flux)의 핵심

Redux의 흐름은 다음이다.

1. UI가 action을 dispatch한다.
2. reducer가 action과 이전 state로 다음 state를 만든다.
3. store가 변경을 통지하고, selector를 사용하는 UI가 리렌더링된다.

중요한 점은 “상태 변경의 출입구가 하나”라는 사실이다. 그래서 DevTools로 타임 트래블이 가능해진다.

---

## 3. 최소 예제: slice 하나로 시작한다

RTK의 기본 단위는 slice다.

```tsx
import { configureStore, createSlice, PayloadAction } from "@reduxjs/toolkit";

type CounterState = { value: number };

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 } as CounterState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    addBy: (state, action: PayloadAction<number>) => {
      state.value += action.payload;
    },
  },
});

export const { increment, decrement, addBy } = counterSlice.actions;

export const store = configureStore({
  reducer: { counter: counterSlice.reducer },
});
```

`state.value += 1` 같은 직접 수정이 가능한 이유는 Immer가 내부에서 불변성을 유지해주기 때문이다.

---

## 4. React에서 연결: Provider + typed hooks

```tsx
import { Provider, useDispatch, useSelector } from "react-redux";
import type { TypedUseSelectorHook } from "react-redux";

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;

export function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

function Counter() {
  const value = useAppSelector((s) => s.counter.value);
  const dispatch = useAppDispatch();

  return (
    <div>
      <div>{value}</div>
      <button onClick={() => dispatch(increment())}>+</button>
      <button onClick={() => dispatch(decrement())}>-</button>
    </div>
  );
}
```

이 패턴은 타입이 커질수록 중요해진다. `dispatch`와 `selector`의 타입이 고정되면 실수 비용이 줄어든다.

---

## 5. 실무에서 제일 중요한 것은 상태의 경계다

Redux store에 무엇을 넣을지 먼저 결정해야 한다.

- Redux에 넣기 좋은 상태: UI 전역 흐름, 복잡한 비즈니스 상태, 오프라인/임시 편집 데이터, 여러 화면을 가로지르는 마법 같은 규칙
- Redux에 넣기 나쁜 상태: 서버가 진실인 데이터(목록/상세/검색 결과). 이건 React Query가 더 적합하다.

서버 상태를 Redux에 넣으면 “캐시 키, 무효화, 재시도, 경쟁 상태”를 Redux 레벨에서 구현해야 한다. 비용이 크다.

---

## 6. 비동기: createAsyncThunk를 어디까지 쓸 것인가

createAsyncThunk는 “서버 요청 → 상태 업데이트”를 Redux 안으로 가져오는 도구다.

```tsx
import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";

export const fetchUsers = createAsyncThunk("users/fetch", async () => {
  const res = await fetch("/api/users");
  if (!res.ok) throw new Error("failed");
  return (await res.json()) as Array<{ id: string; name: string }>;
});

const usersSlice = createSlice({
  name: "users",
  initialState: { list: [] as any[], loading: false, error: null as string | null },
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.list = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.error.message ?? "failed";
      });
  },
});
```

실무에서는 “서버 상태는 React Query” 기준을 잡았다면 thunk 사용 범위가 좁아진다. thunk는 보통 다음에 남는다.

- 여러 API를 묶어 하나의 트랜잭션처럼 처리해야 한다.
- 서버 응답을 단순 캐시가 아니라 “복잡한 도메인 상태 머신”으로 합성해야 한다.

---

## 7. 성능: selector와 정규화가 핵심이다

Redux 성능의 핵심은 다음이다.

- selector가 잘못되면 리렌더링이 폭발한다.
- 배열/객체를 그대로 돌려주는 selector는 메모이제이션이 필요하다.
- 리스트가 크면 정규화(normalization)와 `createEntityAdapter`가 도움이 된다.

```tsx
import { createSelector } from "@reduxjs/toolkit";

const selectCartItems = (s: RootState) => s.cart.items;
export const selectCartTotal = createSelector([selectCartItems], (items) =>
  items.reduce((sum, item) => sum + item.price * item.quantity, 0)
);
```

---

## Vue와 비교

Vue에서는 Pinia가 기본 선택지에 가깝고, Vuex는 레거시로 보는 팀이 많다. Redux Toolkit의 핵심은 “action 로그 기반 디버깅”과 “규칙 기반 구조”다.

| 관점 | Pinia | Redux Toolkit |
| --- | --- | --- |
| 변경 모델 | store 메서드 | action + reducer |
| 디버깅 | DevTools 기반 | DevTools + 타임 트래블이 강함 |
| 구조 강제 | 낮음 | 높음 |
| 대규모 팀 | 규칙을 팀이 만든다 | 프레임이 기본 제공된다 |

---

## 체크리스트

- action과 reducer가 왜 필요한지 설명할 수 있다.
- Redux에 넣을 상태와 React Query에 둘 상태를 구분할 수 있다.
- selector가 성능의 중심이라는 점을 이해한다.
