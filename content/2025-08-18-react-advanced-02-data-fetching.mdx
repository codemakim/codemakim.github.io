---
title: "ğŸš€ [React ë¼ì´ë¸ŒëŸ¬ë¦¬ 2/4] React Query - ìºì‹± ë©”ì»¤ë‹ˆì¦˜"
date: "2025-08-18"
description: "React Queryì˜ ìºì‹± ì›ë¦¬, Stale/Cache Time, ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¥¼ ê¹Šì´ ìˆê²Œ í•™ìŠµí•©ë‹ˆë‹¤"
tags: ["React", "ê³ ê¸‰", "í”„ë¡ íŠ¸ì—”ë“œ"]
series: "React ë¼ì´ë¸ŒëŸ¬ë¦¬"
seriesOrder: 2
---

# React Query (TanStack Query) ê°€ì´ë“œ

> TanStack Query v5ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ë°ì´í„° í˜ì¹­ í•™ìŠµ ìë£Œ  
> ì¶œì²˜: [TanStack Query Documentation](https://tanstack.com/query/)

---

## ğŸ“š ëª©ì°¨

1. [ê°œìš”](#ê°œìš”)
2. [ì„¤ì¹˜ ë° ì„¤ì •](#ì„¤ì¹˜-ë°-ì„¤ì •)
3. [ì¿¼ë¦¬ ê¸°ì´ˆ](#ì¿¼ë¦¬-ê¸°ì´ˆ)
4. [ë®¤í…Œì´ì…˜](#ë®¤í…Œì´ì…˜)
5. [ìºì‹± ì „ëµ](#ìºì‹±-ì „ëµ)
6. [ë‚™ê´€ì  ì—…ë°ì´íŠ¸](#ë‚™ê´€ì -ì—…ë°ì´íŠ¸)
7. [ë¬´í•œ ìŠ¤í¬ë¡¤](#ë¬´í•œ-ìŠ¤í¬ë¡¤)
8. [ê³ ê¸‰ íŒ¨í„´](#ê³ ê¸‰-íŒ¨í„´)

---

## ê°œìš”

### React Queryë€?

**React Query (TanStack Query)**ëŠ” ì„œë²„ ìƒíƒœ ê´€ë¦¬ë¥¼ ìœ„í•œ ê°•ë ¥í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ì…ë‹ˆë‹¤.

**ì£¼ìš” ê¸°ëŠ¥:**

- ìë™ ìºì‹±
- ë°±ê·¸ë¼ìš´ë“œ ë¦¬í˜ì¹­
- ì¤‘ë³µ ìš”ì²­ ì œê±°
- ë‚™ê´€ì  ì—…ë°ì´íŠ¸
- ë¬´í•œ ìŠ¤í¬ë¡¤
- ì„œë²„ ìƒíƒœì™€ í´ë¼ì´ì–¸íŠ¸ ìƒíƒœ ë¶„ë¦¬

### ì™œ React Queryì¸ê°€?

```jsx
// âŒ ì¼ë°˜ì ì¸ ë°©ë²• (ë³µì¡í•¨)
function Users() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <UserList users={users} />;
}

// âœ… React Query (ê°„ê²°í•¨)
import { useQuery } from '@tanstack/react-query';

function Users() {
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <UserList users={users} />;
}
```

### Vueì™€ ë¹„êµ

```html
<!-- Vue: VueQuery ë˜ëŠ” Pinia -->
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { data: users, isLoading, error } = useQuery({
  queryKey: ['users'],
  queryFn: () => fetch('/api/users').then(res => res.json())
})
</script>
```

---

## ì„¤ì¹˜ ë° ì„¤ì •

### ì„¤ì¹˜

```bash
npm install @tanstack/react-query
npm install @tanstack/react-query-devtools
```

### ê¸°ë³¸ ì„¤ì •

```jsx
// App.jsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,  // 5ë¶„
      cacheTime: 1000 * 60 * 10, // 10ë¶„
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
});

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

### QueryClient ì˜µì…˜

```javascript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5,        // ë°ì´í„°ê°€ staleë˜ê¸°ê¹Œì§€ ì‹œê°„
      cacheTime: 1000 * 60 * 10,       // ìºì‹œ ìœ ì§€ ì‹œê°„
      retry: 3,                         // ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ íšŸìˆ˜
      retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
      refetchOnWindowFocus: true,      // ìœˆë„ìš° í¬ì»¤ìŠ¤ ì‹œ ë¦¬í˜ì¹˜
      refetchOnReconnect: true,        // ë„¤íŠ¸ì›Œí¬ ì¬ì—°ê²° ì‹œ ë¦¬í˜ì¹˜
      refetchOnMount: true,            // ë§ˆìš´íŠ¸ ì‹œ ë¦¬í˜ì¹˜
    },
    mutations: {
      retry: 0,                        // ë®¤í…Œì´ì…˜ì€ ì¬ì‹œë„ ì•ˆí•¨
    },
  },
});
```

---

## ì¿¼ë¦¬ ê¸°ì´ˆ

### 1. useQuery ê¸°ë³¸

```jsx
import { useQuery } from '@tanstack/react-query';

function Users() {
  const { data, isLoading, error, isError } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
  });

  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error: {error.message}</div>;

  return (
    <ul>
      {data.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

async function fetchUsers() {
  const response = await fetch('/api/users');
  if (!response.ok) {
    throw new Error('Failed to fetch users');
  }
  return response.json();
}
```

### 2. Query Key

**Query KeyëŠ” ì¿¼ë¦¬ë¥¼ ê³ ìœ í•˜ê²Œ ì‹ë³„í•©ë‹ˆë‹¤.**

```jsx
// ë‹¨ìˆœ í‚¤
useQuery({ queryKey: ['users'], queryFn: fetchUsers });

// íŒŒë¼ë¯¸í„°ê°€ ìˆëŠ” í‚¤
useQuery({ 
  queryKey: ['user', userId], 
  queryFn: () => fetchUser(userId) 
});

// ë³µì¡í•œ í‚¤
useQuery({ 
  queryKey: ['users', { status: 'active', page: 1 }],
  queryFn: () => fetchUsers({ status: 'active', page: 1 })
});
```

### 3. Query Function

```jsx
// ê¸°ë³¸
const query = useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
});

// í™”ì‚´í‘œ í•¨ìˆ˜
const query = useQuery({
  queryKey: ['users'],
  queryFn: () => fetch('/api/users').then(res => res.json()),
});

// async/await
const query = useQuery({
  queryKey: ['users'],
  queryFn: async () => {
    const response = await fetch('/api/users');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  },
});

// QueryKeyì—ì„œ ê°’ ì¶”ì¶œ
const query = useQuery({
  queryKey: ['user', userId],
  queryFn: ({ queryKey }) => {
    const [_key, userId] = queryKey;
    return fetchUser(userId);
  },
});
```

### 4. ìƒíƒœ ê´€ë¦¬

```jsx
function UserProfile({ userId }) {
  const { 
    data,           // ì¿¼ë¦¬ ë°ì´í„°
    error,          // ì—ëŸ¬ ê°ì²´
    isLoading,      // ì´ˆê¸° ë¡œë”© (ë°ì´í„° ì—†ìŒ + ë¡œë”© ì¤‘)
    isFetching,     // ë°±ê·¸ë¼ìš´ë“œ í˜ì¹­ ì¤‘
    isError,        // ì—ëŸ¬ ë°œìƒ
    isSuccess,      // ì„±ê³µ
    status,         // 'pending' | 'error' | 'success'
    fetchStatus,    // 'fetching' | 'paused' | 'idle'
  } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
  });

  // isLoading: ì²˜ìŒ ë¡œë”© ì¤‘ (ë°ì´í„° ì—†ìŒ)
  if (isLoading) return <Spinner />;

  // isError: ì—ëŸ¬ ë°œìƒ
  if (isError) return <ErrorMessage error={error} />;

  // isSuccess: ë°ì´í„° ë¡œë“œ ì™„ë£Œ
  return (
    <div>
      {/* isFetching: ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¦¬í˜ì¹­ ì¤‘ */}
      {isFetching && <RefreshingIndicator />}
      <h1>{data.name}</h1>
      <p>{data.email}</p>
    </div>
  );
}
```

### 5. ì˜ì¡´ì  ì¿¼ë¦¬

```jsx
function UserPosts({ userId }) {
  // ë¨¼ì € ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
  });

  // userê°€ ìˆì„ ë•Œë§Œ í¬ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
  const { data: posts } = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: () => fetchPosts(user.id),
    enabled: !!user,  // userê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰
  });

  return (
    <div>
      <h1>{user?.name}'s Posts</h1>
      {posts?.map(post => (
        <Post key={post.id} {...post} />
      ))}
    </div>
  );
}
```

### 6. ë³‘ë ¬ ì¿¼ë¦¬

```jsx
function Dashboard() {
  const users = useQuery({ 
    queryKey: ['users'], 
    queryFn: fetchUsers 
  });
  
  const posts = useQuery({ 
    queryKey: ['posts'], 
    queryFn: fetchPosts 
  });
  
  const comments = useQuery({ 
    queryKey: ['comments'], 
    queryFn: fetchComments 
  });

  // ëª¨ë“  ì¿¼ë¦¬ê°€ ë¡œë”© ì¤‘ì¸ì§€ í™•ì¸
  if (users.isLoading || posts.isLoading || comments.isLoading) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <Users data={users.data} />
      <Posts data={posts.data} />
      <Comments data={comments.data} />
    </div>
  );
}
```

**useQueriesë¡œ ë™ì  ë³‘ë ¬ ì¿¼ë¦¬:**

```jsx
function UserProfiles({ userIds }) {
  const userQueries = useQueries({
    queries: userIds.map(id => ({
      queryKey: ['user', id],
      queryFn: () => fetchUser(id),
    })),
  });

  const isLoading = userQueries.some(query => query.isLoading);
  const isError = userQueries.some(query => query.isError);

  if (isLoading) return <div>Loading...</div>;
  if (isError) return <div>Error loading users</div>;

  return (
    <div>
      {userQueries.map((query, index) => (
        <UserCard key={userIds[index]} user={query.data} />
      ))}
    </div>
  );
}
```

---

## ë®¤í…Œì´ì…˜

### 1. useMutation ê¸°ë³¸

```jsx
import { useMutation, useQueryClient } from '@tanstack/react-query';

function CreateUser() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: (newUser) => {
      return fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newUser),
      }).then(res => res.json());
    },
    onSuccess: () => {
      // ì¿¼ë¦¬ ë¬´íš¨í™” (ë¦¬í˜ì¹˜ íŠ¸ë¦¬ê±°)
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
  });

  function handleSubmit(e) {
    e.preventDefault();
    const formData = new FormData(e.target);
    mutation.mutate({
      name: formData.get('name'),
      email: formData.get('email'),
    });
  }

  return (
    <form onSubmit={handleSubmit}>
      <input name="name" placeholder="Name" />
      <input name="email" placeholder="Email" />
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Creating...' : 'Create User'}
      </button>
      {mutation.isError && <div>Error: {mutation.error.message}</div>}
      {mutation.isSuccess && <div>User created!</div>}
    </form>
  );
}
```

### 2. ë®¤í…Œì´ì…˜ ìƒíƒœ

```jsx
function DeleteUser({ userId }) {
  const mutation = useMutation({
    mutationFn: (id) => fetch(`/api/users/${id}`, { method: 'DELETE' }),
  });

  const {
    mutate,         // ë®¤í…Œì´ì…˜ ì‹¤í–‰ í•¨ìˆ˜
    isPending,      // ì§„í–‰ ì¤‘
    isError,        // ì—ëŸ¬ ë°œìƒ
    isSuccess,      // ì„±ê³µ
    error,          // ì—ëŸ¬ ê°ì²´
    data,           // ì‘ë‹µ ë°ì´í„°
    reset,          // ìƒíƒœ ì´ˆê¸°í™”
  } = mutation;

  return (
    <div>
      <button onClick={() => mutate(userId)} disabled={isPending}>
        {isPending ? 'Deleting...' : 'Delete'}
      </button>
      
      {isError && <div>Error: {error.message}</div>}
      {isSuccess && <div>User deleted successfully!</div>}
      
      {(isError || isSuccess) && (
        <button onClick={reset}>Reset</button>
      )}
    </div>
  );
}
```

### 3. ë®¤í…Œì´ì…˜ ì½œë°±

```jsx
const mutation = useMutation({
  mutationFn: createUser,
  onMutate: async (newUser) => {
    // ë®¤í…Œì´ì…˜ ì‹œì‘ ì „
    console.log('Creating user:', newUser);
    
    // ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì´ì „ ë°ì´í„° ë°˜í™˜
    const previousUsers = queryClient.getQueryData(['users']);
    return { previousUsers };
  },
  onError: (error, variables, context) => {
    // ì—ëŸ¬ ë°œìƒ ì‹œ
    console.error('Error creating user:', error);
    
    // ë¡¤ë°±
    if (context?.previousUsers) {
      queryClient.setQueryData(['users'], context.previousUsers);
    }
  },
  onSuccess: (data, variables, context) => {
    // ì„±ê³µ ì‹œ
    console.log('User created:', data);
    toast.success('User created successfully!');
  },
  onSettled: (data, error, variables, context) => {
    // ì„±ê³µì´ë“  ì‹¤íŒ¨ë“  ì™„ë£Œ í›„
    queryClient.invalidateQueries({ queryKey: ['users'] });
  },
});
```

### 4. ì¿¼ë¦¬ ë¬´íš¨í™”

```jsx
const queryClient = useQueryClient();

// íŠ¹ì • ì¿¼ë¦¬ ë¬´íš¨í™”
queryClient.invalidateQueries({ queryKey: ['users'] });

// íŠ¹ì • ì‚¬ìš©ì ì¿¼ë¦¬ ë¬´íš¨í™”
queryClient.invalidateQueries({ queryKey: ['user', userId] });

// ì ‘ë‘ì‚¬ë¡œ ë¬´íš¨í™” (ëª¨ë“  user ê´€ë ¨ ì¿¼ë¦¬)
queryClient.invalidateQueries({ queryKey: ['user'] });

// ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ì¿¼ë¦¬ë§Œ ë¬´íš¨í™”
queryClient.invalidateQueries({ 
  queryKey: ['users'], 
  exact: true 
});
```

### 5. ìºì‹œ ì§ì ‘ ì—…ë°ì´íŠ¸

```jsx
const mutation = useMutation({
  mutationFn: createUser,
  onSuccess: (newUser) => {
    // ê¸°ì¡´ ìºì‹œ ê°€ì ¸ì˜¤ê¸°
    const previousUsers = queryClient.getQueryData(['users']);
    
    // ìƒˆ ì‚¬ìš©ì ì¶”ê°€
    queryClient.setQueryData(['users'], (old) => [...old, newUser]);
    
    // ë˜ëŠ” invalidateQueriesë¡œ ë¦¬í˜ì¹˜
    // queryClient.invalidateQueries({ queryKey: ['users'] });
  },
});
```

---

## ìºì‹± ì „ëµ

### ğŸ” React Query ìºì‹±ì˜ ë™ì‘ ì›ë¦¬

**React Queryê°€ í•´ê²°í•˜ëŠ” ë¬¸ì œ:**

1. **ì¤‘ë³µ ìš”ì²­ ì œê±°**

   ```jsx
   // ì—¬ëŸ¬ ì»´í¬ë„ŒíŠ¸ê°€ ë™ì‹œì— ê°™ì€ ë°ì´í„° ìš”ì²­
   function Header() {
     useQuery({ queryKey: ['user'], queryFn: fetchUser });
   }
   function Sidebar() {
     useQuery({ queryKey: ['user'], queryFn: fetchUser });
   }
   function Profile() {
     useQuery({ queryKey: ['user'], queryFn: fetchUser });
   }
   
   // âŒ ì¼ë°˜ ë°©ë²•: 3ë²ˆ ìš”ì²­!
   // âœ… React Query: 1ë²ˆë§Œ ìš”ì²­! (ë‚˜ë¨¸ì§€ëŠ” ìºì‹œ ì‚¬ìš©)
   ```

2. **ìë™ ë°±ê·¸ë¼ìš´ë“œ ë¦¬í˜ì¹­**

   ```
   ì‚¬ìš©ìê°€ íƒ­ ì „í™˜ í›„ ëŒì•„ì˜´
     â†“
   React Queryê°€ ê°ì§€
     â†“
   ë°ì´í„°ê°€ staleì´ë©´ ìë™ ë¦¬í˜ì¹­
     â†“
   ìµœì‹  ë°ì´í„° ìœ ì§€!

   ```

3. **ë©”ëª¨ë¦¬ ê´€ë¦¬**

   ```
   ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸
     â†“
   í•´ë‹¹ ì¿¼ë¦¬ ì‚¬ìš©ì 0ëª…
     â†“
   Cache Time ë™ì•ˆ ë©”ëª¨ë¦¬ ìœ ì§€ (ë‹¤ì‹œ ë§ˆìš´íŠ¸ë  ìˆ˜ ìˆìŒ)
     â†“
   Cache Time ê²½ê³¼ â†’ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜
   ```

### 1. Stale Time vs Cache Time (í•µì‹¬ ê°œë…!)

```javascript
useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  staleTime: 1000 * 60 * 5,  // 5ë¶„ ë™ì•ˆ fresh
  cacheTime: 1000 * 60 * 10, // 10ë¶„ ë™ì•ˆ ìºì‹œ ìœ ì§€

});
```

**Stale Time (ì‹ ì„ ë„):**

- ë°ì´í„°ê°€ "fresh"ë¡œ ê°„ì£¼ë˜ëŠ” ì‹œê°„
- fresh ë°ì´í„°ëŠ” ë¦¬í˜ì¹˜í•˜ì§€ ì•ŠìŒ
- **ì˜ˆì‹œ**: staleTimeì´ 5ë¶„ì´ë©´, 5ë¶„ ì•ˆì—ëŠ” ìºì‹œì—ì„œ ì¦‰ì‹œ ë°˜í™˜

**Cache Time (ìºì‹œ ìœ ì§€):**

- ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë°ì´í„°ë¥¼ ë©”ëª¨ë¦¬ì— ìœ ì§€í•˜ëŠ” ì‹œê°„
- ì´ ì‹œê°„ì´ ì§€ë‚˜ë©´ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜
- **ì˜ˆì‹œ**: cacheTimeì´ 10ë¶„ì´ë©´, ì»´í¬ë„ŒíŠ¸ ì–¸ë§ˆìš´íŠ¸ í›„ 10ë¶„ê°„ ìºì‹œ ìœ ì§€

### ğŸ¯ ì‹¤ë¬´ ì‹œë‚˜ë¦¬ì˜¤ë¡œ ì´í•´í•˜ê¸°

**ì‹œë‚˜ë¦¬ì˜¤**: ì‚¬ìš©ì í”„ë¡œí•„ í˜ì´ì§€

```
1. 00:00 - í˜ì´ì§€ ì ‘ì†
   â†’ fetchUser() í˜¸ì¶œ (ë„¤íŠ¸ì›Œí¬ ìš”ì²­)
   â†’ ìºì‹œ ì €ì¥ (fresh ìƒíƒœ)

2. 00:30 - ë‹¤ë¥¸ í˜ì´ì§€ ì´ë™ í›„ ëŒì•„ì˜´
   â†’ staleTime 5ë¶„ ì•ˆ â†’ ìºì‹œì—ì„œ ì¦‰ì‹œ ë°˜í™˜ (fresh)
   â†’ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ì—†ìŒ! (ë¹ ë¦„!)

3. 06:00 - ë‹¤ì‹œ í˜ì´ì§€ ì ‘ì†
   â†’ staleTime ì´ˆê³¼ â†’ ìºì‹œ ë°˜í™˜ + ë°±ê·¸ë¼ìš´ë“œ ë¦¬í˜ì¹˜ (stale)
   â†’ ì‚¬ìš©ìëŠ” ì¦‰ì‹œ ë°ì´í„° ë´„ + ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìµœì‹ í™”

4. 15:00 - í˜ì´ì§€ ì ‘ì†
   â†’ cacheTime ì´ˆê³¼ â†’ ìºì‹œ ì‚­ì œë¨
   â†’ fetchUser() ë‹¤ì‹œ í˜¸ì¶œ (ë„¤íŠ¸ì›Œí¬ ìš”ì²­)
```

### ğŸ’¡ ì‹¤ë¬´ TIP: "React QueryëŠ” ì–´ë–»ê²Œ ìºì‹±í•˜ë‚˜ìš”?"

**ë‹µë³€ ì˜ˆì‹œ:**

"React QueryëŠ” Qury Keyë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìºì‹œë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.

**í•µì‹¬ ë©”ì»¤ë‹ˆì¦˜:**

1. **Query Key í•´ì‹±**: `['users', { status: 'active' }]` â†’ ê³ ìœ  í‚¤ ìƒì„±
2. **ìºì‹œ ìŠ¤í† ë¦¬ì§€**: ë©”ëª¨ë¦¬ì— Map êµ¬ì¡°ë¡œ ì €ì¥

3. **State ê´€ë¦¬**:
   - fresh: ì‹ ì„ í•œ ë°ì´í„° (ë¦¬í˜ì¹˜ ì•ˆí•¨)
   - stale: ì˜¤ë˜ëœ ë°ì´í„° (ë°±ê·¸ë¼ìš´ë“œ ë¦¬í˜ì¹˜)
   - inactive: ì‚¬ìš© ì•ˆí•˜ëŠ” ë°ì´í„° (cacheTime í›„ ì‚­ì œ)

**ìµœì í™” íš¨ê³¼:**

- ë™ì¼í•œ Query Key â†’ ë‹¨ì¼ ìš”ì²­ìœ¼ë¡œ í†µí•©
- ìºì‹œ íˆíŠ¸ ì‹œ ì¦‰ì‹œ ë°˜í™˜ (0ms)
- ë°±ê·¸ë¼ìš´ë“œ ë¦¬í˜ì¹˜ë¡œ ìµœì‹ ì„± ìœ ì§€

**ì‹¤ë¬´ ì„¤ì •:**

```javascript
// ìì£¼ ë³€í•˜ì§€ ì•ŠëŠ” ë°ì´í„° (ì‚¬ìš©ì ì •ë³´)
staleTime: 5ë¶„, cacheTime: 10ë¶„

// ìì£¼ ë³€í•˜ëŠ” ë°ì´í„° (ì‹¤ì‹œê°„ ëŒ“ê¸€)
staleTime: 0, cacheTime: 0

// ì •ì  ë°ì´í„° (êµ­ê°€ ëª©ë¡)
staleTime: Infinity, cacheTime: Infinity
```

ì´ë¥¼ í†µí•´ ë„¤íŠ¸ì›Œí¬ ìš”ì²­ì„ ìµœì†Œí™”í•˜ë©´ì„œë„ ë°ì´í„° ìµœì‹ ì„±ì„ ìœ ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

### 2. ë¦¬í˜ì¹˜ ì„¤ì •

```javascript
useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  refetchOnWindowFocus: true,    // ìœˆë„ìš° í¬ì»¤ìŠ¤ ì‹œ
  refetchOnReconnect: true,      // ë„¤íŠ¸ì›Œí¬ ì¬ì—°ê²° ì‹œ
  refetchOnMount: true,          // ë§ˆìš´íŠ¸ ì‹œ
  refetchInterval: 1000 * 30,    // 30ì´ˆë§ˆë‹¤ í´ë§
  refetchIntervalInBackground: false,  // ë°±ê·¸ë¼ìš´ë“œì—ì„œë„ í´ë§
});
```

### 3. ìˆ˜ë™ ë¦¬í˜ì¹˜

```jsx
function Users() {
  const { data, refetch, isRefetching } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
  });

  return (
    <div>
      <button onClick={() => refetch()} disabled={isRefetching}>
        {isRefetching ? 'Refreshing...' : 'Refresh'}
      </button>
      <UserList users={data} />
    </div>
  );
}
```

### 4. Prefetch (ì‚¬ì „ ë¡œë”©)

```jsx
import { useQueryClient } from '@tanstack/react-query';

function UserList() {
  const queryClient = useQueryClient();

  function handleMouseEnter(userId) {
    // ë§ˆìš°ìŠ¤ í˜¸ë²„ ì‹œ ì‚¬ìš©ì ìƒì„¸ ì •ë³´ ë¯¸ë¦¬ ë¡œë“œ
    queryClient.prefetchQuery({
      queryKey: ['user', userId],
      queryFn: () => fetchUser(userId),
    });
  }

  return (
    <ul>
      {users.map(user => (
        <li 
          key={user.id}
          onMouseEnter={() => handleMouseEnter(user.id)}
        >
          <Link to={`/users/${user.id}`}>{user.name}</Link>
        </li>
      ))}
    </ul>
  );
}
```

### 5. Initial Data

```jsx
function UserProfile({ userId }) {
  const queryClient = useQueryClient();

  const { data } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    initialData: () => {
      // ìºì‹œì—ì„œ ì‚¬ìš©ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
      const users = queryClient.getQueryData(['users']);
      // í•´ë‹¹ ì‚¬ìš©ì ì°¾ê¸°
      return users?.find(user => user.id === userId);
    },
  });

  return <div>{data?.name}</div>;
}
```

### 6. Placeholder Data

```jsx
function Users() {
  const { data } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
    placeholderData: [],  // ë¡œë”© ì¤‘ í‘œì‹œí•  ë°ì´í„°
  });

  // ë˜ëŠ” ì´ì „ ë°ì´í„° ìœ ì§€
  const { data } = useQuery({
    queryKey: ['users', page],
    queryFn: () => fetchUsers(page),
    placeholderData: (previousData) => previousData,
  });

  return <UserList users={data} />;
}
```

---

## ë‚™ê´€ì  ì—…ë°ì´íŠ¸

### ê¸°ë³¸ íŒ¨í„´

```jsx
function TodoList() {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: updateTodo,
    onMutate: async (newTodo) => {
      // ì§„í–‰ ì¤‘ì¸ ë¦¬í˜ì¹˜ ì·¨ì†Œ
      await queryClient.cancelQueries({ queryKey: ['todos'] });

      // ì´ì „ ë°ì´í„° ìŠ¤ëƒ…ìƒ·
      const previousTodos = queryClient.getQueryData(['todos']);

      // ë‚™ê´€ì  ì—…ë°ì´íŠ¸
      queryClient.setQueryData(['todos'], (old) =>
        old.map(todo =>
          todo.id === newTodo.id ? newTodo : todo
        )
      );

      // ë¡¤ë°±ì„ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ ë°˜í™˜
      return { previousTodos };
    },
    onError: (err, newTodo, context) => {
      // ì—ëŸ¬ ë°œìƒ ì‹œ ë¡¤ë°±
      queryClient.setQueryData(['todos'], context.previousTodos);
      toast.error('Failed to update todo');
    },
    onSettled: () => {
      // ì„±ê³µ/ì‹¤íŒ¨ ìƒê´€ì—†ì´ ë¦¬í˜ì¹˜
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });

  function handleToggle(todo) {
    mutation.mutate({
      ...todo,
      completed: !todo.completed,
    });
  }

  return (
    <div>
      {todos.map(todo => (
        <TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggle}
        />
      ))}
    </div>
  );
}
```

### ë³µì¡í•œ ì˜ˆì œ: ì¢‹ì•„ìš” ë²„íŠ¼

```jsx
function LikeButton({ postId }) {
  const queryClient = useQueryClient();

  const likeMutation = useMutation({
    mutationFn: (postId) => fetch(`/api/posts/${postId}/like`, { method: 'POST' }),
    onMutate: async (postId) => {
      await queryClient.cancelQueries({ queryKey: ['post', postId] });

      const previousPost = queryClient.getQueryData(['post', postId]);

      queryClient.setQueryData(['post', postId], (old) => ({
        ...old,
        likes: old.likes + 1,
        isLiked: true,
      }));

      return { previousPost };
    },
    onError: (err, postId, context) => {
      queryClient.setQueryData(['post', postId], context.previousPost);
    },
    onSettled: (data, error, postId) => {
      queryClient.invalidateQueries({ queryKey: ['post', postId] });
    },
  });

  const unlikeMutation = useMutation({
    mutationFn: (postId) => fetch(`/api/posts/${postId}/unlike`, { method: 'POST' }),
    onMutate: async (postId) => {
      await queryClient.cancelQueries({ queryKey: ['post', postId] });

      const previousPost = queryClient.getQueryData(['post', postId]);

      queryClient.setQueryData(['post', postId], (old) => ({
        ...old,
        likes: old.likes - 1,
        isLiked: false,
      }));

      return { previousPost };
    },
    onError: (err, postId, context) => {
      queryClient.setQueryData(['post', postId], context.previousPost);
    },
  });

  const { data: post } = useQuery({
    queryKey: ['post', postId],
    queryFn: () => fetchPost(postId),
  });

  function handleClick() {
    if (post.isLiked) {
      unlikeMutation.mutate(postId);
    } else {
      likeMutation.mutate(postId);
    }
  }

  return (
    <button onClick={handleClick}>
      {post.isLiked ? 'â¤ï¸' : 'ğŸ¤'} {post.likes}
    </button>
  );
}
```

---

## ë¬´í•œ ìŠ¤í¬ë¡¤

### useInfiniteQuery

```jsx
import { useInfiniteQuery } from '@tanstack/react-query';

function Posts() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
  } = useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: ({ pageParam = 0 }) => fetchPosts(pageParam),
    getNextPageParam: (lastPage, allPages) => {
      // ë‹¤ìŒ í˜ì´ì§€ ë²ˆí˜¸ ë°˜í™˜
      return lastPage.nextCursor;
    },
    initialPageParam: 0,
  });

  if (isLoading) return <div>Loading...</div>;

  return (
    <div>
      {data.pages.map((page, i) => (
        <div key={i}>
          {page.posts.map(post => (
            <PostCard key={post.id} post={post} />
          ))}
        </div>
      ))}

      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage
          ? 'Loading more...'
          : hasNextPage
          ? 'Load More'
          : 'Nothing more to load'}
      </button>
    </div>
  );
}

async function fetchPosts(pageParam) {
  const response = await fetch(`/api/posts?cursor=${pageParam}`);
  return response.json();
}
```

### ìë™ ë¬´í•œ ìŠ¤í¬ë¡¤

```jsx
import { useInfiniteQuery } from '@tanstack/react-query';
import { useInView } from 'react-intersection-observer';

function Posts() {
  const { ref, inView } = useInView();

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
  } = useInfiniteQuery({
    queryKey: ['posts'],
    queryFn: ({ pageParam = 0 }) => fetchPosts(pageParam),
    getNextPageParam: (lastPage) => lastPage.nextCursor,
    initialPageParam: 0,
  });

  // í™”ë©´ì— ë³´ì´ë©´ ìë™ìœ¼ë¡œ ë‹¤ìŒ í˜ì´ì§€ ë¡œë“œ
  useEffect(() => {
    if (inView && hasNextPage) {
      fetchNextPage();
    }
  }, [inView, hasNextPage, fetchNextPage]);

  return (
    <div>
      {data?.pages.map((page, i) => (
        <div key={i}>
          {page.posts.map(post => (
            <PostCard key={post.id} post={post} />
          ))}
        </div>
      ))}

      {/* ê°ì§€ ì˜ì—­ */}
      <div ref={ref}>
        {isFetchingNextPage && <LoadingSpinner />}
      </div>
    </div>
  );
}
```

### ì–‘ë°©í–¥ ë¬´í•œ ìŠ¤í¬ë¡¤

```jsx
const {
  data,
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
} = useInfiniteQuery({
  queryKey: ['posts'],
  queryFn: ({ pageParam = 0 }) => fetchPosts(pageParam),
  getNextPageParam: (lastPage) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage) => firstPage.previousCursor,
  initialPageParam: 0,
});
```

---

## ê³ ê¸‰ íŒ¨í„´

### 1. Query Cancellation

```jsx
function Search() {
  const [searchTerm, setSearchTerm] = useState('');

  const { data, isLoading } = useQuery({
    queryKey: ['search', searchTerm],
    queryFn: async ({ signal }) => {
      const response = await fetch(`/api/search?q=${searchTerm}`, {
        signal,  // AbortSignal ì „ë‹¬
      });
      return response.json();
    },
    enabled: searchTerm.length > 0,
  });

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      {isLoading && <div>Searching...</div>}
      <SearchResults results={data} />
    </div>
  );
}
```

### 2. Dependent Queries

```jsx
function UserProjects({ userId }) {
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
  });

  const { data: projects } = useQuery({
    queryKey: ['projects', user?.id],
    queryFn: () => fetchProjects(user.id),
    enabled: !!user?.id,  // userê°€ ë¡œë“œëœ í›„ì—ë§Œ ì‹¤í–‰
  });

  return <ProjectList projects={projects} />;
}
```

### 3. Query Keys Factory

```javascript
// queryKeys.js
export const userKeys = {
  all: ['users'],
  lists: () => [...userKeys.all, 'list'],
  list: (filters) => [...userKeys.lists(), { filters }],
  details: () => [...userKeys.all, 'detail'],
  detail: (id) => [...userKeys.details(), id],
};

// ì‚¬ìš©
useQuery({
  queryKey: userKeys.detail(userId),
  queryFn: () => fetchUser(userId),
});

// ëª¨ë“  user ì¿¼ë¦¬ ë¬´íš¨í™”
queryClient.invalidateQueries({ queryKey: userKeys.all });

// íŠ¹ì • user ë¬´íš¨í™”
queryClient.invalidateQueries({ queryKey: userKeys.detail(userId) });
```

### 4. Suspense Mode

```jsx
import { Suspense } from 'react';

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Users />
    </Suspense>
  );
}

function Users() {
  const { data } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
    suspense: true,  // Suspense ëª¨ë“œ í™œì„±í™”
  });

  return <UserList users={data} />;
}
```

### 5. Retry Logic

```javascript
useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  retry: 3,  // 3ë²ˆ ì¬ì‹œë„
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  // 1ì´ˆ, 2ì´ˆ, 4ì´ˆ... ìµœëŒ€ 30ì´ˆ
});

// ì¡°ê±´ë¶€ ì¬ì‹œë„
useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  retry: (failureCount, error) => {
    // 404ëŠ” ì¬ì‹œë„ ì•ˆí•¨
    if (error.status === 404) return false;
    // ìµœëŒ€ 3ë²ˆ
    return failureCount < 3;
  },
});
```

### 6. Query Filters

```javascript
const queryClient = useQueryClient();

// ëª¨ë“  ì¿¼ë¦¬ ë¬´íš¨í™”
queryClient.invalidateQueries();

// íŠ¹ì • ì ‘ë‘ì‚¬ ì¿¼ë¦¬ ë¬´íš¨í™”
queryClient.invalidateQueries({ queryKey: ['posts'] });

// ì¡°ê±´ë¶€ ë¬´íš¨í™”
queryClient.invalidateQueries({
  predicate: (query) => 
    query.queryKey[0] === 'posts' && 
    query.state.data?.isArchived
});

// ì¿¼ë¦¬ ì œê±°
queryClient.removeQueries({ queryKey: ['posts'] });

// ì¿¼ë¦¬ ë°ì´í„° ì„¤ì •
queryClient.setQueriesData(
  { queryKey: ['posts'] },
  (oldData) => oldData.filter(post => !post.isDeleted)
);
```

---

## ì‹¤ì „ ì˜ˆì œ: ë¸”ë¡œê·¸ ì• í”Œë¦¬ì¼€ì´ì…˜

```jsx
// api/posts.js
export const postKeys = {
  all: ['posts'],
  lists: () => [...postKeys.all, 'list'],
  list: (filters) => [...postKeys.lists(), filters],
  details: () => [...postKeys.all, 'detail'],
  detail: (id) => [...postKeys.details(), id],
};

export async function fetchPosts({ page = 1, limit = 10 } = {}) {
  const response = await fetch(`/api/posts?page=${page}&limit=${limit}`);
  if (!response.ok) throw new Error('Failed to fetch posts');
  return response.json();
}

export async function fetchPost(id) {
  const response = await fetch(`/api/posts/${id}`);
  if (!response.ok) throw new Error('Failed to fetch post');
  return response.json();
}

export async function createPost(data) {
  const response = await fetch('/api/posts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!response.ok) throw new Error('Failed to create post');
  return response.json();
}

export async function updatePost({ id, data }) {
  const response = await fetch(`/api/posts/${id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!response.ok) throw new Error('Failed to update post');
  return response.json();
}

export async function deletePost(id) {
  const response = await fetch(`/api/posts/${id}`, {
    method: 'DELETE',
  });
  if (!response.ok) throw new Error('Failed to delete post');
}
```

```jsx
// components/PostList.jsx
import { useQuery } from '@tanstack/react-query';
import { fetchPosts, postKeys } from '../api/posts';

export default function PostList() {
  const [page, setPage] = useState(1);

  const { data, isLoading, error } = useQuery({
    queryKey: postKeys.list({ page }),
    queryFn: () => fetchPosts({ page }),
    placeholderData: (previousData) => previousData,
  });

  if (isLoading && !data) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div>
      {data.posts.map(post => (
        <PostCard key={post.id} post={post} />
      ))}
      
      <Pagination
        page={page}
        totalPages={data.totalPages}
        onPageChange={setPage}
      />
    </div>
  );
}
```

```jsx
// components/CreatePost.jsx
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { createPost, postKeys } from '../api/posts';

export default function CreatePost() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');

  const mutation = useMutation({
    mutationFn: createPost,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
      setTitle('');
      setContent('');
      toast.success('Post created!');
    },
    onError: (error) => {
      toast.error(error.message);
    },
  });

  function handleSubmit(e) {
    e.preventDefault();
    mutation.mutate({ title, content });
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Title"
        required
      />
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Content"
        required
      />
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Creating...' : 'Create Post'}
      </button>
    </form>
  );
}
```

---

## ë‹¤ìŒ ë‹¨ê³„

### í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] useQueryë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤
- [ ] useMutationì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤
- [ ] ìºì‹± ì „ëµì„ ì´í•´í•œë‹¤
- [ ] ë‚™ê´€ì  ì—…ë°ì´íŠ¸ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤
- [ ] ë¬´í•œ ìŠ¤í¬ë¡¤ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤
- [ ] Query Keysë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆë‹¤
- [ ] ì—ëŸ¬ ì²˜ë¦¬ë¥¼ í•  ìˆ˜ ìˆë‹¤
- [ ] DevToolsë¥¼ í™œìš©í•  ìˆ˜ ìˆë‹¤

### ì¶”ê°€ í•™ìŠµ ìë£Œ

- [TanStack Query ê³µì‹ ë¬¸ì„œ](https://tanstack.com/query/latest)
- [React Query vs SWR](https://tanstack.com/query/latest/docs/react/comparison)
- [Best Practices](https://tanstack.com/query/latest/docs/react/community/tkdodos-blog)

---

ëª¨ë“  í•­ëª©ì„ ì²´í¬í–ˆë‹¤ë©´ ë‹¤ìŒ ì£¼ì œë¡œ ë„˜ì–´ê°€ì„¸ìš”! ğŸš€
