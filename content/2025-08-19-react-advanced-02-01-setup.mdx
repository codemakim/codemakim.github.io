---
title: "[React Query 1/8] React Query - 설치 및 설정"
date: "2025-08-24"
description: "React Query 설치 및 QueryClient 설정"
tags: ["React", "고급", "프론트엔드"]
series: "React Query"
seriesOrder: 1
---

# React Query 가이드 - 설치 및 설정

> TanStack Query v5를 기반으로 한 데이터 페칭 학습 자료  
> 출처: [TanStack Query Documentation](https://tanstack.com/query/)

---

## 설치 및 설정

### React Query란?

React Query(TanStack Query)는 서버 상태(server state)를 다루는 라이브러리이다. 서버 상태는 다음 특성을 가진다.

- 서버가 진실의 근원(source of truth)이다.
- 네트워크 지연과 실패가 기본값이다.
- 여러 화면/컴포넌트가 같은 데이터를 동시에 필요로 한다.
- 시간이 지나면 데이터가 낡는다.

React Query는 서버 상태를 요청/캐시/동기화 관점에서 표준화한다.

핵심 기능은 다음이다.

- 자동 캐싱
- 백그라운드 리페칭
- 중복 요청 제거
- 뮤테이션 후 동기화(invalidate, cache update)
- 낙관적 업데이트
- 페이지네이션/무한 스크롤
- 서버 상태와 클라이언트 상태 분리

---

## 왜 React Query인가

실무에서 `useEffect + useState`로 페칭을 직접 구현하면 기능이 붙을수록 코드가 급격히 복잡해진다.

- 로딩/에러/성공 상태 관리
- 중복 요청 방지(여러 컴포넌트가 같은 API 호출)
- 재시도 정책
- 탭 전환 후 복귀 시 최신화
- 캐시 무효화(작성/수정/삭제 이후 리스트 최신화)
- 페이지네이션에서 이전 데이터 유지

```tsx
// 전통적인 방식의 전형적인 형태
import { useEffect, useState } from "react";

function Users() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    fetch("/api/users")
      .then((res) => {
        if (!res.ok) throw new Error("failed");
        return res.json();
      })
      .then((data) => {
        setUsers(data);
        setLoading(false);
      })
      .catch((err) => {
        setError(err);
        setLoading(false);
      });
  }, []);

  if (loading) return <div>loading...</div>;
  if (error) return <div>error</div>;
  return <UserList users={users} />;
}
```

React Query는 이 패턴을 라이브러리로 끌어올려, “팀 규칙”으로 고정할 수 있게 만든다.

```tsx
import { useQuery } from "@tanstack/react-query";

function Users() {
  const query = useQuery({
    queryKey: ["users"],
    queryFn: () => fetchJson("/api/users"),
  });

  if (query.isPending) return <div>loading...</div>;
  if (query.isError) return <div>error</div>;
  return <UserList users={query.data} />;
}
```

---

## 이 시리즈에서 가장 중요한 전제: 서버 상태와 클라이언트 상태 분리

React Query가 맡는 것은 서버 상태다.

- 서버 상태 예시: 사용자 목록, 게시글 상세, 댓글 목록, 검색 결과
- 클라이언트 상태 예시: 모달 열림 여부, 탭 선택, 입력 폼 임시값, 다크모드 토글

서버 상태를 전역 상태 라이브러리에 넣기 시작하면 캐시/리페치/무효화 규칙을 직접 구현하게 된다. 실무에서 이 비용이 가장 자주 누적된다.

---

## 핵심 개념 3개

### 1) queryKey가 캐시의 주소다

React Query는 queryKey를 기준으로 캐시를 저장하고 재사용한다.

- `["users"]`
- `["user", userId]`
- `["posts", { page, tag }]`

queryKey가 잘못되면 다음이 된다.

- 다른 화면인데 같은 캐시를 공유한다(데이터 오염).
- 무효화가 과하게 일어난다(리페치 폭발).

### 2) staleTime은 신선도다

`staleTime` 동안 데이터는 fresh로 간주된다. fresh 데이터는 불필요한 리페치가 억제된다.

### 3) gcTime(v5)은 메모리 유지 시간이다

TanStack Query v5에서는 `cacheTime`이 `gcTime`으로 바뀌었다.

- `gcTime`: 관찰자(observer)가 0명이 된 뒤 캐시를 메모리에 얼마나 유지할지 결정한다.

즉 “신선도”와 “메모리 유지”는 다른 축이다.

---

## 설치

```bash
npm install @tanstack/react-query
npm install @tanstack/react-query-devtools
```

---

## QueryClient 설정(최소 예제)

React Query는 전역에 `QueryClient`가 필요하다. 이 객체가 캐시와 기본 정책의 중심이다.

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

const queryClient = new QueryClient();

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

---

## 실무 기본 설정(권장 출발점)

```tsx
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 30,
      gcTime: 1000 * 60 * 5,
      retry: 1,
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 0,
    },
  },
});
```

이 값은 정답이 아니다. 중요한 것은 “팀이 설명 가능한 기준”을 갖는 것이다.

---

## fetch 규칙(에러 처리를 성공으로 착각하지 않기)

React Query는 “queryFn이 throw하면 실패”로 인식한다. `fetch`는 4xx/5xx에서도 throw하지 않으므로 규칙을 만든다.

```tsx
type ApiError = Error & { status?: number };

export async function fetchJson<T>(input: RequestInfo, init?: RequestInit): Promise<T> {
  const res = await fetch(input, init);
  if (!res.ok) {
    const err: ApiError = new Error("request failed");
    err.status = res.status;
    throw err;
  }
  return (await res.json()) as T;
}
```

---

## Vue와 비교

Vue에서도 `@tanstack/vue-query`로 동일한 모델을 쓴다. 개념 대응은 다음과 같다.

| 관심사 | Vue 생태계 | React 생태계 |
| --- | --- | --- |
| 서버 상태 관리 | `@tanstack/vue-query` | `@tanstack/react-query` |
| 클라이언트 전역 상태 | Pinia | Zustand/Redux/Jotai |
| 캐시 키 | queryKey | queryKey |

```html
<script setup>
import { useQuery } from "@tanstack/vue-query";

const query = useQuery({
  queryKey: ["users"],
  queryFn: () => fetch("/api/users").then((res) => res.json()),
});
</script>
```

---

## 체크리스트

- 서버 상태와 클라이언트 상태를 구분할 수 있다.
- queryKey가 캐시의 주소라는 의미를 설명할 수 있다.
- `staleTime`과 `gcTime(v5)`의 차이를 설명할 수 있다.
- `fetch`는 4xx/5xx에서 throw하지 않으므로 직접 throw 규칙이 필요하다는 점을 이해한다.
