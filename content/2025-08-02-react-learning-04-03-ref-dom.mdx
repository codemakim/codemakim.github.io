---
title: "📚 [React 기초 4-3/10] Ref로 DOM 조작하기"
date: "2025-08-02"
description: "DOM 노드 접근과 ref 콜백, forwardRef, useImperativeHandle 사용법"
tags: ["React", "학습", "Ref", "DOM", "초급"]
series: "React 기초"
seriesOrder: 29
---

## Ref로 DOM 조작하기

### DOM 노드에 접근하기

React는 자동으로 DOM을 업데이트하므로 직접 조작할 일이 거의 없습니다. 하지만 때로는 필요합니다:

- input에 포커스
- 요소로 스크롤
- 크기와 위치 측정

```jsx
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

**단계:**

1. `useRef`로 ref 선언
2. JSX의 `ref` 속성에 전달
3. React가 `<input>` DOM 노드를 `inputRef.current`에 저장

### Ref 콜백으로 ref 리스트 관리

```jsx
import { useRef } from 'react';

export default function CatFriends() {
  const itemsRef = useRef(null);

  function scrollToId(itemId) {
    const map = getMap();
    const node = map.get(itemId);
    node.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  function getMap() {
    if (!itemsRef.current) {
      // 처음 사용 시 Map 초기화
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }

  return (
    <>
      <nav>
        <button onClick={() => scrollToId(0)}>
          Tom
        </button>
        <button onClick={() => scrollToId(5)}>
          Maru
        </button>
        <button onClick={() => scrollToId(9)}>
          Jellylorum
        </button>
      </nav>
      <div>
        <ul>
          {catList.map(cat => (
            <li
              key={cat.id}
              ref={(node) => {
                const map = getMap();
                if (node) {
                  map.set(cat.id, node);
                } else {
                  map.delete(cat.id);
                }
              }}
            >
              <img src={cat.imageUrl} alt={cat.name} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

const catList = [];
for (let i = 0; i < 10; i++) {
  catList.push({
    id: i,
    imageUrl: 'https://placekitten.com/250/200?image=' + i
  });
}
```

**Ref 콜백:**

- `ref={(node) => { ... }}`
- React가 DOM 노드를 생성할 때 `node`로 호출
- DOM 노드가 제거될 때 `null`로 호출

### 다른 컴포넌트의 DOM 노드 접근

```jsx
// ❌ 작동하지 않음
function MyInput() {
  return <input />;
}

export default function Form() {
  const inputRef = useRef(null);
  return <MyInput ref={inputRef} />;  // 에러!
}
```

**해결책: `forwardRef` 사용**

```jsx
import { forwardRef, useRef } from 'react';

const MyInput = forwardRef((props, ref) => {
  return <input {...props} ref={ref} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

### useImperativeHandle로 노출되는 기능 제한

```jsx
import { forwardRef, useRef, useImperativeHandle } from 'react';

const MyInput = forwardRef((props, ref) => {
  const realInputRef = useRef(null);
  
  useImperativeHandle(ref, () => ({
    // focus만 노출
    focus() {
      realInputRef.current.focus();
    },
  }));
  
  return <input {...props} ref={realInputRef} />;
});

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();  // ✅ 가능
    // inputRef.current.value = 'Hi';  // ❌ 불가능 (노출 안됨)
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

### React가 ref를 첨부하는 시점

**React에서 모든 업데이트는 두 단계로 분할됩니다:**

1. **렌더**: React가 컴포넌트를 호출하여 화면에 무엇이 있어야 하는지 파악
2. **커밋**: React가 변경사항을 DOM에 적용

**Ref 첨부 시점:**

- **렌더 중**: `ref.current = null`
- **커밋 전**: React가 `ref.current`를 DOM 노드로 설정

### flushSync로 state 업데이트 강제

```jsx
import { useState, useRef } from 'react';
import { flushSync } from 'react-dom';

export default function TodoList() {
  const listRef = useRef(null);
  const [todos, setTodos] = useState(initialTodos);

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    
    flushSync(() => {
      setText('');
      setTodos([...todos, newTodo]);
    });
    
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>Add</button>
      <input value={text} onChange={e => setText(e.target.value)} />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
const initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}
```

### ref로 DOM 조작 시 모범 사례

**Ref는 탈출구입니다.** "React 밖으로 벗어나야" 할 때만 사용하세요.

**좋은 예:**

- 포커스 관리
- 스크롤 위치
- React가 노출하지 않는 브라우저 API 호출

**나쁜 예:**

```jsx
// ❌ 나쁨: React가 관리하는 DOM 수정
const divRef = useRef(null);
divRef.current.remove();  // React와 충돌!
divRef.current.appendChild(child);  // React가 혼란스러워함

// ✅ 좋음: React가 업데이트하지 않는 부분만 수정
divRef.current.scrollIntoView();
divRef.current.focus();
```

### Vue와 비교

```html
<!-- Vue: template ref -->
<script setup>
import { ref } from 'vue'

const inputRef = ref(null)

function focus() {
  inputRef.value.focus()
}
</script>

<template>
  <input ref="inputRef" />
  <button @click="focus">Focus</button>
</template>
```

```jsx
// React: useRef + ref 속성
import { useRef } from 'react'

function Form() {
  const inputRef = useRef(null)
  
  function focus() {
    inputRef.current.focus()
  }
  
  return (
    <>
      <input ref={inputRef} />
      <button onClick={focus}>Focus</button>
    </>
  )
}
```

---
