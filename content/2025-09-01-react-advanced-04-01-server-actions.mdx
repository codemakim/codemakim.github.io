---
title: "[Next.js 고급 1/7] Next.js 고급 - 서버 액션"
date: "2025-09-06"
description: "서버 컴포넌트와 서버 액션의 동작 원리"
tags: ["Next.js", "React", "고급", "프론트엔드"]
series: "Next.js 고급"
seriesOrder: 1
---

# Next.js 고급 - 서버 액션

> 이 글은 Next.js(App Router)에서 Server Actions를 왜 쓰는지, 어디까지 써야 하는지를 실무 관점에서 정리한다.  
> 이 프로젝트는 Next.js 16을 사용하므로, 설명은 “14+에서 도입된 개념이 16에서도 그대로 유효하다”는 전제로 이어진다.

---

## 서버 액션

### 개요

서버 액션은 서버에서만 실행되는 비동기 함수다. 폼 제출과 뮤테이션을 API route 중심에서 “함수 호출 중심”으로 재구성한다.

실무에서 서버 액션은 다음을 줄인다.

- API route 파일과 클라이언트 fetch 코드의 보일러플레이트
- 요청/응답 타입의 분산(타입 안전성)
- 폼 제출 흐름의 중복 구현(로딩/에러/리다이렉트)

반대로 다음을 더 신경써야 한다.

- 캐시 무효화 전략(`revalidatePath`, `revalidateTag`)
- 보안 경계(서버에서만 가능한 작업, 인증/인가)
- 클라이언트 UX(중복 제출 방지, 에러 메시지 설계)

### 서버 컴포넌트와 서버 액션의 동작 원리

서버 컴포넌트가 해결하는 근본적 문제:
전통적인 React (CSR):

```
브라우저가 HTML 받음 (거의 비어있음)
  ↓
JavaScript 번들 다운로드 (모든 컴포넌트 코드 포함!)
  ↓
React 실행
  ↓
API 호출로 데이터 페칭
  ↓
화면 렌더링
문제: 번들 크기 ↑, 초기 로딩 ↓, SEO ↓
```

서버 컴포넌트 (Next.js):

```
서버에서 컴포넌트 실행
  ↓
DB 직접 접근 (빠름!)
  ↓
완성된 HTML 생성
  ↓
HTML + 최소한의 JavaScript만 전송
  ↓
즉시 화면 표시
장점: 번들 크기 ↓, 초기 로딩 ↑, SEO ↑
```

### 서버 컴포넌트 vs 클라이언트 컴포넌트

번들에 포함되는 것:

```jsx
// 서버 컴포넌트 (기본)
async function UserList() {
  const users = await db.users.findMany(); // 서버에서 실행

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
// 브라우저에 전송되는 것:
// - HTML: <ul><li>John</li><li>Jane</li></ul>
// - JavaScript: 0KB! (컴포넌트 코드 전송 안됨)
```

```jsx
// 클라이언트 컴포넌트
"use client";
function Counter() {
  const [count, setCount] = useState(0); // 브라우저에서 실행

  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}
// 브라우저에 전송되는 것:
// - HTML: <button>0</button>
// - JavaScript: Counter 컴포넌트 전체 코드 + React runtime
```

### 서버 액션의 동작 원리

기존 방식 (API Route):

```
클라이언트 → POST /api/create-post
           ↓
       API Route 핸들러
           ↓
       DB에 저장
           ↓
       응답 반환
           ↓
     클라이언트가 받음
문제: 타입 안전성 ↓, 보일러플레이트 ↑
```

서버 액션:

```
클라이언트 → 서버 액션 호출 (RPC처럼!)
           ↓
       Next.js가 자동으로 POST 요청 생성
           ↓
       서버에서 함수 실행
           ↓
       DB에 저장
           ↓
       자동 캐시 무효화
           ↓
     결과 반환
장점: 타입 안전 ↑, 코드 간결 ↑, 자동 최적화
```

실제 네트워크 요청:

```
POST /_next/data/XYZ/actions/createPost
Content-Type: multipart/form-data
{
  "0": "title value",
  "1": "content value"
}
```

Next.js가 자동으로:

1. 폼 데이터를 직렬화
2. POST 요청 생성
3. 서버에서 함수 실행
4. 응답 처리
5. 캐시 무효화

---

## 1. 서버 액션을 언제 쓰는가(실무 기준)

### 서버 액션이 적합한 경우

- 폼 제출이 많다(관리자 CRUD, 설정 저장, 댓글 작성).
- DB/서버 비밀(키, 토큰)에 접근해야 한다.
- 저장 후 리다이렉트 같은 전형적인 흐름이 반복된다.

### Route Handler(API route)가 더 적합한 경우

- 외부 클라이언트(모바일 앱, 다른 서비스)가 같은 엔드포인트를 호출해야 한다.
- 스트리밍/SSE/Webhook 등 HTTP 레벨 제어가 필요하다.
- 엣지 런타임에서 동작해야 한다.

서버 액션은 API를 없애는 기술이 아니다. 웹 앱 내부의 폼/뮤테이션을 단순화하는 기술이다.

---

## 2. 가장 기본 패턴: form `action`에 서버 액션 연결

서버 액션은 form의 `action`으로 연결되는 순간 가장 자연스럽다.

```tsx
// app/actions.ts
"use server";

import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

export async function createPost(formData: FormData) {
  const title = String(formData.get("title") ?? "");
  const content = String(formData.get("content") ?? "");

  // 서버에서만 가능한 작업이 여기에 들어간다.
  await db.posts.create({ data: { title, content } });

  revalidatePath("/posts");
  redirect("/posts");
}
```

```tsx
// app/posts/new/page.tsx
import { createPost } from "@/app/actions";

export default function NewPostPage() {
  return (
    <form action={createPost}>
      <input name="title" required />
      <textarea name="content" required />
      <button type="submit">Create</button>
    </form>
  );
}
```

여기서 중요한 점은 클라이언트 fetch가 없다는 사실이다. 브라우저는 폼 제출만 하고, Next.js가 서버 액션 호출로 변환한다.

---

## 3. 에러 처리: throw와 return을 구분한다

서버 액션은 두 종류의 실패를 구분해서 다루는 편이 좋다.

- 검증 실패: 같은 화면에서 필드 에러를 보여줘야 한다. return 값으로 돌려준다.
- 시스템 실패: DB/네트워크 같은 실패다. 에러 UI 또는 로깅/추적 대상으로 처리한다. throw로 던진다.

이 구분이 없으면 사용자가 고칠 수 있는 에러까지 전부 서버 에러처럼 보인다.

---

## 4. 클라이언트 UX: 중복 제출 방지(`useFormStatus`)

폼 UX는 중복 제출 방지에서 시작한다.

```tsx
"use client";

import { useFormStatus } from "react-dom";

export function SubmitButton() {
  const { pending } = useFormStatus();
  return (
    <button type="submit" disabled={pending}>
      {pending ? "Submitting..." : "Submit"}
    </button>
  );
}
```

이 버튼은 해당 form의 제출 상태를 자동으로 반영한다. 로컬 state로 pending을 직접 관리하는 방식보다 실수가 줄어든다.

---

## 5. 캐시 무효화의 원리: `revalidatePath` vs `revalidateTag`

서버 액션은 쓰기 작업 이후 어떤 캐시가 낡았는지 알아야 한다.

- `revalidatePath("/posts")`: 특정 경로 단위로 무효화한다. 단순하지만 범위가 커질 수 있다.
- `revalidateTag("posts")`: fetch에 태그를 달아두고 태그 단위로 무효화한다. 규모가 커질수록 선호되는 방식이다.

ISR 글에서 이 부분을 더 깊게 다룬다.

---

## Nuxt와 비교

Nuxt에서도 서버에서만 실행되는 로직(서버 API, Nitro)을 두고 폼 제출을 처리한다. Next.js Server Actions의 특징은 서버 함수가 컴포넌트 트리와 직접 연결된다는 점이다.

| 관심사 | Nuxt | Next.js |
| --- | --- | --- |
| 서버 로직 위치 | Nitro route/서버 API | Server Actions 또는 Route Handler |
| 폼 제출 | `useFetch`/서버 API 호출 | form `action` → server action |
| 캐시 무효화 | Nitro 캐시/ISR 전략 | `revalidatePath`/`revalidateTag` |
| 보안 경계 | 서버 코드에 둔다 | server action에 둔다 |

### 실무 TIP: "서버 컴포넌트의 장점은?"

답변 예시:
"서버 컴포넌트의 핵심 장점은 번들 크기 제로이다.
동작 원리:
서버 컴포넌트는 서버에서만 실행되고, 결과 HTML만 클라이언트로 전송된다. 컴포넌트 코드 자체는 JavaScript 번들에 포함되지 않다.
실무 효과:

- 대시보드 페이지에 차트 라이브러리(1MB) 사용 시
  - CSR: 1MB를 브라우저가 다운로드
  - 서버 컴포넌트: 서버에서 차트 생성 → SVG/HTML만 전송 → 0KB!
    추가 장점:

1. DB 직접 접근: API 레이어 불필요
2. 민감 정보 보호: API 키가 클라이언트 노출 안됨
3. SEO 최적화: 완성된 HTML 전송
   주의사항:
   인터랙티브 필요 시 클라이언트 컴포넌트 사용. 하지만 전체가 아니라 필요한 부분만 `'use client'`로 분리하여 번들 크기 최소화할 수 있다."
   특징:

- API 라우트 불필요
- 타입 안전
- 폼 제출 최적화
- 자동 리다이렉트

### 기본 사용법

```jsx
// app/actions.js
"use server";
export async function createPost(formData) {
  const title = formData.get("title");
  const content = formData.get("content");

  // 데이터베이스에 저장
  await db.posts.create({
    data: { title, content },
  });

  // 캐시 무효화
  revalidatePath("/posts");

  // 리다이렉트
  redirect("/posts");
}
```

```jsx
// app/posts/new/page.jsx
import { createPost } from "../actions";
export default function NewPost() {
  return (
    <form action={createPost}>
      <input name="title" required />
      <textarea name="content" required />
      <button type="submit">Create Post</button>
    </form>
  );
}
```

### 클라이언트에서 호출

```jsx
"use client";
import { createPost } from "./actions";
import { useState } from "react";
export default function CreatePostForm() {
  const [pending, setPending] = useState(false);
  async function handleSubmit(formData) {
    setPending(true);
    await createPost(formData);
    setPending(false);
  }
  return (
    <form action={handleSubmit}>
      <input name="title" />
      <button type="submit" disabled={pending}>
        {pending ? "Creating..." : "Create"}
      </button>
    </form>
  );
}
```

### useFormStatus Hook

```jsx
"use client";
import { useFormStatus } from "react-dom";
function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? "Submitting..." : "Submit"}
    </button>
  );
}
export default function Form() {
  return (
    <form action={createPost}>
      <input name="title" />
      <SubmitButton />
    </form>
  );
}
```

### useFormState Hook

```jsx
"use client";
import { useFormState } from "react-dom";
import { createPost } from "./actions";
export default function Form() {
  const [state, formAction] = useFormState(createPost, {
    message: "",
    errors: {},
  });
  return (
    <form action={formAction}>
      <input name="title" />
      {state.errors?.title && <p>{state.errors.title}</p>}

      <input name="email" />
      {state.errors?.email && <p>{state.errors.email}</p>}

      <button type="submit">Submit</button>
      {state.message && <p>{state.message}</p>}
    </form>
  );
}
```

### 서버 액션 검증

```jsx
"use server";
import { z } from "zod";
import { revalidatePath } from "next/cache";
const schema = z.object({
  title: z.string().min(1).max(100),
  content: z.string().min(10),
});
export async function createPost(prevState, formData) {
  const validatedFields = schema.safeParse({
    title: formData.get("title"),
    content: formData.get("content"),
  });
  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: "Validation failed",
    };
  }
  const { title, content } = validatedFields.data;
  try {
    await db.posts.create({
      data: { title, content },
    });
  } catch (error) {
    return {
      message: "Database error",
    };
  }
  revalidatePath("/posts");
  redirect("/posts");
}
```

---
