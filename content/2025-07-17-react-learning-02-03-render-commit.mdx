---
title: "📚 [React 기초 2-3/8] 렌더와 커밋"
date: "2025-07-17"
description: "React의 UI 업데이트 과정인 렌더링과 커밋을 이해합니다"
tags: ["React", "학습", "Vue", "초급", "프론트엔드"]
series: "React 기초"
seriesOrder: 13
---

# React 학습 가이드 - 렌더와 커밋

> React 공식 문서를 기반으로 한 학습 자료  
> 원문: [Adding Interactivity - React](https://react.dev/learn/adding-interactivity)

---

## 렌더와 커밋

### React의 UI 업데이트 3단계

컴포넌트가 화면에 표시되기까지 3단계를 거칩니다:

```
1. 트리거 (Trigger)
   ↓
2. 렌더 (Render)
   ↓
3. 커밋 (Commit)
```

**레스토랑 비유:**

1. **트리거**: 손님 주문을 주방으로 전달
2. **렌더**: 주방에서 음식 준비
3. **커밋**: 테이블에 음식 제공

### 1단계: 렌더 트리거

React가 컴포넌트를 렌더링하기 시작하는 이유는 두 가지입니다.

#### (1) 초기 렌더

```jsx
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(<App />);  // 초기 렌더 트리거!
```

#### (2) State 업데이트

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
```

`setCount()` 호출 → 리렌더링 트리거!

### 2단계: 컴포넌트 렌더

**"렌더링"** = React가 컴포넌트(함수)를 호출하는 것

React가 컴포넌트 함수를 호출해서 무엇을 화면에 그려야 할지 계산합니다.

- **초기 렌더**: 루트 컴포넌트 호출
- **이후 렌더**: state 업데이트가 트리거한 컴포넌트 호출

**재귀적 프로세스:**

1. 업데이트된 컴포넌트를 호출
2. 해당 컴포넌트가 다른 컴포넌트를 반환하면 다음 렌더링
3. 중첩된 컴포넌트가 없을 때까지 반복

#### 🔍 Virtual DOM (가상 DOM)이란?

React는 실제 DOM을 직접 수정하지 않고, 먼저 **가상 DOM**을 만듭니다.

**가상 DOM = JavaScript 객체로 표현된 UI 구조**

```jsx
// 컴포넌트
<div>
  <h1>Hello</h1>
  <p>World</p>
</div>

// 가상 DOM (단순화된 예시)
{
  type: 'div',
  children: [
    { type: 'h1', children: 'Hello' },
    { type: 'p', children: 'World' }
  ]
}
```

**왜 가상 DOM을 사용할까?**

```
실제 DOM 조작은 느림!
- 브라우저가 레이아웃 재계산
- 화면 다시 그리기
- 매우 비싼 작업

가상 DOM 조작은 빠름!
- 그냥 JavaScript 객체
- 메모리에서만 작동
- 브라우저 작업 없음
```

#### 🎯 Reconciliation (재조정)

React가 **변경사항을 찾아내는 과정**을 Reconciliation이라고 합니다.

**동작 방식:**

```
1. 새로운 가상 DOM 생성
   ↓
2. 이전 가상 DOM과 비교 (Diffing)
   ↓
3. 변경된 부분만 목록 작성
   ↓
4. 실제 DOM에 최소한의 변경만 적용
```

**예시:**

```jsx
// 이전 렌더
<div>
  <h1>Count: 0</h1>
  <p>Click the button</p>
</div>

// 새 렌더 (count 증가)
<div>
  <h1>Count: 1</h1>
  <p>Click the button</p>
</div>

// React가 찾은 변경사항:
// "h1의 텍스트만 변경됨"
// → 실제 DOM에서 h1 텍스트만 업데이트!
```

**왜 빠를까?**

- ❌ 전체 DOM을 다시 만들지 않음
- ✅ 변경된 부분만 업데이트
- ✅ JavaScript로 먼저 계산 (빠름)
- ✅ 실제 DOM 조작은 최소화 (느린 작업)

### 예제: 렌더링 과정

```jsx
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="Photo"
    />
  );
}
```

**초기 렌더 (상세 과정):**

```
1. React가 Gallery() 호출
   → JSX를 가상 DOM으로 변환
   
2. 가상 DOM 생성:
   {
     type: 'section',
     children: [
       { type: 'h1', children: 'Inspiring Sculptures' },
       { type: 'img', props: { src: '...', alt: 'Photo' } },
       { type: 'img', props: { src: '...', alt: 'Photo' } },
       { type: 'img', props: { src: '...', alt: 'Photo' } }
     ]
   }

3. 초기 렌더라서 이전 가상 DOM 없음
   → 전체를 실제 DOM에 생성 (커밋 단계로)
```

**이후 렌더 (state 업데이트 시):**

```jsx
export default function Gallery() {
  const [count, setCount] = useState(0);
  
  return (
    <section>
      <h1>Sculptures: {count}</h1>
      <button onClick={() => setCount(count + 1)}>
        Add
      </button>
      <Image />
      <Image />
    </section>
  );
}
```

```
1. setCount 호출 → 렌더 트리거
   
2. Gallery() 다시 호출 → 새 가상 DOM 생성
   
3. Reconciliation (재조정):
   이전 가상 DOM:
   { type: 'h1', children: 'Sculptures: 0' }
   
   새 가상 DOM:
   { type: 'h1', children: 'Sculptures: 1' }
   
   → 변경사항: "h1 텍스트만 변경"
   
4. 변경 목록 생성:
   - h1의 textContent를 "Sculptures: 1"로 업데이트
   
5. 커밋 단계로 전달
```

**핵심: React는 전체를 다시 그리지 않고, 변경된 부분만 찾아냅니다!**

### 3단계: DOM에 변경사항 커밋

Reconciliation에서 계산한 변경사항을 **실제 DOM에 적용**하는 단계입니다.

**커밋 단계의 작업:**

```
렌더 단계에서 받은 변경 목록:
[ 
  { type: 'update', element: h1, property: 'textContent', value: 'Sculptures: 1' }
]

커밋 단계가 실제 DOM에 적용:
document.querySelector('h1').textContent = 'Sculptures: 1';
```

**초기 렌더와 리렌더링 차이:**

| 단계 | 초기 렌더 | 리렌더링 |
|------|-----------|----------|
| **렌더 단계** | 전체 가상 DOM 생성 | 이전/새 가상 DOM 비교 |
| **커밋 단계** | 모든 DOM 노드 생성<br/>`appendChild()` | 변경된 부분만 업데이트<br/>`textContent`, `className` 등 |

**중요:** React는 렌더링 간에 차이가 있을 때만 DOM 노드를 변경합니다.

**변경 없으면 DOM 건드리지 않음:**

```jsx
function Button() {
  return <button>Click</button>;
}

// 부모가 리렌더링되어도:
// 1. Button 함수 호출됨 (렌더 단계)
// 2. 가상 DOM 비교: 동일함!
// 3. 커밋 단계에서 아무것도 안함
// → 실제 DOM의 button은 그대로!
```

### 예제: 변경 없으면 DOM 업데이트 안함

```jsx
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

```jsx
// 매초 리렌더링
setInterval(() => {
  root.render(<Clock time={new Date().toLocaleTimeString()} />);
}, 1000);
```

**매초마다 일어나는 일:**

```
1. 렌더 단계:
   - Clock() 함수 호출
   - 새 가상 DOM 생성
   
   이전 가상 DOM:
   { type: 'h1', children: '12:00:00' }
   { type: 'input', props: {} }
   
   새 가상 DOM:
   { type: 'h1', children: '12:00:01' }  ← 변경됨!
   { type: 'input', props: {} }          ← 동일함!
   
2. Reconciliation:
   - h1: 텍스트 변경됨 → 업데이트 필요
   - input: 완전히 동일 → 업데이트 불필요
   
3. 커밋 단계:
   - h1.textContent = '12:00:01' 만 실행
   - input은 건드리지 않음!
```

**결과:**

- ✅ `<h1>`만 업데이트됨 (시간 변경)
- ✅ `<input>`은 업데이트 안됨 (완전히 동일)
- ✅ 입력 중인 텍스트 유지됨!
- ✅ input의 포커스 상태도 유지됨!

**왜 이게 중요한가?**

전통적인 방식으로 전체를 다시 렌더링하면:
- input 요소가 제거되고 새로 생성됨
- 입력한 텍스트 사라짐
- 포커스 잃음

React는 필요한 부분만 업데이트하여 이런 문제를 방지합니다!

### 브라우저 페인팅

커밋 단계가 끝나면, 브라우저가 화면을 다시 그립니다.

**전체 흐름:**

```
1. 트리거 (Trigger)
   → setState 호출
   
2. 렌더 (Render)
   → React: 컴포넌트 함수 호출
   → React: 가상 DOM 생성 & 비교
   
3. 커밋 (Commit)
   → React: 실제 DOM 업데이트
   
4. 페인팅 (Paint)
   → 브라우저: 화면에 그리기
```

**용어 구분 (중요!):**

| 용어 | 누가 | 무엇을 | 어디서 |
|------|------|--------|--------|
| **"렌더링"** (React) | React | 컴포넌트 호출<br/>가상 DOM 비교 | JavaScript<br/>(메모리) |
| **"페인팅"** (브라우저) | 브라우저 | 픽셀 그리기 | 화면 |

**React 렌더링 ≠ 브라우저 페인팅**

```jsx
// React 렌더링은 여러 번 일어나도
function Counter() {
  const [count, setCount] = useState(0);
  console.log('렌더링!');  // 매번 출력
  return <h1>{count}</h1>;
}

// 브라우저 페인팅은 최종 결과만
// → 변경된 부분만 화면에 반영
```

**성능 이점:**

- React가 메모리에서 빠르게 계산 (JavaScript)
- 브라우저는 최종 결과만 그림 (느린 작업 최소화)
- 전체 페이지를 다시 그리지 않음

### Vue와 비교

Vue도 유사한 가상 DOM (Virtual DOM) 방식을 사용하지만, 몇 가지 차이가 있습니다:

**공통점:**

| 단계 | React | Vue |
|------|-------|-----|
| 트리거 | `setState()` | `ref.value` 변경 |
| 렌더 | 컴포넌트 함수 호출<br/>가상 DOM 생성 | 컴포넌트 render 함수<br/>가상 DOM 생성 |
| 비교 | Reconciliation (Diffing) | Diff 알고리즘 |
| 커밋 | 실제 DOM 업데이트 | 실제 DOM 패치 |

**차이점:**

```jsx
// React: 명시적 setState
function Counter() {
  const [count, setCount] = useState(0);
  
  const increment = () => {
    setCount(count + 1);  // 명시적으로 업데이트 알림
  };
  
  return <button onClick={increment}>{count}</button>;
}
```

```vue
<!-- Vue: 반응성 시스템 -->
<script setup>
import { ref } from 'vue';

const count = ref(0);

const increment = () => {
  count.value++;  // 자동으로 변경 감지
};
</script>

<template>
  <button @click="increment">{{ count }}</button>
</template>
```

**핵심 차이:**

- **React**: 개발자가 명시적으로 "업데이트 필요"를 알림 (`setState`)
- **Vue**: 반응성 시스템이 자동으로 변경 감지 (Proxy 기반)

**하지만 결과는 동일:**

둘 다 가상 DOM을 사용하여 변경된 부분만 효율적으로 업데이트합니다!

---

## 핵심 요약

### React의 3단계 프로세스

```
1. 트리거 (Trigger)
   → 초기 렌더 또는 state 변경

2. 렌더 (Render)
   → 컴포넌트 호출
   → 가상 DOM 생성
   → Reconciliation (이전/새 가상 DOM 비교)

3. 커밋 (Commit)
   → 변경사항만 실제 DOM에 적용
   → 브라우저 페인팅
```

### 왜 빠른가?

- ✅ 가상 DOM: JavaScript 객체 (빠름)
- ✅ Diffing: 변경된 부분만 찾음
- ✅ 최소 업데이트: DOM 조작 최소화 (느린 작업)
- ✅ 일괄 처리: 여러 변경을 한 번에

### 기억할 것

- "렌더링" = 컴포넌트 호출 (Virtual DOM 작업)
- "페인팅" = 브라우저가 화면에 그림
- React는 변경된 부분만 업데이트
- 전체를 다시 그리지 않음!
