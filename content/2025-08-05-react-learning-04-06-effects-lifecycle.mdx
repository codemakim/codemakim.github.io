---
title: "📚 [React 기초 4-6/10] 반응형 Effect의 생명주기"
date: "2025-08-05"
description: "Effect의 생명주기와 의존성 배열의 중요성을 이해합니다"
tags: ["React", "학습", "Effect", "생명주기"]
series: "React 기초"
seriesOrder: 32
---

## 반응형 Effect의 생명주기

Effect의 생명주기를 올바르게 이해하면 많은 버그를 피할 수 있습니다.

### Effect의 생명주기는 컴포넌트와 다릅니다

**컴포넌트:**

- 마운트 (Mount)
- 업데이트 (Update)
- 언마운트 (Unmount)

**Effect:**

- 동기화 시작 (Start synchronizing)
- 동기화 중지 (Stop synchronizing)

### 예제: 채팅방

Effect 생명주기를 구체적인 예제로 살펴봅시다.

```jsx
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to {roomId}!</h1>;
}
```

**생명주기:**

1. `roomId = "general"`로 마운트
   - Effect: `general` 방에 연결

2. `roomId = "travel"`로 업데이트
   - Effect 클린업: `general` 방 연결 해제
   - Effect: `travel` 방에 연결

3. 컴포넌트 언마운트
   - Effect 클린업: `travel` 방 연결 해제

### 의존성 배열의 중요성

Effect가 사용하는 모든 반응형 값을 의존성에 포함해야 합니다.

```jsx
// ❌ 경고: roomId가 의존성에 없음
useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => connection.disconnect();
}, []); // 🔴 React Hook useEffect has a missing dependency: 'roomId'

// ✅ 올바름
useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => connection.disconnect();
}, [roomId]);
```

### 각 Effect는 독립적인 동기화 프로세스

관련 없는 로직은 별도의 Effect로 분리하세요.

```jsx
// ❌ 나쁨: 관련 없는 로직을 하나의 Effect에
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
}

// ✅ 좋음: 각 동기화 프로세스를 별도 Effect로
function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  // ...
}
```

### Effect는 반응형 값에 "반응"합니다

Effect는 props, state 등 반응형 값이 변경될 때마다 재실행됩니다.

```jsx
function ChatRoom({ roomId, serverUrl }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);
  // ...
}
```

**반응형 값:**

- Props
- State
- 컴포넌트 본문에 직접 선언된 변수와 함수

**비반응형 값:**

- 컴포넌트 외부의 값
- `ref.current` (의도적으로 변경 가능)

### 빈 의존성 배열 `[]`

빈 배열은 "한 번만 실행"을 의미하지만, 조심해서 사용해야 합니다.

```jsx
useEffect(() => {
  const connection = createConnection(serverUrl, roomId);
  connection.connect();
  return () => connection.disconnect();
}, []); // 마운트 시에만 실행
```

**의미:** "컴포넌트가 마운트될 때만 실행"

⚠️ **주의:** 반응형 값을 사용하는데 의존성에 없으면 버그 발생!
