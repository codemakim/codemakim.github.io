---
title: "[React 기초 4-3/9] Effect로 동기화하기"
date: "2025-08-03"
description: "외부 시스템과 동기화하는 useEffect의 개념과 작성법"
tags: ["React", "학습", "Effect", "초급"]
series: "React 기초"
seriesOrder: 29
---

# Effect로 동기화하기

## Effect란 무엇인가?

React 컴포넌트는 기본적으로 순수 함수다. 같은 입력(props, state)에 대해 항상 같은 JSX를 반환해야 한다. 하지만 때로는 외부 세계와 상호작용해야 할 때가 있다.

**Effect는 렌더링 자체에 의해 발생하는 부작용(side effect)을 명시한다.** 특정 이벤트가 아니라, 렌더링 후에 실행되어야 하는 코드를 작성할 때 사용한다.

### Effect가 필요한 경우

일부 컴포넌트는 **외부 시스템과 동기화**해야 한다.

**예시:**

- React가 아닌 위젯 제어 (jQuery 플러그인, 지도 라이브러리 등)
- 서버 연결 설정 (WebSocket, SSE 등)
- 분석 로그 전송 (페이지 조회 추적 등)
- 브라우저 API 사용 (타이머, 전역 이벤트 리스너 등)

### Effect 작성 3단계

Effect를 작성하는 과정은 3단계로 나뉜다.

#### 1단계: Effect 선언하기

```jsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // 여기에 코드 작성
  });
  
  return <div />;
}
```

이 Effect는 **매 렌더링 후에 실행**된다.

#### 2단계: Effect 의존성 지정하기

대부분의 Effect는 매 렌더링마다 실행될 필요가 없다. 특정 값이 변경될 때만 실행되어야 한다. 이를 제어하기 위해 의존성 배열을 사용한다.

```jsx
// 매 렌더링 후 실행
useEffect(() => {
  // 코드
});

// 마운트 시에만 실행 (빈 배열)
useEffect(() => {
  // 코드
}, []);

// a나 b가 변경될 때만 실행
useEffect(() => {
  // 코드
}, [a, b]);
```

**의존성 배열의 의미:**

- **생략**: 매 렌더링 후 실행
- **`[]`**: 컴포넌트가 마운트될 때만 실행
- **`[a, b]`**: 마운트 시 + `a`나 `b`가 변경될 때 실행

#### 3단계: 필요하면 클린업 추가하기

일부 Effect는 정리(cleanup) 작업이 필요하다. 예를 들어:

- 연결을 설정했다면 → 연결을 끊어야 함
- 구독을 시작했다면 → 구독을 취소해야 함
- 타이머를 시작했다면 → 타이머를 정리해야 함

클린업 함수를 반환하면 React가 적절한 시점에 호출한다.

```jsx
useEffect(() => {
  // 설정
  const connection = createConnection();
  connection.connect();
  
  // 클린업
  return () => {
    connection.disconnect();
  };
}, []);
```

**클린업이 실행되는 시점:**

- 컴포넌트가 언마운트될 때
- Effect가 재실행되기 직전 (의존성이 변경되었을 때)

### 예제: 채팅 연결

Effect를 사용하여 채팅 서버에 연결하는 실전 예제를 살펴본다.

```jsx
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');
  const [roomId, setRoomId] = useState('general');

  useEffect(() => {
    // 연결 설정
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    
    // 클린업
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <p>Welcome to the {roomId} room!</p>
    </>
  );
}
```

**동작 과정:**

1. **컴포넌트 마운트** → Effect 실행 → 서버 연결
2. **`serverUrl` 또는 `roomId` 변경** → 클린업 실행 (기존 연결 해제) → Effect 재실행 (새 연결)
3. **컴포넌트 언마운트** → 클린업 실행 (연결 해제)

이렇게 하면 서버 URL이나 방 ID가 변경될 때마다 이전 연결을 끊고 새 연결을 시작한다.

### 개발 모드에서 Effect가 두 번 실행되는 이유

개발 환경에서 Effect가 두 번 실행되는 것을 본 적이 있는가? 이것은 버그가 아니다.

**Strict Mode**에서 React는 컴포넌트를 **두 번** 마운트한다:

```
마운트 → 클린업 → 재마운트
```

**왜 이렇게 하나?**

클린업 로직이 제대로 작동하는지 테스트하기 위해서다. 만약 클린업을 제대로 구현하지 않았다면, 이 과정에서 버그가 드러난다.

```jsx
useEffect(() => {
  console.log('연결 중...');
  const connection = createConnection();
  connection.connect();
  
  return () => {
    console.log('연결 해제 중...');
    connection.disconnect();
  };
}, []);
```

**개발 모드 콘솔 출력:**

```
연결 중...
연결 해제 중...
연결 중...
```

**프로덕션 모드 콘솔 출력:**

```
연결 중...
```

이 동작 덕분에 클린업이 필요한데 구현하지 않은 경우를 쉽게 발견할 수 있다.

### Effect가 필요하지 않은 경우

Effect를 남용하면 코드가 복잡해지고 느려진다. Effect 없이 해결할 수 있는지 항상 확인해야 한다.

#### 1. 렌더링을 위한 데이터 변환

Effect로 state를 업데이트하면 불필요한 렌더링이 두 번 발생한다.

```jsx
// 나쁜 예: Effect로 계산
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const [fullName, setFullName] = useState('');

useEffect(() => {
  setFullName(firstName + ' ' + lastName);
}, [firstName, lastName]);

// 좋은 예: 렌더링 중 계산
const [firstName, setFirstName] = useState('');
const [lastName, setLastName] = useState('');
const fullName = firstName + ' ' + lastName;
```

**왜 나쁜가?**

첫 번째 방법은:
1. 렌더링 → `firstName`이나 `lastName`이 이전 값
2. Effect 실행 → `setFullName` 호출
3. 다시 렌더링 → `fullName`이 새 값

두 번째 방법은:
1. 렌더링 → 모든 값이 최신

#### 2. 사용자 이벤트 처리

사용자 행동에 대한 응답은 이벤트 핸들러에서 처리해야 한다.

```jsx
// 나쁜 예: Effect로 처리
function Form() {
  const [submitted, setSubmitted] = useState(false);
  
  useEffect(() => {
    if (submitted) {
      post('/api/register', { email });
    }
  }, [submitted, email]);
  
  function handleSubmit() {
    setSubmitted(true);
  }
}

// 좋은 예: 이벤트 핸들러에서 처리
function Form() {
  function handleSubmit() {
    post('/api/register', { email });
  }
}
```

**차이점:**

- **이벤트 핸들러**: 특정 상호작용에 대한 응답
- **Effect**: 동기화가 필요할 때

### 실전 예제: 타이틀 업데이트

페이지 제목을 현재 메시지 수로 업데이트하는 예제다.

```jsx
import { useState, useEffect } from 'react';

export default function ChatRoom() {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    document.title = `You have ${messages.length} messages`;
  }, [messages.length]);

  return (
    <div>
      <h1>Welcome to chat!</h1>
      <MessageList messages={messages} />
      <MessageInput onSend={msg => setMessages([...messages, msg])} />
    </div>
  );
}
```

**동작:**

- `messages` 배열이 변경될 때마다 브라우저 탭 제목이 업데이트된다
- 외부 시스템(브라우저 API)과 동기화하므로 Effect가 적절하다

### Vue와 비교

```html
<!-- Vue: onMounted, onUnmounted, watch -->
<script setup>
import { ref, onMounted, onUnmounted, watch } from 'vue'

const roomId = ref('general')

onMounted(() => {
  const connection = createConnection(roomId.value)
  connection.connect()
  
  onUnmounted(() => {
    connection.disconnect()
  })
})

watch(roomId, (newId, oldId) => {
  // roomId가 변경되면 재연결
  connection.disconnect()
  connection = createConnection(newId)
  connection.connect()
})
</script>
```

```jsx
// React: useEffect
import { useState, useEffect } from 'react'

function ChatRoom() {
  const [roomId, setRoomId] = useState('general')

  useEffect(() => {
    const connection = createConnection(roomId)
    connection.connect()
    
    return () => {
      connection.disconnect()
    }
  }, [roomId])
}
```

**차이점:**

- **Vue**: `onMounted`/`onUnmounted` + `watch`를 분리해서 사용
- **React**: `useEffect` 하나로 마운트, 업데이트, 언마운트를 모두 처리

React의 접근 방식은 "동기화"에 집중한다. "이 Effect는 `roomId`와 동기화된다"라고 선언하면, React가 알아서 마운트, 업데이트, 언마운트 시점에 적절히 실행한다.

## 정리

- Effect는 렌더링 후에 실행되는 부작용을 명시한다
- 외부 시스템과 동기화할 때 사용한다
- 의존성 배열로 언제 실행할지 제어한다
- 클린업 함수로 정리 작업을 수행한다
- 개발 모드에서는 클린업 테스트를 위해 두 번 실행된다
- 렌더링을 위한 계산이나 이벤트 처리에는 Effect를 사용하지 않는다
