---
title: "[React 테스팅 2/3] RTL - 사용자 관점 테스트"
date: "2025-09-15"
description: "RTL의 핵심 철학과 getByRole을 우선 사용하는 이유를 이해한다"
tags: ["Testing", "React", "중급", "프론트엔드"]
series: "React 테스팅"
seriesOrder: 2
---

# React Testing Library: 사용자 행동을 신호로 만든다

RTL은 React를 테스트하는 도구라기보다 DOM을 통해 사용자 행동을 검증하는 프레임이다.
목표는 컴포넌트의 내부 구현을 고정하는 것이 아니라, 사용자 경험의 계약을 고정하는 것이다.

## RTL이 주는 신호의 정체

RTL 테스트가 강한 이유는 다음 두 신호를 동시에 얻기 때문이다.

- **DOM 의미(semantics)**: role, label, name을 통해 화면 요소의 의미를 검증한다
- **행동 후 결과**: 클릭/입력 후 화면이 어떻게 변하는지를 검증한다

이 둘은 리팩토링 내성을 만든다. className이나 컴포넌트 트리 형태가 바뀌어도, 의미와 행동이 유지되면 테스트가 유지된다.

## selector는 “안정성의 측정 지표”다

테스트는 결국 selector 선택 문제다. selector의 의미 수준이 높을수록, 테스트는 덜 깨진다.

| 우선순위 | 방법 | 의미 수준 | 깨짐 위험 |
| --- | --- | --- | --- |
| 1 | `getByRole` | 높다 | 낮다 |
| 2 | `getByLabelText` | 높다 | 낮다 |
| 3 | `getByPlaceholderText` | 중간 | 중간 |
| 4 | `getByText` | 중간 | 중간 |
| 5 | `getByAltText` | 중간 | 중간 |
| 6 | `getByTestId` | 낮다 | 높다 |

테스트가 자주 깨진다면, 대개 `testid`가 많거나, role/label이 없는 UI를 억지로 테스트하고 있을 가능성이 높다.

## 설치와 최소 셋업

```bash
npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

```ts
// setupTests.ts
import "@testing-library/jest-dom";
```

Jest 설정에서 `setupFilesAfterEnv`로 연결한다.

## 최소 예제: 버튼 클릭은 “행동→결과”로만 본다

```tsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

function Counter() {
  const [count, setCount] = React.useState(0);
  return (
    <div>
      <p aria-label="count">{count}</p>
      <button onClick={() => setCount((c) => c + 1)}>increment</button>
    </div>
  );
}

test("increment를 클릭하면 count가 1 증가한다", async () => {
  const user = userEvent.setup();
  render(<Counter />);

  await user.click(screen.getByRole("button", { name: /increment/i }));
  expect(screen.getByLabelText("count")).toHaveTextContent("1");
});
```

내부 state를 직접 확인하지 않는다. 사용자가 관측 가능한 결과만 확인한다.

## 비동기 UI 테스트: 시간 대기가 아니라 “완료 조건”을 기다린다

비동기 테스트가 불안정한 이유는 대부분 다음 때문이다.

- 데이터 로딩 완료 조건을 잡지 못하고 “대충 기다린다”
- UI가 여러 단계로 갱신되는데 한 단계만 기다린다

권장 순서는 다음이다.

1. `findBy*`로 “나올 때까지 기다리기”
2. `waitForElementToBeRemoved`로 “사라질 때까지 기다리기”
3. 최후에 `waitFor`로 “조건을 만족할 때까지 기다리기”

```tsx
test("로딩이 끝나면 사용자 이름이 표시된다", async () => {
  render(<UserProfile userId="1" />);

  // 로딩이 사라지는 조건을 잡는다
  await waitForElementToBeRemoved(() => screen.queryByText(/loading/i));

  // 화면 결과를 기다린다
  expect(await screen.findByRole("heading", { name: /john/i })).toBeInTheDocument();
});
```

## 네트워크 mocking: fetch를 직접 mock하지 않고 MSW로 표준화한다

`global.fetch = jest.fn()`은 빠르지만, 테스트가 네트워크의 형태를 잃는다.
MSW는 “요청 단위”로 관측 가능성을 만든다.

- 어떤 URL로
- 어떤 method로
- 어떤 payload로
- 어떤 응답을 받는지

이 정보가 테스트 실패 시 원인을 좁힌다.

```ts
// tests/msw/server.ts
import { setupServer } from "msw/node";
import { http, HttpResponse } from "msw";

export const server = setupServer(
  http.get("/api/users/:id", ({ params }) => {
    if (params.id === "404") return HttpResponse.json({ message: "not found" }, { status: 404 });
    return HttpResponse.json({ id: params.id, name: "John" });
  }),
);
```

```ts
// tests/setupTests.ts
import "@testing-library/jest-dom";
import { server } from "./msw/server";

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

이 구조의 장점은 “컴포넌트 테스트”가 네트워크 경계를 유지한 채로 결정성을 얻는다는 점이다.

## Provider 경계: renderWithProviders로 테스트의 입력을 통일한다

실무에서는 라우터, QueryClient, 전역 상태가 테스트를 복잡하게 만든다.
입력을 통일하면 테스트의 변동성이 줄어든다.

```tsx
// tests/renderWithProviders.tsx
import { render } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { MemoryRouter } from "react-router-dom";

export function renderWithProviders(ui: React.ReactElement, { route = "/" } = {}) {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { retry: false } },
  });

  return render(
    <QueryClientProvider client={queryClient}>
      <MemoryRouter initialEntries={[route]}>{ui}</MemoryRouter>
    </QueryClientProvider>,
  );
}
```

여기서 중요한 기준은 다음이다.

- 테스트마다 `QueryClient`는 새로 만든다(캐시 누수 방지)
- Router는 `MemoryRouter`를 쓴다(브라우저 의존 제거)

## 흔한 함정과 디버깅

### 1) testid가 늘어난다

testid가 늘어나는 이유는 UI가 의미를 잃었기 때문이다. 접근 가능한 role/label을 먼저 만드는 편이 맞다.

### 2) waitFor로 모든 문제를 덮는다

waitFor 남발은 flaky를 만든다. “무엇을 기다리는가”를 문장으로 말할 수 없으면, 조건이 잘못된 것이다.

### 3) 구현 세부사항을 검증한다

함수 호출 횟수, state 내부 구조, hook 호출 순서를 검증하면 리팩토링이 불가능해진다.
사용자가 관측하는 계약만 남겨야 한다.

## Vue Test Utils와 비교

| 관점 | Vue Test Utils | RTL |
| --- | --- | --- |
| 접근 | 컴포넌트 wrapper 중심 | DOM 의미(role/label) 중심 |
| 안정성 | 구조/구현 변경에 영향 | 의미가 유지되면 안정 |
| 추천 대상 | 컴포넌트 내부 계약 검증 | 사용자 경험 계약 검증 |

두 도구의 차이는 기술이 아니라 “무엇을 고정할 것인가”의 선택이다.

## 학습 체크리스트

- [ ] `getByRole`을 최우선으로 쓰는 이유를 설명할 수 있다
- [ ] selector 의미 수준이 테스트 안정성을 좌우한다는 점을 설명할 수 있다
- [ ] 비동기 테스트에서 시간 대기 대신 완료 조건을 설계할 수 있다
- [ ] 네트워크 mocking을 MSW로 표준화하는 이유를 설명할 수 있다
- [ ] Provider 경계를 render helper로 통일해 테스트 변동성을 줄일 수 있다
