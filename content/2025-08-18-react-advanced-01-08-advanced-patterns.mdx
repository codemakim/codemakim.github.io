---
title: "[React Router 8/9] React Router - 고급 패턴"
date: "2025-08-22"
description: "라우트 구성 분리, Breadcrumbs, Scroll Restoration, Modal Routes"
tags: ["React", "고급", "프론트엔드"]
series: "React 라이브러리"
seriesOrder: 12
---

# React Router 가이드 - 고급 패턴

> React Router v6를 기반으로 한 라우팅 학습 자료  
> 출처: [React Router Documentation](https://reactrouter.com/)

---

## 고급 패턴이란?

실무 프로젝트에서 자주 사용되는 라우팅 패턴들이다. 코드 구조화, 사용자 경험 개선, 복잡한 네비게이션 처리 등을 다룬다.

## Route 구성 분리

### 1. 라우트 설정을 별도 파일로 관리

프로젝트가 커지면 라우트 설정을 별도 파일로 분리하여 관리한다:

```jsx
// routes/index.jsx
import { lazy } from "react";

const Home = lazy(() => import("../pages/Home"));
const About = lazy(() => import("../pages/About"));
const Dashboard = lazy(() => import("../pages/Dashboard"));

export const routes = [
  {
    path: "/",
    element: <Layout />,
    children: [
      { index: true, element: <Home /> },
      { path: "about", element: <About /> },
      {
        path: "dashboard",
        element: (
          <ProtectedRoute>
            <Dashboard />
          </ProtectedRoute>
        ),
      },
    ],
  },
];

// App.jsx
import { useRoutes } from "react-router-dom";
import { routes } from "./routes";

export default function App() {
  const element = useRoutes(routes);
  return element;
}
```

**장점**:
- 라우트 설정을 한 곳에서 관리한다
- 조건부로 라우트를 추가/제거하기 쉽다
- 권한별로 라우트를 분리할 수 있다

## Breadcrumbs (빵 부스러기 네비게이션)

현재 위치를 계층적으로 표시한다:

```jsx
import { useMatches, Link } from "react-router-dom";

function Breadcrumbs() {
  const matches = useMatches();

  // handle.crumb이 있는 라우트만 필터링
  const crumbs = matches
    .filter((match) => match.handle?.crumb)
    .map((match) => match.handle.crumb(match.data));

  return (
    <nav>
      {crumbs.map((crumb, index) => (
        <span key={index}>
          {index > 0 && " > "}
          {crumb}
        </span>
      ))}
    </nav>
  );
}

// 라우트 설정에 handle 추가
<Route
  path="/users/:userId"
  element={<User />}
  handle={{
    crumb: (data) => <Link to={`/users/${data.userId}`}>{data.name}</Link>,
  }}
/>
```

**사용 예시**:
```
Home > Users > John Doe
```

## Scroll Restoration (스크롤 복원)

페이지 전환 시 스크롤을 최상단으로 이동한다:

```jsx
import { useEffect } from "react";
import { useLocation } from "react-router-dom";

function ScrollToTop() {
  const { pathname } = useLocation();

  useEffect(() => {
    window.scrollTo(0, 0);
  }, [pathname]); // 경로 변경 시마다 실행

  return null;
}

// App.jsx에 추가
<BrowserRouter>
  <ScrollToTop />
  <Routes>{/* ... */}</Routes>
</BrowserRouter>
```

**문제 해결**: 새 페이지로 이동했는데 이전 페이지의 스크롤 위치가 유지되는 문제를 방지한다.

### 조건부 스크롤 복원

특정 경로에서만 스크롤 복원을 적용한다:

```jsx
function ScrollToTop() {
  const { pathname } = useLocation();

  useEffect(() => {
    // /posts 페이지에서는 스크롤 유지
    if (pathname.startsWith("/posts")) {
      return;
    }
    
    window.scrollTo(0, 0);
  }, [pathname]);

  return null;
}
```

## Route-based Code Splitting

라우트 단위로 코드를 분할하여 성능을 최적화한다:

```jsx
import { lazy, Suspense } from "react";

const routes = [
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Home />,
      },
      {
        path: "admin",
        element: (
          <Suspense fallback={<Loading />}>
            <AdminLayout />
          </Suspense>
        ),
        children: [
          {
            index: true,
            element: lazy(() => import("./pages/admin/Dashboard")),
          },
          {
            path: "users",
            element: lazy(() => import("./pages/admin/Users")),
          },
        ],
      },
    ],
  },
];
```

**효과**:
- 초기 번들 크기 감소
- 사용하지 않는 페이지는 로드하지 않음
- 관리자 페이지는 관리자만 다운로드

## Modal Routes

URL은 변경하되 배경 페이지는 유지하는 모달 패턴:

```jsx
function App() {
  const location = useLocation();
  const state = location.state;

  return (
    <>
      {/* 메인 라우트 */}
      <Routes location={state?.backgroundLocation || location}>
        <Route path="/" element={<Home />} />
        <Route path="/gallery" element={<Gallery />} />
      </Routes>

      {/* 모달 라우트 (배경 페이지 위에 표시) */}
      {state?.backgroundLocation && (
        <Routes>
          <Route path="/img/:id" element={<ImageModal />} />
        </Routes>
      )}
    </>
  );
}

// Gallery 컴포넌트
function Gallery() {
  const location = useLocation();

  return (
    <div>
      {images.map((img) => (
        <Link
          key={img.id}
          to={`/img/${img.id}`}
          state={{ backgroundLocation: location }}
        >
          <img src={img.thumbnail} alt={img.title} />
        </Link>
      ))}
    </div>
  );
}

// Modal 컴포넌트
function ImageModal() {
  const navigate = useNavigate();
  const { id } = useParams();

  return (
    <div className="modal-overlay" onClick={() => navigate(-1)}>
      <div className="modal-content">
        <img src={`/images/${id}.jpg`} alt="" />
        <button onClick={() => navigate(-1)}>Close</button>
      </div>
    </div>
  );
}
```

**동작**:
1. Gallery에서 이미지 클릭
2. `/img/123` URL로 변경
3. Gallery는 그대로 두고 위에 모달 표시
4. 뒤로가기 시 모달만 닫힘 (Gallery 유지)

## 라우트 기반 메타 태그

각 페이지의 메타 태그를 동적으로 변경한다:

```jsx
import { useEffect } from "react";
import { useLocation } from "react-router-dom";

const pageTitles = {
  "/": "Home - My App",
  "/about": "About Us - My App",
  "/dashboard": "Dashboard - My App",
};

function App() {
  const location = useLocation();

  useEffect(() => {
    const title = pageTitles[location.pathname] || "My App";
    document.title = title;
  }, [location]);

  return <Routes>{/* ... */}</Routes>;
}
```

## 실전 팁

### 1. 라우트 분리 전략

```jsx
// routes/publicRoutes.jsx - 공개 페이지
export const publicRoutes = [
  { path: "/", element: <Home /> },
  { path: "/about", element: <About /> },
];

// routes/authRoutes.jsx - 인증 필요
export const authRoutes = [
  { path: "/profile", element: <Profile /> },
  { path: "/settings", element: <Settings /> },
];

// routes/adminRoutes.jsx - 관리자 전용
export const adminRoutes = [
  { path: "/admin", element: <AdminDashboard /> },
  { path: "/admin/users", element: <UserManagement /> },
];
```

### 2. 라우트 가드를 객체에 포함

```jsx
export const routes = [
  { path: "/", element: <Home />, public: true },
  { path: "/dashboard", element: <Dashboard />, requiresAuth: true },
  { path: "/admin", element: <Admin />, requiresRole: "admin" },
];

function App() {
  return useRoutes(
    routes.map((route) => ({
      ...route,
      element: route.requiresAuth ? (
        <ProtectedRoute requiredRole={route.requiresRole}>
          {route.element}
        </ProtectedRoute>
      ) : (
        route.element
      ),
    }))
  );
}
```

---
