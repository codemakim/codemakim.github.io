---
title: "[React 기초 3-7/8] Reducer와 Context로 확장하기"
date: "2025-07-29"
description: "Reducer와 Context를 결합해 확장 가능한 State 관리 시스템을 구축하는 방법을 학습한다"
tags: ["React", "학습", "Vue", "초급", "프론트엔드"]
series: "React 기초"
seriesOrder: 25
---

# React 학습 가이드 - Reducer와 Context로 확장하기

## Reducer와 Context로 확장하기

Reducer와 Context를 결합하면 대규모 애플리케이션에서도 유지보수가 쉬운 state 관리 시스템을 만들 수 있다.

앞서 Reducer와 Context를 각각 학습했다. 이제 두 가지를 결합하는 방법을 알아본다.

> 참고: 기초 개념은 [Reducer로 State 로직 추출하기](/posts/2025-07-27-react-learning-03-05-reducer)와 [Context로 데이터 깊이 전달하기](/posts/2025-07-28-react-learning-03-06-context)를 먼저 보는 것이 좋다.

### 통합 패턴의 핵심

세 가지 핵심 요소를 결합한다:

1. **Reducer로 복잡한 state 관리** - state 업데이트 로직을 한 곳에 모은다
2. **Context로 깊은 트리에 전달** - props drilling 없이 깊은 곳까지 전달한다
3. **커스텀 Hook으로 사용 편의성 향상** - 사용하기 쉬운 인터페이스를 제공한다

### 왜 이 패턴을 사용하나?

단순히 `useState`와 props로 state를 관리하면 두 가지 문제가 생긴다:

**문제 1: Props Drilling**
```jsx
// App이 최상단에서 state를 가지고
// 여러 단계를 거쳐 전달해야 함
<App>
  <TaskBoard tasks={tasks} onUpdate={handleUpdate}>
    <TaskColumn tasks={tasks} onUpdate={handleUpdate}>
      <TaskCard task={task} onUpdate={handleUpdate} />
    </TaskColumn>
  </TaskBoard>
</App>
```

**문제 2: 흩어진 업데이트 로직**
```jsx
// 여러 컴포넌트에 같은 로직이 반복됨
function AddTask() {
  const handleAdd = () => {
    setTasks([...tasks, newTask]); // 여기도
  };
}

function EditTask() {
  const handleEdit = () => {
    setTasks(tasks.map(t => ...)); // 여기도
  };
}
```

**해결: Reducer + Context**
```jsx
// 로직은 reducer에 집중
// 어디서든 dispatch로 접근
function AddTask() {
  const dispatch = useTasksDispatch();
  const handleAdd = () => dispatch({ type: 'added', ... });
}
```

### 파일 구조

코드를 어떻게 조직하면 좋을까?

```
src/
  contexts/
    TasksContext.js       # Context 정의 및 Hook
    TasksProvider.js      # Provider 컴포넌트
  components/
    TaskList.js
    AddTask.js
    TaskItem.js
  App.js
```

### 구현 예제

실제로 어떻게 구현하는지 단계별로 살펴본다.

#### 1단계: Reducer 정의

```tsx
// contexts/TasksContext.tsx
type Action =
  | { type: 'added'; id: number; text: string }
  | { type: 'changed'; id: number; text: string; done: boolean }
  | { type: 'deleted'; id: number };

type Task = { id: number; text: string; done: boolean };

function tasksReducer(state: Task[], action: Action): Task[] {
  switch (action.type) {
    case 'added':
      return [...state, { id: action.id, text: action.text, done: false }];
    case 'changed':
      return state.map(t => 
        t.id === action.id 
          ? { ...t, text: action.text, done: action.done } 
          : t
      );
    case 'deleted':
      return state.filter(t => t.id !== action.id);
    default:
      return state;
  }
}
```

#### 2단계: Context 생성 (값과 dispatch 분리)

```tsx
import { createContext, useContext, useReducer } from 'react';

// 값을 전달하는 Context
const TasksContext = createContext<Task[] | undefined>(undefined);

// dispatch를 전달하는 Context (성능 최적화)
const TasksDispatchContext = createContext<React.Dispatch<Action> | undefined>(undefined);
```

왜 두 개로 분리하나? 

- `TasksContext`를 사용하는 컴포넌트는 tasks 값이 변경될 때만 리렌더링된다
- `TasksDispatchContext`만 사용하는 컴포넌트는 tasks 값이 변경되어도 리렌더링되지 않는다

#### 3단계: Provider 컴포넌트

```tsx
export function TasksProvider({ children }: { children: React.ReactNode }) {
  const [tasks, dispatch] = useReducer(tasksReducer, []);
  
  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>
        {children}
      </TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}
```

#### 4단계: 커스텀 Hook (안전하게 사용하기)

```tsx
export function useTasks() {
  const ctx = useContext(TasksContext);
  if (!ctx) {
    throw new Error('useTasks must be used within TasksProvider');
  }
  return ctx;
}

export function useTasksDispatch() {
  const ctx = useContext(TasksDispatchContext);
  if (!ctx) {
    throw new Error('useTasksDispatch must be used within TasksProvider');
  }
  return ctx;
}
```

왜 이렇게 하나?

- Provider 없이 사용하면 명확한 에러 메시지를 보여준다
- `undefined` 체크를 컴포넌트마다 할 필요가 없다

#### 5단계: 컴포넌트에서 사용

```tsx
// App.tsx
function App() {
  return (
    <TasksProvider>
      <TaskList />
      <AddTask />
    </TasksProvider>
  );
}

// TaskList.tsx
function TaskList() {
  const tasks = useTasks(); // 값만 읽기
  
  return (
    <ul>
      {tasks.map(task => (
        <TaskItem key={task.id} task={task} />
      ))}
    </ul>
  );
}

// AddTask.tsx
function AddTask() {
  const dispatch = useTasksDispatch(); // dispatch만 사용 (리렌더링 안됨)
  const [text, setText] = useState('');
  
  function handleAdd() {
    dispatch({ 
      type: 'added', 
      id: Date.now(), 
      text 
    });
    setText('');
  }
  
  return (
    <div>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={handleAdd}>Add</button>
    </div>
  );
}

// TaskItem.tsx
function TaskItem({ task }: { task: Task }) {
  const dispatch = useTasksDispatch();
  
  return (
    <li>
      <input
        type="checkbox"
        checked={task.done}
        onChange={e => dispatch({
          type: 'changed',
          id: task.id,
          text: task.text,
          done: e.target.checked
        })}
      />
      <span>{task.text}</span>
      <button onClick={() => dispatch({ type: 'deleted', id: task.id })}>
        Delete
      </button>
    </li>
  );
}
```

### 장점

- **관심사 분리**: state 로직(reducer)과 UI(컴포넌트)가 명확히 분리된다
- **재사용성**: 다른 컴포넌트에서 쉽게 사용할 수 있다
- **테스트 용이**: reducer는 순수 함수라 테스트하기 쉽다
- **확장성**: 앱이 커져도 관리하기 쉽다
- **성능**: dispatch만 사용하는 컴포넌트는 리렌더링되지 않는다

### 언제 useReducer/Context를 쓰나?

모든 상황에 사용하는 것은 아니다. 적절한 상황을 판단해야 한다.

**권장하는 경우:**
- 업데이트 로직이 다수의 핸들러로 흩어져 복잡해질 때
- 여러 컴포넌트가 동일한 state/로직을 공유해야 할 때
- state 업데이트 로직이 복잡해서 한 곳에서 관리하고 싶을 때
- 깊은 컴포넌트 트리에서 props drilling이 발생할 때

**권장하지 않는 경우:**
- 단일 컴포넌트에서만 사용하는 단순한 state (`useState`가 더 간단)
- state가 자주 변경되는데 많은 컴포넌트가 구독하는 경우 (리렌더링 폭발)
- 전역 Context 하나에 모든 state를 몰아넣는 경우

### Context 설계 패턴

성능과 유지보수성을 고려한 설계 패턴이다.

**1. 값과 dispatch 분리**
```tsx
// 나쁨: 하나의 Context
const TasksContext = createContext({ tasks, dispatch });

// 좋음: 두 개로 분리
const TasksContext = createContext(tasks);
const TasksDispatchContext = createContext(dispatch);
```

**2. Provider를 도메인별로 분리**
```tsx
// 나쁨: 하나의 거대한 Context
<AppContext.Provider value={{ user, tasks, theme, ... }}>

// 좋음: 기능별로 분리
<AuthProvider>
  <ThemeProvider>
    <TasksProvider>
      <App />
    </TasksProvider>
  </ThemeProvider>
</AuthProvider>
```

**3. 커스텀 Hook 제공**
```tsx
// 나쁨: 직접 useContext 사용
const tasks = useContext(TasksContext);

// 좋음: 커스텀 Hook으로 추상화
const tasks = useTasks(); // 에러 처리 포함
```

### 성능 최적화 팁

**1. Context 값을 안정적으로 유지**
```tsx
// 나쁨: 매 렌더마다 새 객체 생성
<TasksContext.Provider value={{ tasks, dispatch }}>

// 좋음: 분리하거나 useMemo 사용
const value = useMemo(() => ({ tasks, dispatch }), [tasks]);
<TasksContext.Provider value={value}>
```

**2. React.memo로 리렌더링 방지**
```tsx
const TaskItem = React.memo(function TaskItem({ task }) {
  // task가 변경될 때만 리렌더링
});
```

**3. 파생 값은 useMemo**
```tsx
function TaskStats() {
  const tasks = useTasks();
  
  const completedCount = useMemo(
    () => tasks.filter(t => t.done).length,
    [tasks]
  );
  
  return <div>Completed: {completedCount}</div>;
}
```

### TypeScript 안전성

**Discriminated Union으로 액션 타입 안전성 확보**
```tsx
type Action =
  | { type: 'added'; id: number; text: string }
  | { type: 'changed'; id: number; text: string; done: boolean }
  | { type: 'deleted'; id: number };

// TypeScript가 자동으로 type에 따라 필요한 필드를 체크
dispatch({ type: 'added', text: 'New' }); // OK
dispatch({ type: 'added' }); // Error: text가 없음
```

**Context 기본값을 undefined로 설정**
```tsx
const TasksContext = createContext<Task[] | undefined>(undefined);

export function useTasks() {
  const ctx = useContext(TasksContext);
  if (!ctx) {
    throw new Error('useTasks must be used within TasksProvider');
  }
  return ctx; // 여기서는 Task[]로 타입이 좁혀짐
}
```

### 테스트 전략

**Reducer 테스트 (순수 함수)**
```tsx
describe('tasksReducer', () => {
  it('should add a task', () => {
    const state = [];
    const action = { type: 'added', id: 1, text: 'Test' };
    const newState = tasksReducer(state, action);
    
    expect(newState).toEqual([{ id: 1, text: 'Test', done: false }]);
  });
});
```

**컴포넌트 테스트 (통합)**
```tsx
function renderWithProvider(component) {
  return render(
    <TasksProvider>
      {component}
    </TasksProvider>
  );
}

test('should add a task', () => {
  renderWithProvider(<App />);
  // 테스트 로직...
});
```

### 마이그레이션 체크리스트

기존 코드를 Reducer + Context 패턴으로 변경할 때:

1. 액션 타입 정의 (type, payload 구조)
2. reducer 함수 작성 및 테스트
3. `useState`를 `useReducer`로 교체
4. Context와 Provider 생성
5. 커스텀 Hook 제공 (`useTasks`, `useTasksDispatch`)
6. 컴포넌트에서 props 대신 Hook 사용

### 안티패턴 (피해야 할 것들)

**1. Reducer에서 부작용 실행**
```tsx
// 나쁨
function tasksReducer(state, action) {
  if (action.type === 'added') {
    fetch('/api/tasks', { method: 'POST', ... }); // 부작용
    return [...state, action.task];
  }
}

// 좋음: 컴포넌트나 useEffect에서 실행
function AddTask() {
  const dispatch = useTasksDispatch();
  
  async function handleAdd() {
    await fetch('/api/tasks', { method: 'POST', ... });
    dispatch({ type: 'added', ... });
  }
}
```

**2. 거대한 단일 Context**
```tsx
// 나쁨: 하나에 다 넣기
<AppContext.Provider value={{ user, tasks, theme, settings, ... }}>

// 좋음: 도메인별 분리
<AuthProvider>
  <TasksProvider>
    <ThemeProvider>
```

**3. 가변 데이터 반환**
```tsx
// 나쁨: 원본 수정
function reducer(state, action) {
  state.push(action.task); // 원본 수정
  return state;
}

// 좋음: 새 배열 반환
function reducer(state, action) {
  return [...state, action.task];
}
```

### 확장 가능한 파일 구조

프로젝트가 커지면 다음과 같이 구조화한다:

```
src/
  features/
    tasks/
      contexts/
        TasksContext.tsx      # Context 정의
      components/
        TaskList.tsx
        AddTask.tsx
        TaskItem.tsx
      hooks/
        useTaskStats.ts       # 커스텀 Hook
      reducers/
        tasksReducer.ts       # Reducer 로직
      types.ts                # 타입 정의
  app/
    App.tsx
```

이렇게 하면:
- 관련 코드가 한 곳에 모인다
- 다른 기능과 독립적이다
- 테스트하기 쉽다
- 필요하면 통째로 다른 프로젝트로 옮길 수 있다
