---
title: "[React 기초 3-7/8] Reducer와 Context로 확장하기"
date: "2025-07-29"
description: "Reducer와 Context를 결합해 확장 가능한 State 관리 시스템을 구축하는 방법을 학습한다"
tags: ["React", "학습", "Vue", "초급", "프론트엔드"]
series: "React 기초"
seriesOrder: 25
---

# React 학습 가이드 - Reducer와 Context로 확장하기


---
## Reducer와 Context로 확장하기
Reducer와 Context를 결합하면 대규모 애플리케이션에서도 유지보수가 쉬운 state 관리 시스템을 만들 수 있다.
위에서 이미 다뤘지만, 다시 한번 정리하면:
> 참고: 기초 개념과 마이그레이션 단계는 [Reducer로 State 로직 추출하기](/posts/2025-07-27-react-learning-03-05-reducer),
> Context 기본 구현 예제는 [Context로 데이터 깊이 전달하기](/posts/2025-07-28-react-learning-03-06-context)에 먼저 수록되어 있다.
### 통합 패턴
세 가지 핵심 요소를 결합한다.
1. Reducer로 복잡한 state 관리
2. Context로 깊은 트리에 전달
3. 커스텀 Hook으로 사용 편의성 향상
### 파일 구조 예시
코드를 어떻게 조직하면 좋을까요?
```
src/
  contexts/
    TasksContext.js       # Context 정의 및 Hook
    TasksProvider.js      # Provider 컴포넌트
  components/
    TaskList.js
    AddTask.js
    TaskItem.js
  App.js
```
### 장점
- 관심사 분리: state 로직과 UI 분리
- 재사용성: 다른 컴포넌트에서 쉽게 사용
- 테스트 용이: reducer는 순수 함수
- 확장성: 앱이 커져도 관리 가능
### 언제 useReducer/Context를 쓰나요?
모든 상황에 사용하는 것은 아닙니다. 적절한 상황을 판단하라.
권장
- 업데이트 로직이 다수의 핸들러로 흩어져 복잡해짐
- 여러 컴포넌트가 동일한 상태/로직을 공유해야 함
지양
- 단일 컴포넌트, 단순 상태(useState가 더 간단)
- 전역 Context 하나에 모든 걸 몰아넣기(리렌더 폭발)
### Context 설계 패턴
성능과 유지보수성을 고려한 설계 패턴이다.
- 값 분리: `TasksContext`(값)와 `TasksDispatchContext`(dispatch) 분리 → 불필요 리렌더 감소
- Provider를 도메인별로 쪼개기: Auth, Theme, Tasks 등 기능별 Context
- 커스텀 훅 추상화: `useTasks()`, `useTasksDispatch()`로 null 방지와 사용성 향상
_아래 코드는 03-06의 기본 예제를 토대로, TS/안전성/분리 패턴을 확장한 버전이다._
```tsx
// contexts/TasksContext.tsx
import { createContext, useContext, useReducer } from 'react';
type Action =
  | { type: 'added'; id: number; text: string }
  | { type: 'changed'; id: number; text: string; done: boolean }
  | { type: 'deleted'; id: number };
type Task = { id: number; text: string; done: boolean };
function tasksReducer(state: Task[], action: Action): Task[] {
  switch (action.type) {
    case 'added':
      return [...state, { id: action.id, text: action.text, done: false }];
    case 'changed':
      return state.map(t => (t.id === action.id ? { ...t, text: action.text, done: action.done } : t));
    case 'deleted':
      return state.filter(t => t.id !== action.id);
    default:
      return state;
  }
}
const TasksContext = createContext<Task[] | undefined>(undefined);
const TasksDispatchContext = createContext<React.Dispatch<Action> | undefined>(undefined);
export function TasksProvider({ children }: { children: React.ReactNode }) {
  const [tasks, dispatch] = useReducer(tasksReducer, []);
  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>{children}</TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}
export function useTasks() {
  const ctx = useContext(TasksContext);
  if (!ctx) throw new Error('useTasks must be used within TasksProvider');
  return ctx;
}
export function useTasksDispatch() {
  const ctx = useContext(TasksDispatchContext);
  if (!ctx) throw new Error('useTasksDispatch must be used within TasksProvider');
  return ctx;
}
```
### 성능/리렌더링 팁
- Context 값은 안정적으로 유지: 큰 객체를 매 렌더마다 새로 만들지 않기(useMemo 고려)
- dispatch 분리: 값과 dispatch 분리로 소비자 리렌더 최소화
- 리스트는 `React.memo`/key 안정화, 파생 값은 `useMemo`
### TypeScript 안전성
- 액션은 Discriminated Union으로 선언, reducer 반환 타입 명확히
- Context 기본값 `undefined`로 두고 커스텀 훅에서 에러 처리(Provider 누락 방지)
### 테스트 전략
- Reducer: 입력(Action) → 출력(State) 단위 테스트(순수 함수)
- Provider: 테스트용 Provider로 감싸서 통합 테스트
### 마이그레이션 체크리스트
1) 액션 정의 → 2) reducer 작성 → 3) useReducer 교체 → 4) Context로 배포 → 5) 커스텀 훅 제공 → 6) 컴포넌트 교체
### 안티패턴
- Reducer 내부에서 부작용(fetch, setTimeout) 수행
- 거대한 단일 Context 하나에 전역 모든 상태 수용
- 가변 데이터(원본 배열/객체) 직접 반환
### 확장 가능한 파일 구조 예시
```
src/
  features/tasks/
    contexts/TasksContext.tsx
    components/TaskList.tsx
    hooks/useTaskStats.ts
    reducers/tasksReducer.ts (선택)
  app/App.tsx
```
