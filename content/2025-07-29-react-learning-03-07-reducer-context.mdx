---
title: "[React 기초 3-7/8] Reducer와 Context로 확장하기"
date: "2025-07-29"
description: "Reducer와 Context를 결합해 확장 가능한 State 관리 시스템을 구축하는 방법을 학습한다"
tags: ["React", "학습", "Vue", "초급", "프론트엔드"]
series: "React 기초"
seriesOrder: 25
---

# React 학습 가이드 - Reducer와 Context로 확장하기

## Reducer와 Context로 확장하기

Reducer와 Context를 결합하면 대규모 애플리케이션에서도 유지보수가 쉬운 state 관리 시스템을 만들 수 있다.

앞서 Reducer와 Context를 각각 학습했다. 이제 두 가지를 결합하는 방법을 알아본다.

> 참고: 기초 개념은 [Reducer로 State 로직 추출하기](/posts/2025-07-27-react-learning-03-05-reducer)와
[Context로 데이터 깊이 전달하기](/posts/2025-07-28-react-learning-03-06-context)를 먼저 보는 것이 좋다.

### 통합 패턴의 핵심

세 가지 핵심 요소를 결합한다:

1. **Reducer로 복잡한 state 관리** - state 업데이트 로직을 한 곳에 모은다
2. **Context로 깊은 트리에 전달** - props drilling 없이 깊은 곳까지 전달한다
3. **커스텀 Hook으로 사용 편의성 향상** - 사용하기 쉬운 인터페이스를 제공한다

### 왜 이 패턴을 사용하나?

단순히 `useState`와 props로 state를 관리하면 두 가지 문제가 생긴다:

**문제 1: Props Drilling**

```jsx
// App이 최상단에서 state를 가지고
// 여러 단계를 거쳐 전달해야 함
<App>
  <TaskBoard tasks={tasks} onUpdate={handleUpdate}>
    <TaskColumn tasks={tasks} onUpdate={handleUpdate}>
      <TaskCard task={task} onUpdate={handleUpdate} />
    </TaskColumn>
  </TaskBoard>
</App>
```

**문제 2: 흩어진 업데이트 로직**

```jsx
// 여러 컴포넌트에 같은 로직이 반복됨
function AddTask() {
  const handleAdd = () => {
    setTasks([...tasks, newTask]); // 여기도
  };
}

function EditTask() {
  const handleEdit = () => {
    setTasks(tasks.map(t => ...)); // 여기도
  };
}
```

**해결: Reducer + Context**

```jsx
// 로직은 reducer에 집중
// 어디서든 dispatch로 접근
function AddTask() {
  const dispatch = useTasksDispatch();
  const handleAdd = () => dispatch({ type: 'added', ... });
}
```

### 파일 구조

코드를 어떻게 조직하면 좋을까?

```
src/
  contexts/
    TasksContext.js       # Context 정의 및 Hook
    TasksProvider.js      # Provider 컴포넌트
  components/
    TaskList.js
    AddTask.js
    TaskItem.js
  App.js
```

### 구현 예제

실제로 어떻게 구현하는지 단계별로 살펴본다.

#### 1단계: Reducer 정의

```tsx
// contexts/TasksContext.tsx
type Action =
  | { type: "added"; id: number; text: string }
  | { type: "changed"; id: number; text: string; done: boolean }
  | { type: "deleted"; id: number };

type Task = { id: number; text: string; done: boolean };

function tasksReducer(state: Task[], action: Action): Task[] {
  switch (action.type) {
    case "added":
      return [...state, { id: action.id, text: action.text, done: false }];
    case "changed":
      return state.map((t) =>
        t.id === action.id ? { ...t, text: action.text, done: action.done } : t,
      );
    case "deleted":
      return state.filter((t) => t.id !== action.id);
    default:
      return state;
  }
}
```

#### 2단계: Context 생성 (값과 dispatch 분리)

```tsx
import { createContext, useContext, useReducer } from "react";

// 값을 전달하는 Context
const TasksContext = createContext<Task[] | undefined>(undefined);

// dispatch를 전달하는 Context (성능 최적화)
const TasksDispatchContext = createContext<React.Dispatch<Action> | undefined>(
  undefined,
);
```

왜 두 개로 분리하나?

- `TasksContext`를 사용하는 컴포넌트는 tasks 값이 변경될 때만 리렌더링된다
- `TasksDispatchContext`만 사용하는 컴포넌트는 tasks 값이 변경되어도 리렌더링되지 않는다

#### 3단계: Provider 컴포넌트

```tsx
export function TasksProvider({ children }: { children: React.ReactNode }) {
  const [tasks, dispatch] = useReducer(tasksReducer, []);

  return (
    <TasksContext.Provider value={tasks}>
      <TasksDispatchContext.Provider value={dispatch}>
        {children}
      </TasksDispatchContext.Provider>
    </TasksContext.Provider>
  );
}
```

#### 4단계: 커스텀 Hook (안전하게 사용하기)

```tsx
export function useTasks() {
  const ctx = useContext(TasksContext);
  if (!ctx) {
    throw new Error("useTasks must be used within TasksProvider");
  }
  return ctx;
}

export function useTasksDispatch() {
  const ctx = useContext(TasksDispatchContext);
  if (!ctx) {
    throw new Error("useTasksDispatch must be used within TasksProvider");
  }
  return ctx;
}
```

왜 이렇게 하나?

- Provider 없이 사용하면 명확한 에러 메시지를 보여준다
- `undefined` 체크를 컴포넌트마다 할 필요가 없다

#### 5단계: 컴포넌트에서 사용

```tsx
// App.tsx
function App() {
  return (
    <TasksProvider>
      <TaskList />
      <AddTask />
    </TasksProvider>
  );
}

// TaskList.tsx
function TaskList() {
  const tasks = useTasks(); // 값만 읽기

  return (
    <ul>
      {tasks.map((task) => (
        <TaskItem key={task.id} task={task} />
      ))}
    </ul>
  );
}

// AddTask.tsx
function AddTask() {
  const dispatch = useTasksDispatch(); // dispatch만 사용 (리렌더링 안됨)
  const [text, setText] = useState("");

  function handleAdd() {
    dispatch({
      type: "added",
      id: Date.now(),
      text,
    });
    setText("");
  }

  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={handleAdd}>Add</button>
    </div>
  );
}

// TaskItem.tsx
function TaskItem({ task }: { task: Task }) {
  const dispatch = useTasksDispatch();

  return (
    <li>
      <input
        type="checkbox"
        checked={task.done}
        onChange={(e) =>
          dispatch({
            type: "changed",
            id: task.id,
            text: task.text,
            done: e.target.checked,
          })
        }
      />
      <span>{task.text}</span>
      <button onClick={() => dispatch({ type: "deleted", id: task.id })}>
        Delete
      </button>
    </li>
  );
}
```

### 장점

- **관심사 분리**: state 로직(reducer)과 UI(컴포넌트)가 명확히 분리된다
- **재사용성**: 다른 컴포넌트에서 쉽게 사용할 수 있다
- **테스트 용이**: reducer는 순수 함수라 테스트하기 쉽다
- **확장성**: 앱이 커져도 관리하기 쉽다
- **성능**: dispatch만 사용하는 컴포넌트는 리렌더링되지 않는다

### 언제 useReducer/Context를 쓰나?

모든 상황에 사용하는 것은 아니다. 적절한 상황을 판단해야 한다.

**권장하는 경우:**

- 업데이트 로직이 다수의 핸들러로 흩어져 복잡해질 때
- 여러 컴포넌트가 동일한 state/로직을 공유해야 할 때
- state 업데이트 로직이 복잡해서 한 곳에서 관리하고 싶을 때
- 깊은 컴포넌트 트리에서 props drilling이 발생할 때

**권장하지 않는 경우:**

- 단일 컴포넌트에서만 사용하는 단순한 state (`useState`가 더 간단)
- state가 자주 변경되는데 많은 컴포넌트가 구독하는 경우 (리렌더링 폭발)
- 전역 Context 하나에 모든 state를 몰아넣는 경우

### Context 설계 패턴

성능과 유지보수성을 고려한 설계 패턴이다.

**1. 값과 dispatch 분리**

```tsx
// 나쁨: 하나의 Context
const TasksContext = createContext({ tasks, dispatch });

// 좋음: 두 개로 분리
const TasksContext = createContext(tasks);
const TasksDispatchContext = createContext(dispatch);
```

**2. Provider를 도메인별로 분리**

```tsx
// 나쁨: 하나의 거대한 Context
<AppContext.Provider value={{ user, tasks, theme, ... }}>

// 좋음: 기능별로 분리
<AuthProvider>
  <ThemeProvider>
    <TasksProvider>
      <App />
    </TasksProvider>
  </ThemeProvider>
</AuthProvider>
```

**3. 커스텀 Hook 제공**

```tsx
// 나쁨: 직접 useContext 사용
const tasks = useContext(TasksContext);

// 좋음: 커스텀 Hook으로 추상화
const tasks = useTasks(); // 에러 처리 포함
```

### 성능 최적화 팁

**1. Context 값을 안정적으로 유지**

값과 dispatch를 분리한 이유가 바로 이것이다. 만약 하나의 Context에 객체로 묶어서 전달하면:

```tsx
// 나쁨: 매 렌더마다 새 객체 생성
function TasksProvider({ children }) {
  const [tasks, dispatch] = useReducer(tasksReducer, []);

  // 매번 새로운 객체 생성 → 모든 구독자가 리렌더링
  return (
    <TasksContext.Provider value={{ tasks, dispatch }}>
      {children}
    </TasksContext.Provider>
  );
}
```

값과 dispatch를 별도 Context로 분리하면 이 문제를 피할 수 있다:

```tsx
// 좋음: 값과 dispatch 분리
<TasksContext.Provider value={tasks}>
  <TasksDispatchContext.Provider value={dispatch}>
    {children}
  </TasksDispatchContext.Provider>
</TasksContext.Provider>
```

**2. React.memo로 리렌더링 방지**

리스트의 각 아이템은 `React.memo`로 감싸면 자신의 props가 변경될 때만 리렌더링된다:

```tsx
const TaskItem = React.memo(function TaskItem({ task }) {
  // task가 변경될 때만 리렌더링
  return <li>{task.text}</li>;
});
```

### TypeScript 안전성

**Discriminated Union으로 액션 타입 안전성 확보**

```tsx
type Action =
  | { type: "added"; id: number; text: string }
  | { type: "changed"; id: number; text: string; done: boolean }
  | { type: "deleted"; id: number };

// TypeScript가 자동으로 type에 따라 필요한 필드를 체크
dispatch({ type: "added", text: "New" }); // OK
dispatch({ type: "added" }); // Error: text가 없음
```

**Context 기본값을 undefined로 설정**

```tsx
const TasksContext = createContext<Task[] | undefined>(undefined);

export function useTasks() {
  const ctx = useContext(TasksContext);
  if (!ctx) {
    throw new Error("useTasks must be used within TasksProvider");
  }
  return ctx; // 여기서는 Task[]로 타입이 좁혀짐
}
```

### 테스트 전략

**Reducer 테스트 (순수 함수)**

```tsx
describe("tasksReducer", () => {
  it("should add a task", () => {
    const state = [];
    const action = { type: "added", id: 1, text: "Test" };
    const newState = tasksReducer(state, action);

    expect(newState).toEqual([{ id: 1, text: "Test", done: false }]);
  });
});
```

**컴포넌트 테스트 (통합)**

```tsx
function renderWithProvider(component) {
  return render(<TasksProvider>{component}</TasksProvider>);
}

test("should add a task", () => {
  renderWithProvider(<App />);
  // 테스트 로직...
});
```

### 마이그레이션 체크리스트

기존 코드를 Reducer + Context 패턴으로 변경할 때:

1. 액션 타입 정의 (type, payload 구조)
2. reducer 함수 작성 및 테스트
3. `useState`를 `useReducer`로 교체
4. Context와 Provider 생성
5. 커스텀 Hook 제공 (`useTasks`, `useTasksDispatch`)
6. 컴포넌트에서 props 대신 Hook 사용

### 안티패턴 (피해야 할 것들)

**1. Reducer에서 부작용 실행**

Reducer는 **순수 함수**여야 한다. 순수 함수란 같은 입력에 대해 항상 같은 출력을 반환하고, 외부 세계와 상호작용하지 않는 함수다.

**부작용이란?**

함수의 주된 목적(값 반환) 외에 외부 세계와 상호작용하는 모든 것:

- 네트워크 요청 (`fetch`, `axios` 등)
- DOM 조작
- 타이머 설정 (`setTimeout`, `setInterval`)
- 콘솔 출력 (`console.log`)
- 로컬 스토리지 접근

```tsx
// 나쁨: Reducer에서 네트워크 요청
function tasksReducer(state, action) {
  if (action.type === "added") {
    // 문제: fetch는 네트워크 요청을 보내는 부작용
    // 외부 스코프 상태 접근 여부와 무관하게,
    // "네트워크 요청을 보낸다"는 행위 자체가 부작용
    fetch("/api/tasks", { method: "POST", body: JSON.stringify(action.task) });
    return [...state, action.task];
  }
}
```

**왜 문제인가?**

1. **예측 불가능**: 같은 action을 dispatch해도 네트워크 상태에 따라 결과가 다를 수 있다
2. **테스트 어려움**: Reducer 테스트 시 네트워크를 모킹해야 한다
3. **디버깅 어려움**: 시간 여행 디버깅 (Redux DevTools 등)이 불가능하다

```tsx
// 좋음: 컴포넌트나 useEffect에서 실행
function AddTask() {
  const dispatch = useTasksDispatch();

  async function handleAdd(newTask) {
    // 1. 먼저 API 호출
    await fetch('/api/tasks', {
      method: 'POST',
      body: JSON.stringify(newTask)
    });

    // 2. 성공하면 Reducer 업데이트
    dispatch({ type: 'added', task: newTask });
  }

  return <button onClick={() => handleAdd(...)}>Add</button>;
}
```

이렇게 분리하면:

- Reducer는 순수 함수로 유지 (테스트 쉬움)
- 네트워크 요청은 컴포넌트에서 처리 (에러 처리 쉬움)
- 각자의 역할이 명확함

**2. 거대한 단일 Context**

```tsx
// 나쁨: 하나에 다 넣기
<AppContext.Provider value={{ user, tasks, theme, settings, ... }}>

// 좋음: 도메인별 분리
<AuthProvider>
  <TasksProvider>
    <ThemeProvider>
```

**3. 가변 데이터 반환**

```tsx
// 나쁨: 원본 수정
function reducer(state, action) {
  state.push(action.task); // 원본 수정
  return state;
}

// 좋음: 새 배열 반환
function reducer(state, action) {
  return [...state, action.task];
}
```

### 확장 가능한 파일 구조

프로젝트가 커지면 다음과 같이 구조화한다:

```
src/
  features/
    tasks/
      contexts/
        TasksContext.tsx      # Context 정의
      components/
        TaskList.tsx
        AddTask.tsx
        TaskItem.tsx
      hooks/
        useTaskStats.ts       # 커스텀 Hook
      reducers/
        tasksReducer.ts       # Reducer 로직
      types.ts                # 타입 정의
  app/
    App.tsx
```

이렇게 하면:

- 관련 코드가 한 곳에 모인다
- 다른 기능과 독립적이다
- 테스트하기 쉽다
- 필요하면 통째로 다른 프로젝트로 옮길 수 있다
