---
title: "[React Router 5/9] React Router - Router Hooks"
date: "2025-08-19"
description: "useParams, useSearchParams, useLocation, useMatch 활용"
tags: ["React", "고급", "프론트엔드"]
series: "React 라이브러리"
seriesOrder: 9
---

# React Router 가이드 - Router Hooks

> React Router v6를 기반으로 한 라우팅 학습 자료  
> 출처: [React Router Documentation](https://reactrouter.com/)

---

## Router Hooks란?

React Router는 라우팅 정보에 접근하고 조작하기 위한 다양한 Hook을 제공한다. 이전 섹션에서 다룬 `useNavigate`와 `useParams` 외에도 유용한 Hook들이 있다.

## useLocation

현재 URL의 정보를 가져온다:

```jsx
import { useLocation } from "react-router-dom";

export default function Header() {
  const location = useLocation();

  return (
    <div>
      <p>Current path: {location.pathname}</p>   {/* "/about" */}
      <p>Search: {location.search}</p>            {/* "?id=123" */}
      <p>Hash: {location.hash}</p>                {/* "#section1" */}
      <p>State: {JSON.stringify(location.state)}</p> {/* navigate로 전달한 state */}
    </div>
  );
}
```

**location 객체 구조**:
- `pathname`: 현재 경로 (`/about`)
- `search`: 쿼리 스트링 (`?id=123&sort=asc`)
- `hash`: URL 해시 (`#section1`)
- `state`: navigate 시 전달한 데이터
- `key`: 현재 location의 고유 키

### 활용 예시 1: 이전 페이지 기억

```jsx
function LoginPage() {
  const navigate = useNavigate();
  const location = useLocation();
  
  // ProtectedRoute에서 전달한 from 정보
  const from = location.state?.from || "/";

  function handleLogin() {
    // 로그인 성공 후 원래 페이지로 이동
    navigate(from, { replace: true });
  }

  return <button onClick={handleLogin}>Login</button>;
}
```

### 활용 예시 2: 경로에 따른 스타일링

```jsx
function Navigation() {
  const location = useLocation();

  return (
    <nav>
      <Link 
        to="/dashboard" 
        style={{ 
          fontWeight: location.pathname === "/dashboard" ? "bold" : "normal" 
        }}
      >
        Dashboard
      </Link>
    </nav>
  );
}
```

### 활용 예시 3: 페이지 전환 감지

```jsx
function App() {
  const location = useLocation();

  useEffect(() => {
    // 페이지 전환 시마다 실행
    console.log("Route changed to:", location.pathname);
    
    // 분석 도구에 페이지뷰 전송
    analytics.send("pageview", location.pathname);
  }, [location]);

  return <Routes>...</Routes>;
}
```

## useSearchParams

쿼리 스트링을 읽고 변경한다. URLSearchParams API를 기반으로 동작한다:

```jsx
import { useSearchParams } from "react-router-dom";

export default function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();

  // 쿼리 파라미터 읽기
  const category = searchParams.get("category"); // "electronics"
  const sort = searchParams.get("sort");         // "price"
  const page = searchParams.get("page");         // "2"

  // 쿼리 파라미터 변경
  function handleFilterChange(newCategory) {
    setSearchParams({ category: newCategory, sort, page });
    // URL이 ?category=newCategory&sort=price&page=2 로 변경됨
  }

  return (
    <div>
      <p>Category: {category}</p>
      <p>Sort: {sort}</p>
      <p>Page: {page}</p>
      <button onClick={() => handleFilterChange("books")}>
        Show Books
      </button>
    </div>
  );
}
```

### URLSearchParams API 메서드

```jsx
const [searchParams, setSearchParams] = useSearchParams();

// 읽기
searchParams.get("category");          // 'books'
searchParams.getAll("tags");           // ['fiction', 'bestseller']
searchParams.has("category");          // true
searchParams.toString();               // 'category=books&tags=fiction'

// 쓰기 (객체 전달)
setSearchParams({ category: "movies", page: "1" });
// URL: ?category=movies&page=1

// 쓰기 (함수 전달)
setSearchParams(prev => {
  prev.set("page", "2");
  prev.delete("temp");
  return prev;
});
```

### 활용 예시: 필터링과 정렬

```jsx
function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [products, setProducts] = useState([]);

  const category = searchParams.get("category") || "all";
  const sort = searchParams.get("sort") || "name";

  useEffect(() => {
    // 쿼리 파라미터가 변경될 때마다 데이터 다시 fetch
    fetchProducts(category, sort).then(setProducts);
  }, [category, sort]);

  function handleCategoryChange(newCategory) {
    setSearchParams(prev => {
      prev.set("category", newCategory);
      return prev;
    });
  }

  function handleSortChange(newSort) {
    setSearchParams(prev => {
      prev.set("sort", newSort);
      return prev;
    });
  }

  return (
    <div>
      <select value={category} onChange={e => handleCategoryChange(e.target.value)}>
        <option value="all">All</option>
        <option value="electronics">Electronics</option>
        <option value="books">Books</option>
      </select>

      <select value={sort} onChange={e => handleSortChange(e.target.value)}>
        <option value="name">Name</option>
        <option value="price">Price</option>
        <option value="date">Date</option>
      </select>

      <ul>
        {products.map(product => (
          <li key={product.id}>{product.name}</li>
        ))}
      </ul>
    </div>
  );
}
```

**장점**:
- URL에 필터 상태가 반영되어 공유와 북마크가 가능하다
- 새로고침해도 필터 상태가 유지된다
- 뒤로가기/앞으로가기로 필터 상태를 변경할 수 있다

## useMatch

특정 경로 패턴과 현재 URL이 매칭되는지 확인한다:

```jsx
import { useMatch } from "react-router-dom";

function Navigation() {
  const match = useMatch("/users/:userId");

  if (match) {
    console.log("User ID:", match.params.userId);
    console.log("Pathname:", match.pathname);
    console.log("Pattern:", match.pattern);
  }

  return <nav>...</nav>;
}
```

**반환 값**:
- 매칭되면: `{ params, pathname, pattern }` 객체
- 매칭 안 되면: `null`

### 활용 예시: 조건부 렌더링

```jsx
function Sidebar() {
  const isDashboard = useMatch("/dashboard/*");
  const isSettings = useMatch("/settings/*");

  // Dashboard나 Settings 페이지에서만 사이드바 표시
  if (!isDashboard && !isSettings) {
    return null;
  }

  return (
    <aside>
      {isDashboard && <DashboardSidebar />}
      {isSettings && <SettingsSidebar />}
    </aside>
  );
}
```

## useRoutes (프로그래밍 방식 라우트 정의)

JSX 대신 객체 배열로 라우트를 정의한다:

```jsx
import { useRoutes } from "react-router-dom";

function App() {
  const routes = useRoutes([
    { path: "/", element: <Home /> },
    { path: "/about", element: <About /> },
    {
      path: "/users",
      element: <UsersLayout />,
      children: [
        { index: true, element: <UserList /> },
        { path: ":userId", element: <UserDetail /> },
      ],
    },
    { path: "*", element: <NotFound /> },
  ]);

  return routes;
}
```

**장점**:
- 라우트를 데이터로 관리할 수 있다
- 조건부로 라우트를 추가/제거하기 쉽다
- 외부 파일에서 라우트 정의를 불러올 수 있다

### 활용 예시: 역할별 라우트

```jsx
function App() {
  const { user } = useAuth();

  const adminRoutes = [
    { path: "/admin", element: <AdminDashboard /> },
    { path: "/admin/users", element: <UserManagement /> },
  ];

  const userRoutes = [
    { path: "/", element: <Home /> },
    { path: "/profile", element: <Profile /> },
  ];

  const routes = user?.role === "admin" 
    ? [...userRoutes, ...adminRoutes]
    : userRoutes;

  return useRoutes(routes);
}
```

## Hook 조합 패턴

여러 Hook을 조합하여 사용하는 예시:

```jsx
function ProductDetail() {
  const { productId } = useParams();           // URL 파라미터
  const [searchParams] = useSearchParams();    // 쿼리 스트링
  const location = useLocation();              // 전체 location 정보
  const navigate = useNavigate();              // 네비게이션

  const variant = searchParams.get("variant") || "default";
  const from = location.state?.from;

  function handleAddToCart() {
    addToCart(productId, variant);
    
    // 장바구니 페이지로 이동
    navigate("/cart", {
      state: { from: location.pathname }
    });
  }

  return (
    <div>
      <h1>Product {productId}</h1>
      <p>Variant: {variant}</p>
      <button onClick={handleAddToCart}>Add to Cart</button>
      {from && <Link to={from}>Back to {from}</Link>}
    </div>
  );
}
```

---
