---
title: "[React Query 5/8] React Query - 낙관적 업데이트"
date: "2025-08-28"
description: "낙관적 업데이트 패턴과 롤백 처리"
tags: ["React", "고급", "프론트엔드"]
series: "React Query"
seriesOrder: 5
---

# React Query 가이드 - 낙관적 업데이트

> TanStack Query v5를 기반으로 한 데이터 페칭 학습 자료  
> 출처: [TanStack Query Documentation](https://tanstack.com/query/)

---

## 낙관적 업데이트

낙관적 업데이트는 “서버 응답을 기다리지 않고 UI를 먼저 바꾸는 패턴”이다. 실무에서 낙관적 업데이트는 UX를 크게 개선하지만, 동시에 정합성 위험을 만든다.

이 글은 다음을 목표로 한다.

- 언제 낙관적 업데이트가 가능한지 판단한다.
- `onMutate → onError → onSettled`의 흐름을 이해한다.
- 경쟁 상태(연속 클릭, 동시에 여러 요청)에서 롤백을 설계한다.

---

## 1. 낙관적 업데이트가 성립하는 조건

낙관적 업데이트는 다음 조건이 강할수록 안전하다.

- 변경이 단순하다(토글, 카운트 ±1, 리스트에 임시 항목 추가).
- 실패 확률이 낮다(권한/검증 실패가 드문 작업).
- 실패해도 롤백 UX가 자연스럽다(원복이 명확하다).

반대로 다음이면 낙관적 업데이트는 위험하다.

- 서버가 값을 크게 보정한다(가격/재고/권한 기반 결과).
- 실패 시 사용자에게 치명적이다(결제, 정산, 승인 워크플로우).

이 경우에는 “낙관적 업데이트” 대신 “진행 중 상태를 명확히 보여주는 UI”가 더 낫다.

---

## 2. 기본 패턴: 스냅샷 + 롤백 + invalidate

낙관적 업데이트의 표준 패턴은 다음이다.

1. 진행 중인 관련 쿼리를 취소한다(`cancelQueries`)
2. 이전 캐시 스냅샷을 저장한다
3. 캐시를 즉시 업데이트한다(`setQueryData`)
4. 실패하면 스냅샷으로 롤백한다
5. 성공/실패와 무관하게 서버 진실로 다시 맞춘다(`invalidateQueries`)

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

type Todo = { id: string; title: string; completed: boolean };

async function updateTodo(todo: Todo) {
  const res = await fetch(`/api/todos/${todo.id}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(todo),
  });
  if (!res.ok) throw new Error("failed");
  return (await res.json()) as Todo;
}

export function TodoItem({ todo }: { todo: Todo }) {
  const queryClient = useQueryClient();

  const mutation = useMutation({
    mutationFn: updateTodo,
    onMutate: async (nextTodo) => {
      await queryClient.cancelQueries({ queryKey: ["todos"] });
      const previousTodos = queryClient.getQueryData<Todo[]>(["todos"]);

      queryClient.setQueryData<Todo[]>(["todos"], (old) => {
        const prev = old ?? [];
        return prev.map((t) => (t.id === nextTodo.id ? nextTodo : t));
      });

      return { previousTodos };
    },
    onError: (_err, _nextTodo, context) => {
      if (context?.previousTodos) {
        queryClient.setQueryData(["todos"], context.previousTodos);
      }
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["todos"] });
    },
  });

  return (
    <label>
      <input
        type="checkbox"
        checked={todo.completed}
        onChange={() => mutation.mutate({ ...todo, completed: !todo.completed })}
        disabled={mutation.isPending}
      />
      {todo.title}
    </label>
  );
}
```

`onSettled`를 두는 이유는 “서버 진실로 재동기화”하기 위해서다. 낙관적 업데이트는 임시 UI이므로 마지막에는 서버 결과로 맞춰야 한다.

---

## 3. 실무 예제: 좋아요 토글

좋아요는 토글이므로 낙관적 업데이트에 적합한 편이다. 핵심은 “두 번 클릭” 같은 경쟁 상태를 막는 것이다.

```tsx
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

type Post = { id: string; likes: number; isLiked: boolean };

async function fetchPost(postId: string): Promise<Post> {
  const res = await fetch(`/api/posts/${postId}`);
  if (!res.ok) throw new Error("failed");
  return await res.json();
}

async function toggleLike(postId: string): Promise<void> {
  const res = await fetch(`/api/posts/${postId}/toggle-like`, { method: "POST" });
  if (!res.ok) throw new Error("failed");
}

export function LikeButton({ postId }: { postId: string }) {
  const queryClient = useQueryClient();
  const postQuery = useQuery({
    queryKey: ["post", postId],
    queryFn: () => fetchPost(postId),
  });

  const mutation = useMutation({
    mutationFn: () => toggleLike(postId),
    onMutate: async () => {
      await queryClient.cancelQueries({ queryKey: ["post", postId] });
      const previous = queryClient.getQueryData<Post>(["post", postId]);

      queryClient.setQueryData<Post>(["post", postId], (old) => {
        if (!old) return old;
        const nextLiked = !old.isLiked;
        return { ...old, isLiked: nextLiked, likes: old.likes + (nextLiked ? 1 : -1) };
      });

      return { previous };
    },
    onError: (_err, _vars, context) => {
      if (context?.previous) {
        queryClient.setQueryData(["post", postId], context.previous);
      }
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["post", postId] });
    },
  });

  if (postQuery.isPending) return <button disabled>loading...</button>;
  if (postQuery.isError) return <button disabled>error</button>;

  const post = postQuery.data;

  return (
    <button onClick={() => mutation.mutate()} disabled={mutation.isPending}>
      {post.isLiked ? "liked" : "like"} ({post.likes})
    </button>
  );
}
```

---

## 4. 자주 터지는 함정

### 1) cancelQueries를 안 한다

낙관적 업데이트 직후에 백그라운드 리페치가 들어와 캐시를 덮어쓰면 UI가 튄다.

### 2) rollback 스냅샷을 안 만든다

실패했을 때 사용자는 이미 바뀐 UI를 봤다. 롤백이 없으면 “거짓 UI”가 남는다.

### 3) invalidate를 안 한다

낙관적 업데이트는 임시값이다. 마지막에는 서버 진실로 맞춰야 한다.

---

## Vue와 비교

Vue Query에서도 동일한 lifecycle(`onMutate`, `onError`, `onSettled`)가 있다. Pinia로 낙관적 업데이트를 구현할 수도 있지만, 경쟁 상태/롤백/재동기화를 팀이 직접 설계해야 한다.

| 관심사 | Vue Query | React Query |
| --- | --- | --- |
| 낙관적 업데이트 | `onMutate` + rollback | `onMutate` + rollback |
| 경쟁 상태 | cancel/invalidate | cancel/invalidate |
| 서버 진실 동기화 | invalidate | invalidate |

---

## 체크리스트

- 낙관적 업데이트가 가능한 조건과 위험한 조건을 구분할 수 있다.
- cancel → snapshot → update → rollback → invalidate 흐름을 설명할 수 있다.
- 연속 클릭 같은 경쟁 상태를 UI/로직으로 막을 수 있다.

---
