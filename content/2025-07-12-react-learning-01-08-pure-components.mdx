---
title: "📚 [React 기초 1-8/10] 순수 컴포넌트 유지하기"
date: "2025-07-12"
description: "React에서 순수 컴포넌트를 작성하고 부작용을 관리하는 방법을 학습합니다"
tags: ["React", "학습", "Vue", "초급", "프론트엔드"]
series: "React 기초"
seriesOrder: 8
---

# React 학습 가이드 - 순수 컴포넌트 유지하기

> React 공식 문서를 기반으로 한 학습 자료  
> 원문: [Describing the UI - React](https://react.dev/learn/describing-the-ui)

---

## 순수 컴포넌트 유지하기

### 순수 함수란?

**순수 함수**는 다음 특징을 가진 함수입니다:

1. **자기 일만 함 (Minds its own business)**
   - 함수 호출 전에 존재했던 객체나 변수를 변경하지 않음

2. **같은 입력, 같은 출력 (Same inputs, same output)**
   - 같은 입력이 주어지면 항상 같은 결과 반환

### 순수 함수 예제

```javascript
// ✅ 순수 함수
function double(number) {
  return number * 2;
}

double(3)  // 6
double(3)  // 6 (항상 같은 결과)
```

```javascript
// ❌ 순수하지 않은 함수
let count = 0;

function increment() {
  count = count + 1;  // 외부 변수 수정!
  return count;
}

increment()  // 1
increment()  // 2 (다른 결과!)
```

### React 컴포넌트를 순수 함수처럼 작성하기

**React는 모든 컴포넌트가 순수 함수라고 가정합니다.**

```jsx
// ✅ 순수 컴포넌트
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

**결과:**

```
Tea cup for guest #1
Tea cup for guest #2
Tea cup for guest #3
```

### 비순수 컴포넌트의 문제

```jsx
// ❌ 비순수 컴포넌트 (안티패턴!)
let guest = 0;

function Cup() {
  // 나쁨: 기존 변수를 변경!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

**결과 (예측 불가능!):**

```
Tea cup for guest #2  // 1이 아님!
Tea cup for guest #4  // 3이 아님!
Tea cup for guest #6  // 5가 아님!
```

**왜 이런 일이 발생하나?**

- React는 컴포넌트를 여러 번 렌더링할 수 있음
- Strict Mode에서는 개발 중 2번 렌더링
- 비순수 컴포넌트는 예측 불가능한 버그 발생

### 순수하게 고치기

```jsx
// ✅ 순수 컴포넌트로 변경
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

**이제 항상 예상대로 작동:**

```
Tea cup for guest #1
Tea cup for guest #2
Tea cup for guest #3
```

### 부작용 (Side Effects)이 필요한 경우

**부작용 예:**

- 화면 업데이트
- 애니메이션 시작
- 데이터 변경

**해결책:** 렌더링 중이 아니라 **"옆에서"** 발생해야 함

#### 1. **이벤트 핸들러에서 부작용 처리**

```jsx
// ✅ 이벤트 핸들러는 순수할 필요 없음
function Button() {
  function handleClick() {
    alert('Clicked!');  // 부작용 OK!
  }
  
  return <button onClick={handleClick}>Click me</button>;
}
```

#### 2. **useEffect Hook 사용**

```jsx
import { useEffect } from 'react';

function Component() {
  useEffect(() => {
    // 부작용 코드 (API 호출, 타이머 등)
    console.log('Component rendered');
  }, []);
  
  return <div>Content</div>;
}
```

### 로컬 뮤테이션은 괜찮음

```jsx
// ✅ 렌더링 중 생성된 변수/객체 수정은 OK
function Cup({ guest }) {
  const cups = [];  // 렌더링 중 생성
  
  for (let i = 1; i <= guest; i++) {
    cups.push(<div key={i}>Cup #{i}</div>);
  }
  
  return <>{cups}</>;
}
```

**핵심:** 렌더링 **전**에 존재했던 변수만 수정하지 않으면 됩니다.

### Strict Mode로 비순수성 감지

React는 **Strict Mode**에서 각 컴포넌트를 2번 호출하여 비순수 함수를 감지합니다.

```jsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

**동작:**

- 개발 모드에서만 2번 렌더링
- 프로덕션에서는 1번만 렌더링
- 비순수 컴포넌트는 다른 결과를 출력하여 문제를 발견할 수 있음

### 실전 예제: API 호출

```jsx
// ❌ 잘못된 코드: 렌더링 중 API 호출
function ProductList() {
  const products = fetch('/api/products');  // 비순수!
  return <div>{products}</div>;
}

// ✅ 올바른 코드: useEffect 사용
import { useState, useEffect } from 'react';

function ProductList() {
  const [products, setProducts] = useState([]);
  
  useEffect(() => {
    fetch('/api/products')
      .then(res => res.json())
      .then(data => setProducts(data));
  }, []);
  
  return (
    <ul>
      {products.map(p => <li key={p.id}>{p.name}</li>)}
    </ul>
  );
}
```

### 순수성의 이점

1. **예측 가능성**: 같은 props → 같은 결과
2. **테스트 용이**: 단위 테스트 작성 쉬움
3. **최적화 가능**: React가 안전하게 렌더링 스킵 가능
4. **병렬 처리**: React 18+ Concurrent Rendering

### Vue와 비교

```html
<!-- Vue: setup()에서 반응성 시스템이 관리 -->
<script setup>
import { ref } from 'vue'

let count = ref(0)  // Vue가 관리

function increment() {
  count.value++  // 안전함
}
</script>
```

```jsx
// React: 순수성 유지 필수
function Counter() {
  const [count, setCount] = useState(0)
  
  function increment() {
    setCount(count + 1)  // 순수하게 상태 업데이트
  }
  
  return <button onClick={increment}>{count}</button>
}
```

---

## 다음 단계

이제 순수 컴포넌트의 중요성을 배웠으니, 다음 포스트에서는 **UI를 트리로 이해하기**를 학습합니다.

**배울 내용:**
- 렌더 트리와 모듈 의존성 트리
- 컴포넌트 계층 구조
- 성능 최적화 관점

---

**작성일**: 2025-10-11  
**출처**: [React Official Documentation](https://react.dev/learn/describing-the-ui)  
**대상**: React 초급 학습자
