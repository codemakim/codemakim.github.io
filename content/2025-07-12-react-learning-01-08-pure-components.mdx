---
title: "[React 기초 1-8/10] 순수 컴포넌트 유지하기"
date: "2025-07-12"
description: "React에서 순수 컴포넌트를 작성하고 부작용을 관리하는 방법을 학습합니다"
tags: ["React", "학습", "Vue", "초급", "프론트엔드"]
series: "React 기초"
seriesOrder: 8
---

# React 학습 가이드 - 순수 컴포넌트 유지하기

## 순수 컴포넌트 유지하기

### 순수 함수란?

순수 함수는 다음 특징을 가진 함수다:

1. 자기 일만 함 (Minds its own business)
   - 함수 호출 전에 존재했던 객체나 변수를 변경하지 않음

2. 같은 입력, 같은 출력 (Same inputs, same output)
   - 같은 입력이 주어지면 항상 같은 결과 반환

### 순수 함수 예제

순수 함수:

```javascript
// 순수 함수
function double(number) {
  return number * 2;
}

double(3); // 6
double(3); // 6 (항상 같은 결과)
```

- 같은 입력(`3`)이면 항상 같은 결과(`6`)를 반환한다.
- 외부 변수를 수정하지 않는다.

비순수 함수:

```javascript
// 순수하지 않은 함수
let count = 0;

function increment() {
  count = count + 1; // 외부 변수 수정
  return count;
}

increment(); // 1
increment(); // 2 (다른 결과)
```

- 외부 변수 `count`를 수정한다.
- 호출할 때마다 다른 결과를 반환한다.

### React 컴포넌트를 순수 함수처럼 작성하기

React는 모든 컴포넌트가 순수 함수라고 가정한다.

같은 props를 받으면 항상 같은 JSX를 반환해야 한다.

```jsx
// 순수 컴포넌트
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

결과:

```
Tea cup for guest #1
Tea cup for guest #2
Tea cup for guest #3
```

### 비순수 컴포넌트의 문제

외부 변수를 수정하는 컴포넌트는 예측할 수 없는 버그를 일으킨다.

```jsx
// 비순수 컴포넌트 (안티패턴)
let guest = 0;

function Cup() {
  // 나쁨: 기존 변수를 변경
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

결과 (예측 불가능):

```
Tea cup for guest #2  // 1이 아님
Tea cup for guest #4  // 3이 아님
Tea cup for guest #6  // 5가 아님
```

왜 이런 일이 발생하나?

- React는 컴포넌트를 여러 번 렌더링할 수 있음
- Strict Mode에서는 개발 중 2번 렌더링
- 비순수 컴포넌트는 예측 불가능한 버그 발생

### 순수하게 고치기

```jsx
// 순수 컴포넌트로 변경
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

이제 항상 예상대로 작동:

```
Tea cup for guest #1
Tea cup for guest #2
Tea cup for guest #3
```

### 부작용 (Side Effects)이 필요한 경우

렌더링은 순수해야 하지만, 때로는 부작용이 필요하다.

부작용 예:

- 화면 업데이트
- 애니메이션 시작
- 데이터 변경

해결책: 렌더링 중이 아니라 "옆에서" 발생해야 함

#### 1. 이벤트 핸들러에서 부작용 처리

```jsx
// 이벤트 핸들러는 순수할 필요 없음
function Button() {
  function handleClick() {
    alert("Clicked!"); // 부작용 OK
  }

  return <button onClick={handleClick}>Click me</button>;
}
```

#### 2. useEffect Hook 사용

```jsx
import { useEffect } from "react";

function Component() {
  useEffect(() => {
    // 부작용 코드 (API 호출, 타이머 등)
    console.log("Component rendered");
  }, []);

  return <div>Content</div>;
}
```

### 로컬 뮤테이션은 괜찮음

렌더링 중에 생성한 변수나 객체를 수정하는 것은 문제없다.

```jsx
// 렌더링 중 생성된 변수/객체 수정은 OK
function Cup({ guest }) {
  const cups = []; // 렌더링 중 생성

  for (let i = 1; i <= guest; i++) {
    cups.push(<div key={i}>Cup #{i}</div>);
  }

  return <>{cups}</>;
}
```

핵심: 렌더링 전에 존재했던 변수만 수정하지 않으면 된다.

### Strict Mode로 비순수성 감지

React는 개발 모드에서 비순수 함수를 찾아내기 위해 컴포넌트를 2번 호출한다.

React는 Strict Mode에서 각 컴포넌트를 2번 호출하여 비순수 함수를 감지한다.

```jsx
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>,
);
```

동작:

- 개발 모드에서만 2번 렌더링
- 프로덕션에서는 1번만 렌더링
- 비순수 컴포넌트는 다른 결과를 출력하여 문제를 발견할 수 있음

### 실전 예제: API 호출

```jsx
// 잘못된 코드: 렌더링 중 API 호출
function ProductList() {
  const products = fetch("/api/products"); // 비순수
  return <div>{products}</div>;
}

// 올바른 코드: useEffect 사용
import { useState, useEffect } from "react";

function ProductList() {
  const [products, setProducts] = useState([]);

  useEffect(() => {
    fetch("/api/products")
      .then((res) => res.json())
      .then((data) => setProducts(data));
  }, []);

  return (
    <ul>
      {products.map((p) => (
        <li key={p.id}>{p.name}</li>
      ))}
    </ul>
  );
}
```

### 순수성의 이점

1. 예측 가능성: 같은 props → 같은 결과
2. 테스트 용이: 단위 테스트 작성 쉬움
3. 최적화 가능: React가 안전하게 렌더링 스킵 가능
4. 병렬 처리: React 18+ Concurrent Rendering

### Vue와 비교

```html
<!-- Vue: setup()에서 반응성 시스템이 관리 -->
<script setup>
  import { ref } from "vue";

  let count = ref(0); // Vue가 관리

  function increment() {
    count.value++; // 안전함
  }
</script>
```

```jsx
// React: 순수성 유지 필수
function Counter() {
  const [count, setCount] = useState(0);

  function increment() {
    setCount(count + 1); // 순수하게 상태 업데이트
  }

  return <button onClick={increment}>{count}</button>;
}
```
