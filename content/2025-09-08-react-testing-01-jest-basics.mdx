---
title: "[React 테스팅 1/3] Jest 기초"
date: "2025-09-08"
description: "Jest를 사용한 테스트 작성, Mock, 비동기 테스트를 학습한다"
tags: ["Testing", "JavaScript", "중급", "프론트엔드"]
series: "React 테스팅"
seriesOrder: 1
---

# Jest 기초: 측정 가능한 테스트를 만든다

Jest는 단위 테스트 러너이자 assertion, mocking, 커버리지 수집기를 한 번에 제공한다.
이 글의 목표는 Jest 문법을 나열하는 것이 아니라, 테스트를 **측정 가능한 신호**로 바꾸는 기준을 만드는 것이다.

## 무엇을 Jest로 테스트하는가

Jest는 다음 레이어에서 가치를 낸다.

- **순수 로직**: 입력이 같으면 출력이 같은 함수, 파서, 정규화, 도메인 규칙
- **경계 로직**: 네트워크/시간/랜덤 같은 비결정 요소를 격리한 뒤의 “결정된 부분”
- **회귀 방지**: 리팩토링 후에도 동일한 계약을 보장해야 하는 부분

반대로 Jest로 다루기 불리한 대상도 있다.

- **브라우저 렌더링 결과**: DOM 기반 검증은 RTL로 옮기는 편이 낫다
- **전체 사용자 여정**: E2E가 담당한다

## 테스트를 신호로 만드는 규칙

테스트는 “통과/실패”만으로는 의미가 얕다. 다음 정보가 함께 나와야 디버깅 비용이 줄어든다.

| 규칙 | 목적 | 신호(측정) |
| --- | --- | --- |
| 한 테스트는 한 계약을 검증한다 | 실패 원인을 좁힌다 | 실패 메시지가 한 줄로 읽힌다 |
| 비결정 요소를 고정한다 | flaky를 없앤다 | 같은 커밋에서 반복 실행해도 결과가 같다 |
| 단위가 깨지면 범위를 재조정한다 | 과도한 mock을 줄인다 | 테스트 유지보수 시간이 줄어든다 |

## 실행 환경(node, jsdom)을 먼저 고정한다

Jest의 `testEnvironment`는 “무엇을 믿을 수 있는가”를 정한다.

- **node**: `window`, DOM이 없다. 순수 로직 테스트에 적합하다.
- **jsdom**: DOM API가 있다. UI 테스트의 기반이 된다(단, 레이아웃/페인트 같은 실제 브라우저 동작은 없다).

```js
// jest.config.js
module.exports = {
  testEnvironment: "node",
  collectCoverageFrom: ["src/**/*.{js,jsx,ts,tsx}", "!src/**/*.d.ts"],
  clearMocks: true,
};
```

UI 테스트까지 한 리포지토리에서 함께 돌린다면, 파일 단위로 환경을 나누는 편이 안정적이다.

```js
// jest.config.js (예시: 프로젝트 분리)
module.exports = {
  projects: [
    {
      displayName: "unit",
      testMatch: ["<rootDir>/src/**/*.unit.test.{ts,tsx}"],
      testEnvironment: "node",
    },
    {
      displayName: "ui",
      testMatch: ["<rootDir>/src/**/*.ui.test.{ts,tsx}"],
      testEnvironment: "jsdom",
    },
  ],
};
```

## AAA(Arrange-Act-Assert)로 테스트를 읽히게 만든다

테스트는 문서다. 구조가 반복되면 실패 원인을 찾는 속도가 빨라진다.

```ts
// price.unit.test.ts
import { formatPrice } from "./price";

test("formatPrice는 KRW를 천 단위로 포맷한다", () => {
  // Arrange
  const value = 1234567;

  // Act
  const formatted = formatPrice(value, "KRW");

  // Assert
  expect(formatted).toBe("1,234,567원");
});
```

## 커버리지(coverage)는 “증거”가 아니라 “레이더”다

커버리지는 테스트 품질을 보장하지 않는다. 다만 빈 구역을 빠르게 보여준다.

- **line coverage**: 실행된 줄 비율이다. 조건 분기 누락을 숨기기 쉽다.
- **branch coverage**: if/ternary/switch 분기 커버 여부다. 계약 테스트에 더 유용하다.
- **function coverage**: 호출된 함수 비율이다. public API 중심 설계에 도움된다.

중요한 지점은 “숫자를 목표로 하지 않는 것”이다. 목표는 다음이다.

- **핵심 경계의 분기(branch)**가 커버되었는가
- **실패 시 어떤 계약이 깨졌는지**가 읽히는가

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
```

## Mock의 목적은 “격리”이고, 결과는 “관측 가능성”이다

Mock은 외부 의존성을 제거해 테스트를 빠르고 결정적으로 만든다. 동시에 관측 신호를 추가한다.

### 1) 함수 단위 mock: 호출이 아니라 계약을 검증한다

```ts
test("save는 storage에 직렬화된 값을 저장한다", () => {
  const storage = { setItem: jest.fn() };

  save(storage, "token", { accessToken: "a" });

  expect(storage.setItem).toHaveBeenCalledWith("token", JSON.stringify({ accessToken: "a" }));
});
```

여기서 중요한 것은 `setItem`이 몇 번 호출되었는가가 아니라, **무슨 데이터 계약으로 저장되는가**다.

### 2) 시간 고정: flaky의 1순위 원인을 제거한다

시간 의존 로직은 테스트가 느려지거나 flaky해지기 쉽다. 타이머를 “가짜 시간”으로 바꾼다.

```ts
beforeEach(() => {
  jest.useFakeTimers();
});

afterEach(() => {
  jest.useRealTimers();
});

test("delayedGreeting은 1초 뒤 콜백을 실행한다", () => {
  const cb = jest.fn();
  delayedGreeting(cb);

  expect(cb).not.toHaveBeenCalled();

  jest.advanceTimersByTime(1000);
  expect(cb).toHaveBeenCalledWith("Hello");
});
```

### 3) 랜덤/UUID 고정: 재현성을 확보한다

랜덤은 테스트를 무의미하게 만든다. 랜덤 자체를 테스트하는 것이 아니라, 랜덤을 사용하는 **결과 계약**을 테스트해야 한다.

```ts
test("createId는 호출마다 문자열을 반환한다", () => {
  const spy = jest.spyOn(Math, "random").mockReturnValue(0.1234);
  expect(createId()).toBe("0.1234");
  spy.mockRestore();
});
```

실무에서는 “랜덤 값을 고정한다”가 아니라, 랜덤을 호출하지 않도록 설계를 바꾸는 편이 낫다.

## 비동기 테스트는 “대기 조건”이 핵심이다

비동기 테스트가 flaky한 이유는 대부분 다음 중 하나다.

- 대기 조건이 “시간”이다
- 외부 의존(네트워크/타이머)이 남아 있다
- 테스트 대상이 내부적으로 병렬 작업을 한다

```ts
test("fetchJson은 500이면 예외를 던진다", async () => {
  global.fetch = jest.fn().mockResolvedValueOnce({ ok: false, status: 500 });

  await expect(fetchJson("/api")).rejects.toThrow();
});
```

여기서 중요한 것은 `setTimeout`으로 기다리지 않는 것이다. **완료 조건**(Promise resolve/reject)을 직접 기다린다.

## flaky를 측정하는 방법

flaky는 “가끔 실패하는 테스트”가 아니라 “리팩토링/배포 속도를 계속 늦추는 시스템 장애”다.

- **재현 루프**: 같은 테스트를 여러 번 돌려 실패율을 확인한다.
- **실패 분류**: 시간/환경/경쟁(레이스)/외부 의존으로 분류한다.

```bash
# 동일 테스트 반복 실행(예시)
jest path/to/foo.unit.test.ts --runInBand --repeatEach=20
```

여기서 실패가 1번이라도 나오면, 원인은 “코드 품질”이 아니라 “결정성”에 있다.

## Vue(Vitest)와 비교

| 항목 | Jest | Vitest |
| --- | --- | --- |
| 실행 모델 | Node 기반, 생태계 성숙 | Vite 기반, 빠른 피드백 |
| mock | jest 내장 | vi 내장 |
| 커버리지 | 내장/연동 다양 | v8/istanbul 옵션 |
| 주 사용처 | 레거시/대규모, 광범위 호환 | Vite 기반 프런트, 빠른 개발 루프 |

핵심은 도구가 아니라 규칙이다. 결정성, 격리, 읽히는 실패 메시지가 우선이다.

## 학습 체크리스트

- [ ] node/jsdom 환경 차이를 설명할 수 있다
- [ ] 커버리지를 숫자가 아니라 레이더로 해석할 수 있다
- [ ] 시간/랜덤/네트워크 의존을 고정해서 flaky를 제거할 수 있다
- [ ] 비동기 테스트에서 “시간 대기” 대신 “완료 조건”을 설계할 수 있다
- [ ] 반복 실행으로 flaky를 측정하고 원인을 분류할 수 있다
