---
title: "📚 [React 기초 4-2/10] Ref로 값 참조하기"
date: "2025-08-01"
description: "리렌더링 없이 값을 기억하기 위한 useRef 사용법"
tags: ["React", "학습", "Ref", "초급", "프론트엔드"]
series: "React 기초"
seriesOrder: 28
---

## Ref로 값 참조하기

### State와 Ref의 차이

컴포넌트가 일부 정보를 "기억"하되, **리렌더링을 트리거하고 싶지 않을 때** `useRef`를 사용합니다.

```jsx
import { useRef } from 'react';

const ref = useRef(0);
```

**`useRef` 반환값:**

```javascript
{
  current: 0  // 초기값
}
```

### State vs Ref 비교

| 특징 | useRef | useState |
|------|--------|----------|
| **반환값** | `{ current: value }` | `[value, setValue]` |
| **변경 시 리렌더링** | ❌ 안함 | ✅ 함 |
| **변경 가능 (Mutable)** | ✅ 가능 (`ref.current` 수정) | ❌ 불가 (setter 함수 사용) |
| **렌더링 중 읽기/쓰기** | ❌ 불가 | ✅ 가능 |

### 예제: 스톱워치

```jsx
import { useState, useRef } from 'react';

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>
        Start
      </button>
      <button onClick={handleStop}>
        Stop
      </button>
    </>
  );
}
```

**`intervalRef` 사용 이유:**

- `setInterval`의 ID를 저장
- 렌더링에 영향 주지 않음
- `handleStop`에서 접근 가능

### Ref 사용 시기

**Ref는 다음과 같은 경우에 사용합니다:**

- timeout ID 저장
- DOM 요소 저장 (다음 섹션에서)
- JSX 계산에 필요 없는 다른 객체 저장

### Ref 모범 사례

#### 1. **Ref를 탈출구로 취급하세요**

```jsx
// ✅ 좋음: 외부 시스템/브라우저 API
const intervalRef = useRef(null);
const videoRef = useRef(null);

// ❌ 나쁨: React가 관리해야 할 정보
const dataRef = useRef([]);  // state를 사용하세요!
```

#### 2. **렌더링 중에 `ref.current` 읽기/쓰기 금지**

```jsx
// ❌ 잘못됨: 렌더링 중 ref 읽기
function MyComponent() {
  const myRef = useRef(0);
  myRef.current = myRef.current + 1;  // 예측 불가능!
  return <h1>{myRef.current}</h1>;
}

// ✅ 올바름: 이벤트 핸들러에서 사용
function MyComponent() {
  const myRef = useRef(0);
  
  function handleClick() {
    myRef.current = myRef.current + 1;
    console.log(myRef.current);
  }
  
  return <button onClick={handleClick}>Click me</button>;
}
```

### Ref 내부 동작

**직접 구현한다면:**

```jsx
// React가 내부적으로 하는 일
function useRef(initialValue) {
  const [ref, unused] = useState({ current: initialValue });
  return ref;
}
```

### 예제: 클릭 카운터

```jsx
import { useRef } from 'react';

export default function Counter() {
  let countRef = useRef(0);

  function handleClick() {
    // 증가하지만 리렌더링 안됨!
    countRef.current = countRef.current + 1;
    alert('You clicked ' + countRef.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}
```

**버튼을 여러 번 눌러도 화면은 변하지 않지만, alert는 증가된 값을 표시합니다.**

### Vue와 비교

```html
<!-- Vue: ref()는 반응형 -->
<script setup>
import { ref } from 'vue'

const count = ref(0)

function increment() {
  count.value++  // 자동 리렌더링!
}
</script>

<template>
  <button @click="increment">{{ count }}</button>
</template>
```

```jsx
// React: useRef는 비반응형
import { useRef } from 'react'

function Counter() {
  const countRef = useRef(0)
  
  function increment() {
    countRef.current++  // 리렌더링 안됨!
  }
  
  return <button onClick={increment}>Click</button>
}
```

**차이점:**

- Vue: `ref()`는 반응형 (화면 업데이트)
- React: `useRef()`는 비반응형 (화면 업데이트 안됨)

---
