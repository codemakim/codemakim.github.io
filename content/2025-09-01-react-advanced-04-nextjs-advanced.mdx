---
title: "🚀 [React 라이브러리 4/4] Next.js 고급 - 서버 컴포넌트"
date: "2025-09-01"
description: "서버 컴포넌트가 번들을 줄이는 메커니즘, 서버 액션의 RPC 방식을 이해합니다"
tags: ["Next.js", "React", "고급"]
---

# Next.js 고급 기능 가이드

> Next.js 15의 고급 기능을 다루는 학습 자료

---

## 📚 목차

1. [서버 액션](#서버-액션)
2. [스트리밍 SSR](#스트리밍-ssr)
3. [ISR](#isr-incremental-static-regeneration)
4. [Middleware](#middleware)
5. [API Routes 고급](#api-routes-고급)
6. [이미지 최적화](#이미지-최적화)

---

## 서버 액션

### 개요

**Server Actions**는 서버에서 실행되는 비동기 함수입니다. (Next.js 14+)

### 🔍 서버 컴포넌트와 서버 액션의 동작 원리

**서버 컴포넌트가 해결하는 근본적 문제:**

전통적인 React (CSR):
```
브라우저가 HTML 받음 (거의 비어있음)
  ↓
JavaScript 번들 다운로드 (모든 컴포넌트 코드 포함!)
  ↓
React 실행
  ↓
API 호출로 데이터 페칭
  ↓
화면 렌더링

문제: 번들 크기 ↑, 초기 로딩 ↓, SEO ↓
```

서버 컴포넌트 (Next.js):
```
서버에서 컴포넌트 실행
  ↓
DB 직접 접근 (빠름!)
  ↓
완성된 HTML 생성
  ↓
HTML + 최소한의 JavaScript만 전송
  ↓
즉시 화면 표시

장점: 번들 크기 ↓, 초기 로딩 ↑, SEO ↑
```

### 🎯 서버 컴포넌트 vs 클라이언트 컴포넌트

**번들에 포함되는 것:**

```jsx
// 서버 컴포넌트 (기본)
async function UserList() {
  const users = await db.users.findMany();  // 서버에서 실행
  
  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}

// 브라우저에 전송되는 것:
// - HTML: <ul><li>John</li><li>Jane</li></ul>
// - JavaScript: 0KB! (컴포넌트 코드 전송 안됨)
```

```jsx
// 클라이언트 컴포넌트
'use client';

function Counter() {
  const [count, setCount] = useState(0);  // 브라우저에서 실행
  
  return <button onClick={() => setCount(count + 1)}>{count}</button>;
}

// 브라우저에 전송되는 것:
// - HTML: <button>0</button>
// - JavaScript: Counter 컴포넌트 전체 코드 + React runtime
```

### 🔍 서버 액션의 동작 원리

**기존 방식 (API Route):**
```
클라이언트 → POST /api/create-post
           ↓
       API Route 핸들러
           ↓
       DB에 저장
           ↓
       응답 반환
           ↓
     클라이언트가 받음

문제: 타입 안전성 ↓, 보일러플레이트 ↑
```

**서버 액션:**
```
클라이언트 → 서버 액션 호출 (RPC처럼!)
           ↓
       Next.js가 자동으로 POST 요청 생성
           ↓
       서버에서 함수 실행
           ↓
       DB에 저장
           ↓
       자동 캐시 무효화
           ↓
     결과 반환

장점: 타입 안전 ↑, 코드 간결 ↑, 자동 최적화
```

**실제 네트워크 요청:**
```
POST /_next/data/XYZ/actions/createPost
Content-Type: multipart/form-data

{
  "0": "title value",
  "1": "content value"
}
```

Next.js가 자동으로:
1. 폼 데이터를 직렬화
2. POST 요청 생성
3. 서버에서 함수 실행
4. 응답 처리
5. 캐시 무효화

### 💡 실무 TIP: "서버 컴포넌트의 장점은?"

**답변 예시:**

"서버 컴포넌트의 핵심 장점은 **번들 크기 제로**입니다.

**동작 원리:**
서버 컴포넌트는 서버에서만 실행되고, 결과 HTML만 클라이언트로 전송됩니다. 컴포넌트 코드 자체는 JavaScript 번들에 포함되지 않습니다.

**실무 효과:**
- 대시보드 페이지에 차트 라이브러리(1MB) 사용 시
  - CSR: 1MB를 브라우저가 다운로드
  - 서버 컴포넌트: 서버에서 차트 생성 → SVG/HTML만 전송 → 0KB!

**추가 장점:**
1. DB 직접 접근: API 레이어 불필요
2. 민감 정보 보호: API 키가 클라이언트 노출 안됨
3. SEO 최적화: 완성된 HTML 전송

**주의사항:**
인터랙티브 필요 시 클라이언트 컴포넌트 사용. 하지만 전체가 아니라 필요한 부분만 `'use client'`로 분리하여 번들 크기 최소화할 수 있습니다."

**특징:**
- API 라우트 불필요
- 타입 안전
- 폼 제출 최적화
- 자동 리다이렉트

### 기본 사용법

```jsx
// app/actions.js
'use server';

export async function createPost(formData) {
  const title = formData.get('title');
  const content = formData.get('content');
  
  // 데이터베이스에 저장
  await db.posts.create({
    data: { title, content }
  });
  
  // 캐시 무효화
  revalidatePath('/posts');
  
  // 리다이렉트
  redirect('/posts');
}
```

```jsx
// app/posts/new/page.jsx
import { createPost } from '../actions';

export default function NewPost() {
  return (
    <form action={createPost}>
      <input name="title" required />
      <textarea name="content" required />
      <button type="submit">Create Post</button>
    </form>
  );
}
```

### 클라이언트에서 호출

```jsx
'use client';

import { createPost } from './actions';
import { useState } from 'react';

export default function CreatePostForm() {
  const [pending, setPending] = useState(false);

  async function handleSubmit(formData) {
    setPending(true);
    await createPost(formData);
    setPending(false);
  }

  return (
    <form action={handleSubmit}>
      <input name="title" />
      <button type="submit" disabled={pending}>
        {pending ? 'Creating...' : 'Create'}
      </button>
    </form>
  );
}
```

### useFormStatus Hook

```jsx
'use client';

import { useFormStatus } from 'react-dom';

function SubmitButton() {
  const { pending } = useFormStatus();
  
  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Submitting...' : 'Submit'}
    </button>
  );
}

export default function Form() {
  return (
    <form action={createPost}>
      <input name="title" />
      <SubmitButton />
    </form>
  );
}
```

### useFormState Hook

```jsx
'use client';

import { useFormState } from 'react-dom';
import { createPost } from './actions';

export default function Form() {
  const [state, formAction] = useFormState(createPost, {
    message: '',
    errors: {}
  });

  return (
    <form action={formAction}>
      <input name="title" />
      {state.errors?.title && <p>{state.errors.title}</p>}
      
      <input name="email" />
      {state.errors?.email && <p>{state.errors.email}</p>}
      
      <button type="submit">Submit</button>
      {state.message && <p>{state.message}</p>}
    </form>
  );
}
```

### 서버 액션 검증

```jsx
'use server';

import { z } from 'zod';
import { revalidatePath } from 'next/cache';

const schema = z.object({
  title: z.string().min(1).max(100),
  content: z.string().min(10),
});

export async function createPost(prevState, formData) {
  const validatedFields = schema.safeParse({
    title: formData.get('title'),
    content: formData.get('content'),
  });

  if (!validatedFields.success) {
    return {
      errors: validatedFields.error.flatten().fieldErrors,
      message: 'Validation failed',
    };
  }

  const { title, content } = validatedFields.data;

  try {
    await db.posts.create({
      data: { title, content },
    });
  } catch (error) {
    return {
      message: 'Database error',
    };
  }

  revalidatePath('/posts');
  redirect('/posts');
}
```

---

## 스트리밍 SSR

### Suspense를 사용한 스트리밍

```jsx
import { Suspense } from 'react';

export default function Page() {
  return (
    <div>
      <h1>My Blog</h1>
      
      {/* 즉시 렌더링 */}
      <Suspense fallback={<PostsSkeleton />}>
        <Posts />
      </Suspense>
      
      {/* 즉시 렌더링 */}
      <Suspense fallback={<CommentsSkeleton />}>
        <Comments />
      </Suspense>
    </div>
  );
}

async function Posts() {
  const posts = await fetchPosts();
  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}

async function Comments() {
  const comments = await fetchComments();
  return (
    <ul>
      {comments.map(comment => (
        <li key={comment.id}>{comment.text}</li>
      ))}
    </ul>
  );
}
```

### Loading.js

```jsx
// app/dashboard/loading.jsx
export default function Loading() {
  return <DashboardSkeleton />;
}
```

```jsx
// app/dashboard/page.jsx
export default async function Dashboard() {
  const data = await fetchDashboardData();
  return <DashboardContent data={data} />;
}
```

### 중첩된 Suspense

```jsx
export default function Page() {
  return (
    <Suspense fallback={<PageSkeleton />}>
      <Header />
      
      <Suspense fallback={<NavSkeleton />}>
        <Nav />
      </Suspense>
      
      <Main>
        <Suspense fallback={<PostsSkeleton />}>
          <Posts />
        </Suspense>
        
        <Sidebar>
          <Suspense fallback={<WidgetSkeleton />}>
            <PopularPosts />
          </Suspense>
        </Sidebar>
      </Main>
    </Suspense>
  );
}
```

---

## ISR (Incremental Static Regeneration)

### 기본 ISR

```jsx
// app/posts/[id]/page.jsx
export const revalidate = 60; // 60초마다 재생성

export default async function Post({ params }) {
  const post = await fetchPost(params.id);
  
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
    </article>
  );
}

export async function generateStaticParams() {
  const posts = await fetchPosts();
  
  return posts.map((post) => ({
    id: post.id.toString(),
  }));
}
```

### On-Demand Revalidation

```jsx
// app/api/revalidate/route.js
import { revalidatePath, revalidateTag } from 'next/cache';
import { NextResponse } from 'next/server';

export async function POST(request) {
  const { path, tag } = await request.json();

  if (path) {
    revalidatePath(path);
    return NextResponse.json({ revalidated: true, path });
  }

  if (tag) {
    revalidateTag(tag);
    return NextResponse.json({ revalidated: true, tag });
  }

  return NextResponse.json({ revalidated: false });
}
```

```jsx
// 특정 경로 재검증
fetch('/api/revalidate', {
  method: 'POST',
  body: JSON.stringify({ path: '/posts/1' }),
});

// 태그로 재검증
fetch('/api/revalidate', {
  method: 'POST',
  body: JSON.stringify({ tag: 'posts' }),
});
```

### 태그 기반 캐시

```jsx
// app/posts/page.jsx
export default async function Posts() {
  const posts = await fetch('https://api.example.com/posts', {
    next: { tags: ['posts'] }
  }).then(res => res.json());

  return (
    <ul>
      {posts.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

```jsx
// app/actions.js
'use server';

import { revalidateTag } from 'next/cache';

export async function createPost(data) {
  await db.posts.create({ data });
  revalidateTag('posts'); // 'posts' 태그를 가진 모든 캐시 무효화
}
```

---

## Middleware

### 기본 Middleware

```jsx
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  // 요청 로깅
  console.log('Request:', request.nextUrl.pathname);

  // 헤더 추가
  const response = NextResponse.next();
  response.headers.set('x-custom-header', 'my-value');

  return response;
}

export const config = {
  matcher: ['/dashboard/:path*', '/admin/:path*'],
};
```

### 인증 Middleware

```jsx
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  const token = request.cookies.get('token');

  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: '/dashboard/:path*',
};
```

### 국제화 Middleware

```jsx
// middleware.js
import { NextResponse } from 'next/server';

const locales = ['en', 'ko', 'ja'];
const defaultLocale = 'en';

export function middleware(request) {
  const pathname = request.nextUrl.pathname;

  // 이미 로케일이 있으면 패스
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  );

  if (pathnameHasLocale) return;

  // Accept-Language 헤더에서 로케일 가져오기
  const locale = request.headers.get('accept-language')?.split(',')[0] || defaultLocale;

  // 로케일 추가하여 리다이렉트
  return NextResponse.redirect(
    new URL(`/${locale}${pathname}`, request.url)
  );
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
```

### A/B 테스트 Middleware

```jsx
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  // 쿠키에서 버킷 확인
  let bucket = request.cookies.get('bucket');

  if (!bucket) {
    // 랜덤하게 A 또는 B 할당
    bucket = Math.random() < 0.5 ? 'a' : 'b';
    const response = NextResponse.next();
    response.cookies.set('bucket', bucket);
    return response;
  }

  // 버킷에 따라 다른 페이지로 리라이트
  if (bucket === 'b') {
    return NextResponse.rewrite(new URL('/experiment-b', request.url));
  }

  return NextResponse.next();
}
```

---

## API Routes 고급

### Route Handlers (App Router)

```jsx
// app/api/posts/route.js
import { NextResponse } from 'next/server';

// GET /api/posts
export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const page = searchParams.get('page') || '1';

  const posts = await db.posts.findMany({
    skip: (parseInt(page) - 1) * 10,
    take: 10,
  });

  return NextResponse.json(posts);
}

// POST /api/posts
export async function POST(request) {
  const body = await request.json();

  const post = await db.posts.create({
    data: body,
  });

  return NextResponse.json(post, { status: 201 });
}
```

### 동적 Route Handlers

```jsx
// app/api/posts/[id]/route.js
import { NextResponse } from 'next/server';

// GET /api/posts/:id
export async function GET(request, { params }) {
  const post = await db.posts.findUnique({
    where: { id: params.id },
  });

  if (!post) {
    return NextResponse.json(
      { error: 'Post not found' },
      { status: 404 }
    );
  }

  return NextResponse.json(post);
}

// PUT /api/posts/:id
export async function PUT(request, { params }) {
  const body = await request.json();

  const post = await db.posts.update({
    where: { id: params.id },
    data: body,
  });

  return NextResponse.json(post);
}

// DELETE /api/posts/:id
export async function DELETE(request, { params }) {
  await db.posts.delete({
    where: { id: params.id },
  });

  return new NextResponse(null, { status: 204 });
}
```

### 스트리밍 응답

```jsx
// app/api/stream/route.js
export async function GET() {
  const encoder = new TextEncoder();

  const stream = new ReadableStream({
    async start(controller) {
      for (let i = 0; i < 10; i++) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
        controller.enqueue(encoder.encode(`data: ${i}\n\n`));
      }
      controller.close();
    },
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

### CORS 설정

```jsx
// app/api/posts/route.js
import { NextResponse } from 'next/server';

export async function GET(request) {
  const posts = await fetchPosts();

  return NextResponse.json(posts, {
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}

export async function OPTIONS(request) {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}
```

---

## 이미지 최적화

### next/image 고급 사용

```jsx
import Image from 'next/image';

export default function Gallery() {
  return (
    <div>
      {/* 반응형 이미지 */}
      <Image
        src="/hero.jpg"
        alt="Hero"
        fill
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
        style={{ objectFit: 'cover' }}
      />

      {/* 우선순위 이미지 (LCP 최적화) */}
      <Image
        src="/hero.jpg"
        alt="Hero"
        width={1200}
        height={600}
        priority
      />

      {/* 블러 플레이스홀더 */}
      <Image
        src="/photo.jpg"
        alt="Photo"
        width={500}
        height={300}
        placeholder="blur"
        blurDataURL="data:image/jpeg;base64,..."
      />

      {/* 외부 이미지 */}
      <Image
        src="https://example.com/photo.jpg"
        alt="External"
        width={500}
        height={300}
        unoptimized={false}
      />
    </div>
  );
}
```

### 이미지 로더

```jsx
// next.config.js
module.exports = {
  images: {
    loader: 'custom',
    loaderFile: './image-loader.js',
  },
};
```

```jsx
// image-loader.js
export default function cloudinaryLoader({ src, width, quality }) {
  const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`];
  return `https://res.cloudinary.com/demo/image/upload/${params.join(',')}${src}`;
}
```

### 동적 블러 플레이스홀더

```jsx
import { getPlaiceholder } from 'plaiceholder';

export default async function Post({ params }) {
  const post = await fetchPost(params.id);
  
  const { base64 } = await getPlaiceholder(post.imageUrl);

  return (
    <Image
      src={post.imageUrl}
      alt={post.title}
      width={800}
      height={600}
      placeholder="blur"
      blurDataURL={base64}
    />
  );
}
```

---

## 실전 예제: 블로그 플랫폼

```jsx
// app/posts/page.jsx
export const revalidate = 3600; // 1시간마다

export default async function Posts() {
  const posts = await fetch('https://api.example.com/posts', {
    next: { tags: ['posts'] }
  }).then(res => res.json());

  return (
    <div>
      <h1>Blog Posts</h1>
      <Suspense fallback={<PostsSkeleton />}>
        <PostList posts={posts} />
      </Suspense>
    </div>
  );
}
```

```jsx
// app/actions.js
'use server';

import { revalidateTag } from 'next/cache';
import { redirect } from 'next/navigation';

export async function createPost(formData) {
  const title = formData.get('title');
  const content = formData.get('content');

  await db.posts.create({
    data: { title, content },
  });

  revalidateTag('posts');
  redirect('/posts');
}

export async function deletePost(id) {
  await db.posts.delete({
    where: { id },
  });

  revalidateTag('posts');
}
```

```jsx
// middleware.js
import { NextResponse } from 'next/server';

export function middleware(request) {
  const token = request.cookies.get('auth-token');

  // 인증 필요한 경로
  if (request.nextUrl.pathname.startsWith('/admin')) {
    if (!token) {
      return NextResponse.redirect(new URL('/login', request.url));
    }
  }

  // 로깅
  console.log(`[${new Date().toISOString()}] ${request.method} ${request.url}`);

  return NextResponse.next();
}

export const config = {
  matcher: ['/admin/:path*', '/api/:path*'],
};
```

---

## Nuxt와 비교

| 기능 | Next.js | Nuxt |
|------|---------|------|
| **서버 액션** | Server Actions | Server Routes |
| **ISR** | revalidate | ISR (Nitro) |
| **Middleware** | middleware.js | Server Middleware |
| **이미지 최적화** | next/image | nuxt/image |
| **API Routes** | app/api | server/api |

```javascript
// Nuxt: Server Routes
// server/api/posts.post.js
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const post = await db.posts.create({ data: body })
  return post
})
```

```jsx
// Next.js: Route Handlers
// app/api/posts/route.js
export async function POST(request) {
  const body = await request.json()
  const post = await db.posts.create({ data: body })
  return NextResponse.json(post)
}
```

---

## 다음 단계

### 학습 체크리스트

- [ ] 서버 액션을 사용할 수 있다
- [ ] Suspense로 스트리밍 SSR을 구현할 수 있다
- [ ] ISR을 활용할 수 있다
- [ ] Middleware로 요청을 처리할 수 있다
- [ ] Route Handlers를 작성할 수 있다
- [ ] 이미지를 최적화할 수 있다
- [ ] 캐시 전략을 이해한다

### 추가 학습 자료

- [Next.js 공식 문서](https://nextjs.org/docs)
- [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)
- [Caching](https://nextjs.org/docs/app/building-your-application/caching)

---

**작성일**: 2025-10-11  
**대상**: Next.js 중급 개발자

---

모든 항목을 체크했다면 다음 주제로 넘어가세요! 🚀

