---
title: "ğŸš€ [React ë¼ì´ë¸ŒëŸ¬ë¦¬ 8/8] React Query - ì‹¤ì „ ì˜ˆì œ & ë‹¤ìŒ ë‹¨ê³„"
date: "2025-08-26"
description: "ë¸”ë¡œê·¸ ì• í”Œë¦¬ì¼€ì´ì…˜ êµ¬í˜„ ë° í•™ìŠµ ì²´í¬ë¦¬ìŠ¤íŠ¸"
tags: ["React", "ê³ ê¸‰", "í”„ë¡ íŠ¸ì—”ë“œ"]
series: "React ë¼ì´ë¸ŒëŸ¬ë¦¬"
seriesOrder: 53
---

# React Query ê°€ì´ë“œ - ì‹¤ì „ ì˜ˆì œ & ë‹¤ìŒ ë‹¨ê³„

> TanStack Query v5ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ë°ì´í„° í˜ì¹­ í•™ìŠµ ìë£Œ  
> ì¶œì²˜: [TanStack Query Documentation](https://tanstack.com/query/)

---

## ì‹¤ì „ ì˜ˆì œ & ë‹¤ìŒ ë‹¨ê³„
ì‹¤ì „ ì˜ˆì œ & ë‹¤ìŒ ë‹¨ê³„

ê³ ê¸‰ íŒ¨í„´

### 1. Query Cancellation

```jsx
function Search() {
  const [searchTerm, setSearchTerm] = useState('');

  const { data, isLoading } = useQuery({
    queryKey: ['search', searchTerm],
    queryFn: async ({ signal }) => {
      const response = await fetch(`/api/search?q=${searchTerm}`, {
        signal,  // AbortSignal ì „ë‹¬
      });
      return response.json();
    },
    enabled: searchTerm.length > 0,
  });

  return (
    <div>
      <input
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      />
      {isLoading && <div>Searching...</div>}
      <SearchResults results={data} />
    </div>
  );
}
```

### 2. Dependent Queries

```jsx
function UserProjects({ userId }) {
  const { data: user } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
  });

  const { data: projects } = useQuery({
    queryKey: ['projects', user?.id],
    queryFn: () => fetchProjects(user.id),
    enabled: !!user?.id,  // userê°€ ë¡œë“œëœ í›„ì—ë§Œ ì‹¤í–‰
  });

  return <ProjectList projects={projects} />;
}
```

### 3. Query Keys Factory

```javascript
// queryKeys.js
export const userKeys = {
  all: ['users'],
  lists: () => [...userKeys.all, 'list'],
  list: (filters) => [...userKeys.lists(), { filters }],
  details: () => [...userKeys.all, 'detail'],
  detail: (id) => [...userKeys.details(), id],
};

// ì‚¬ìš©
useQuery({
  queryKey: userKeys.detail(userId),
  queryFn: () => fetchUser(userId),
});

// ëª¨ë“  user ì¿¼ë¦¬ ë¬´íš¨í™”
queryClient.invalidateQueries({ queryKey: userKeys.all });

// íŠ¹ì • user ë¬´íš¨í™”
queryClient.invalidateQueries({ queryKey: userKeys.detail(userId) });
```

### 4. Suspense Mode

```jsx
import { Suspense } from 'react';

function App() {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      <Users />
    </Suspense>
  );
}

function Users() {
  const { data } = useQuery({
    queryKey: ['users'],
    queryFn: fetchUsers,
    suspense: true,  // Suspense ëª¨ë“œ í™œì„±í™”
  });

  return <UserList users={data} />;
}
```

### 5. Retry Logic

```javascript
useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  retry: 3,  // 3ë²ˆ ì¬ì‹œë„
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  // 1ì´ˆ, 2ì´ˆ, 4ì´ˆ... ìµœëŒ€ 30ì´ˆ
});

// ì¡°ê±´ë¶€ ì¬ì‹œë„
useQuery({
  queryKey: ['users'],
  queryFn: fetchUsers,
  retry: (failureCount, error) => {
    // 404ëŠ” ì¬ì‹œë„ ì•ˆí•¨
    if (error.status === 404) return false;
    // ìµœëŒ€ 3ë²ˆ
    return failureCount < 3;
  },
});
```

### 6. Query Filters

```javascript
const queryClient = useQueryClient();

// ëª¨ë“  ì¿¼ë¦¬ ë¬´íš¨í™”
queryClient.invalidateQueries();

// íŠ¹ì • ì ‘ë‘ì‚¬ ì¿¼ë¦¬ ë¬´íš¨í™”
queryClient.invalidateQueries({ queryKey: ['posts'] });

// ì¡°ê±´ë¶€ ë¬´íš¨í™”
queryClient.invalidateQueries({
  predicate: (query) => 
    query.queryKey[0] === 'posts' && 
    query.state.data?.isArchived
});

// ì¿¼ë¦¬ ì œê±°
queryClient.removeQueries({ queryKey: ['posts'] });

// ì¿¼ë¦¬ ë°ì´í„° ì„¤ì •
queryClient.setQueriesData(
  { queryKey: ['posts'] },
  (oldData) => oldData.filter(post => !post.isDeleted)
);
```

---


## ì‹¤ì „ ì˜ˆì œ: ë¸”ë¡œê·¸ ì• í”Œë¦¬ì¼€ì´ì…˜

```jsx
// api/posts.js
export const postKeys = {
  all: ['posts'],
  lists: () => [...postKeys.all, 'list'],
  list: (filters) => [...postKeys.lists(), filters],
  details: () => [...postKeys.all, 'detail'],
  detail: (id) => [...postKeys.details(), id],
};

export async function fetchPosts({ page = 1, limit = 10 } = {}) {
  const response = await fetch(`/api/posts?page=${page}&limit=${limit}`);
  if (!response.ok) throw new Error('Failed to fetch posts');
  return response.json();
}

export async function fetchPost(id) {
  const response = await fetch(`/api/posts/${id}`);
  if (!response.ok) throw new Error('Failed to fetch post');
  return response.json();
}

export async function createPost(data) {
  const response = await fetch('/api/posts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!response.ok) throw new Error('Failed to create post');
  return response.json();
}

export async function updatePost({ id, data }) {
  const response = await fetch(`/api/posts/${id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!response.ok) throw new Error('Failed to update post');
  return response.json();
}

export async function deletePost(id) {
  const response = await fetch(`/api/posts/${id}`, {
    method: 'DELETE',
  });
  if (!response.ok) throw new Error('Failed to delete post');
}
```

```jsx
// components/PostList.jsx
import { useQuery } from '@tanstack/react-query';
import { fetchPosts, postKeys } from '../api/posts';

export default function PostList() {
  const [page, setPage] = useState(1);

  const { data, isLoading, error } = useQuery({
    queryKey: postKeys.list({ page }),
    queryFn: () => fetchPosts({ page }),
    placeholderData: (previousData) => previousData,
  });

  if (isLoading && !data) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <div>
      {data.posts.map(post => (
        <PostCard key={post.id} post={post} />
      ))}
      
      <Pagination
        page={page}
        totalPages={data.totalPages}
        onPageChange={setPage}
      />
    </div>
  );
}
```

```jsx
// components/CreatePost.jsx
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { createPost, postKeys } from '../api/posts';

export default function CreatePost() {
  const queryClient = useQueryClient();
  const [title, setTitle] = useState('');
  const [content, setContent] = useState('');

  const mutation = useMutation({
    mutationFn: createPost,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
      setTitle('');
      setContent('');
      toast.success('Post created!');
    },
    onError: (error) => {
      toast.error(error.message);
    },
  });

  function handleSubmit(e) {
    e.preventDefault();
    mutation.mutate({ title, content });
  }

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        placeholder="Title"
        required
      />
      <textarea
        value={content}
        onChange={(e) => setContent(e.target.value)}
        placeholder="Content"
        required
      />
      <button type="submit" disabled={mutation.isPending}>
        {mutation.isPending ? 'Creating...' : 'Create Post'}
      </button>
    </form>
  );
}
```

---