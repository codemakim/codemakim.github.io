---
title: "[React 기초 4-7/9] Effect 의존성 제거하기"
date: "2025-08-07"
description: "불필요한 Effect 의존성을 제거해 재실행을 줄이는 방법"
tags: ["React", "학습", "Effect", "의존성", "최적화"]
series: "React 기초"
seriesOrder: 33
---

# Effect 의존성 제거하기

Effect가 너무 자주 재실행된다면 의존성을 줄일 수 있는지 검토해야 한다.

## 의존성 문제의 근본 원인

Effect가 너무 자주 실행되는 주된 이유는 **불필요한 의존성** 때문이다. 특히 객체와 함수가 문제가 된다.

### 왜 객체와 함수가 문제인가?

JavaScript에서 객체와 함수는 **매 렌더링마다 새로 생성**된다.

```jsx
function Component() {
  // 매 렌더링마다 새 객체
  const options = { x: 1, y: 2 };

  // 매 렌더링마다 새 함수
  const handleClick = () => {};

  // 매 렌더링마다 새 배열
  const items = [1, 2, 3];
}
```

React는 `===`로 비교하므로:

```jsx
{ x: 1 } === { x: 1 }  // false
() => {} === () => {}  // false
[1, 2] === [1, 2]      // false
```

따라서 의존성 배열에 객체나 함수를 넣으면 매 렌더링마다 Effect가 실행된다.

## 불필요한 의존성 제거 - 3가지 해결법

### 1. 객체 의존성 해결

**나쁜 예: 객체를 의존성으로**

```jsx
function ChatRoom({ options }) {
  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // 매 렌더링마다 재연결
}

function App() {
  const [isDark, setIsDark] = useState(false);

  // 매 렌더링마다 새 객체 생성
  const options = { serverUrl: "https://localhost:1234", roomId: "music" };

  return <ChatRoom options={options} />;
}
```

**문제:** `App`이 리렌더링될 때마다 (예: `isDark` 변경) 새 `options` 객체가 생성되고, `ChatRoom`의 Effect가 재실행된다.

**해결법 A: 객체를 분해하여 원시 값만 의존성으로**

```jsx
function ChatRoom({ options }) {
  // 객체에서 필요한 값만 추출
  const { serverUrl, roomId } = options;

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [serverUrl, roomId]); // 원시 값만 의존성으로
}
```

**해결법 B: 부모에서 원시 값을 전달**

```jsx
// 더 나은 방법: 처음부터 원시 값을 전달
function App() {
  const [isDark, setIsDark] = useState(false);

  return <ChatRoom serverUrl="https://localhost:1234" roomId="music" />;
}

function ChatRoom({ serverUrl, roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [serverUrl, roomId]);
}
```

### 2. 함수 의존성 해결

**나쁜 예: 함수를 의존성으로**

```jsx
function ChatRoom({ getOptions }) {
  useEffect(() => {
    const options = getOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [getOptions]); // 매 렌더링마다 재연결
}
```

**해결법 A: 함수를 Effect 안으로**

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    // 함수를 Effect 내부에 정의
    function getOptions() {
      return {
        serverUrl: "https://localhost:1234",
        roomId: roomId,
      };
    }

    const options = getOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
}
```

이제 `roomId`만 의존성이다.

**해결법 B: 객체를 Effect 내부에서 직접 생성**

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    // 객체를 직접 생성 (함수 불필요)
    const connection = createConnection({
      serverUrl: "https://localhost:1234",
      roomId: roomId,
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
}
```

더 간단하고 명확하다.

### 3. 외부 상수는 의존성에서 제거

컴포넌트 외부에 정의된 값은 의존성에 포함할 필요가 없다.

```jsx
// 컴포넌트 외부의 상수
const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // serverUrl은 의존성 불필요 (변하지 않음)
}
```

**왜?** `serverUrl`은 렌더링과 무관하게 항상 같은 값이기 때문이다.

## State로부터 다음 state 계산하기

이전 state를 기반으로 새 state를 계산할 때는 업데이터 함수를 사용해야 한다.

**나쁜 예: state를 의존성으로**

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.on("message", (receivedMessage) => {
      // messages를 읽어서 새 배열 생성
      setMessages([...messages, receivedMessage]);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, messages]); // messages가 변경될 때마다 재연결
}
```

**문제:**

- 메시지를 받을 때마다 `messages`가 변경된다
- `messages`가 변경될 때마다 Effect가 재실행된다
- 채팅 연결이 끊기고 다시 연결된다

**좋은 예: 업데이터 함수 사용**

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.on("message", (receivedMessage) => {
      // 업데이터 함수: 이전 messages를 인자로 받음
      setMessages((msgs) => [...msgs, receivedMessage]);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // messages는 의존성이 아님
}
```

**업데이터 함수의 동작:**

```jsx
setMessages((msgs) => [...msgs, newMessage]);
```

- `msgs`: 이전 `messages` 값 (React가 제공)
- 반환값: 새 `messages` 값

Effect는 `messages`를 읽지 않으므로 의존성에 포함할 필요가 없다.

## 값을 읽되 "반응"하고 싶지 않을 때

최신 값은 읽고 싶지만 Effect를 재실행하고 싶지 않다면 Effect Event를 사용한다.

**나쁜 예: theme 변경 시 재연결**

```jsx
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on("connected", () => {
      showNotification("Connected!", theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]); // theme 변경 시에도 재연결
}
```

**좋은 예: Effect Event 사용 (실험적)**

```jsx
function ChatRoom({ roomId, theme }) {
  // Effect Event로 비반응형 로직 분리
  const onConnected = useEffectEvent(() => {
    showNotification("Connected!", theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on("connected", onConnected);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // theme은 의존성 아님
}
```

**현재 사용 가능한 방법: ref 사용**

```jsx
function ChatRoom({ roomId, theme }) {
  const themeRef = useRef(theme);

  // 항상 최신 theme를 ref에 저장
  useEffect(() => {
    themeRef.current = theme;
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on("connected", () => {
      showNotification("Connected!", themeRef.current);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // theme은 의존성 아님
}
```

## 실전 패턴: 복잡한 의존성 문제 해결

### 패턴 1: 필요한 값만 추출

```jsx
// 나쁜 예
function Component({ user }) {
  useEffect(() => {
    console.log(user.name);
  }, [user]); // user 객체 전체가 의존성
}

// 좋은 예
function Component({ user }) {
  const userName = user.name;

  useEffect(() => {
    console.log(userName);
  }, [userName]); // 원시 값만 의존성
}
```

### 패턴 2: 로직을 컴포넌트 외부로

```jsx
// 나쁜 예
function Component({ data }) {
  function processData(data) {
    // 복잡한 처리...
  }

  useEffect(() => {
    processData(data);
  }, [data, processData]); // 함수가 의존성
}

// 좋은 예
function processData(data) {
  // 복잡한 처리...
}

function Component({ data }) {
  useEffect(() => {
    processData(data);
  }, [data]); // 함수는 외부에 있으므로 의존성 아님
}
```

### 패턴 3: 여러 Effect로 분리

```jsx
// 나쁜 예: 관련 없는 의존성이 섞임
function Component({ roomId, userId }) {
  useEffect(() => {
    // roomId에만 관련된 로직
    connectToRoom(roomId);

    // userId에만 관련된 로직
    loadUserProfile(userId);
  }, [roomId, userId]); // 둘 중 하나만 변경되어도 둘 다 실행
}

// 좋은 예: 독립적인 Effect로 분리
function Component({ roomId, userId }) {
  useEffect(() => {
    connectToRoom(roomId);
  }, [roomId]);

  useEffect(() => {
    loadUserProfile(userId);
  }, [userId]);
}
```

## 의존성 린터 무시하지 말 것

React는 의존성이 올바른지 확인하는 린터 규칙이 있다.

```jsx
// 린터 경고
useEffect(() => {
  // roomId를 사용하는데...
  const connection = createConnection(roomId);
  connection.connect();
}, []); // 의존성에 없음

// 오류 메시지:
// React Hook useEffect has a missing dependency: 'roomId'
```

**절대 하지 말 것:**

```jsx
// 나쁜 예: 린터 무시
useEffect(() => {
  const connection = createConnection(roomId);
  connection.connect();
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, []);
```

이렇게 하면 버그가 발생한다. 대신 위에서 설명한 패턴을 사용하여 의존성을 올바르게 제거해야 한다.

## 정리

- 객체와 함수는 매 렌더링마다 새로 생성되므로 의존성 문제를 일으킨다
- 객체를 분해하여 원시 값만 의존성으로 사용한다
- 함수는 Effect 내부로 옮기거나 컴포넌트 외부로 옮긴다
- 외부 상수는 의존성에 포함하지 않는다
- state 업데이트 시 업데이터 함수를 사용하여 의존성을 제거한다
- 값을 읽되 반응하고 싶지 않을 때는 ref나 Effect Event를 사용한다
- 린터 경고를 무시하지 말고 올바르게 해결한다
